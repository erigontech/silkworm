// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: txpool/mining.proto
#ifndef GRPC_txpool_2fmining_2eproto__INCLUDED
#define GRPC_txpool_2fmining_2eproto__INCLUDED

#include "txpool/mining.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace txpool {

class Mining final {
 public:
  static constexpr char const* service_full_name() {
    return "txpool.Mining";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Version returns the service version number
    virtual ::grpc::Status Version(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::VersionReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>> AsyncVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    // subscribe to pending blocks event
    std::unique_ptr< ::grpc::ClientReaderInterface< ::txpool::OnPendingBlockReply>> OnPendingBlock(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::txpool::OnPendingBlockReply>>(OnPendingBlockRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingBlockReply>> AsyncOnPendingBlock(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingBlockReply>>(AsyncOnPendingBlockRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingBlockReply>> PrepareAsyncOnPendingBlock(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingBlockReply>>(PrepareAsyncOnPendingBlockRaw(context, request, cq));
    }
    // subscribe to mined blocks event
    std::unique_ptr< ::grpc::ClientReaderInterface< ::txpool::OnMinedBlockReply>> OnMinedBlock(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::txpool::OnMinedBlockReply>>(OnMinedBlockRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnMinedBlockReply>> AsyncOnMinedBlock(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnMinedBlockReply>>(AsyncOnMinedBlockRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnMinedBlockReply>> PrepareAsyncOnMinedBlock(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnMinedBlockReply>>(PrepareAsyncOnMinedBlockRaw(context, request, cq));
    }
    // subscribe to pending blocks event
    std::unique_ptr< ::grpc::ClientReaderInterface< ::txpool::OnPendingLogsReply>> OnPendingLogs(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::txpool::OnPendingLogsReply>>(OnPendingLogsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingLogsReply>> AsyncOnPendingLogs(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingLogsReply>>(AsyncOnPendingLogsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingLogsReply>> PrepareAsyncOnPendingLogs(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingLogsReply>>(PrepareAsyncOnPendingLogsRaw(context, request, cq));
    }
    // GetWork returns a work package for external miner.
    //
    // The work package consists of 3 strings:
    //   result[0] - 32 bytes hex encoded current block header pow-hash
    //   result[1] - 32 bytes hex encoded seed hash used for DAG
    //   result[2] - 32 bytes hex encoded boundary condition ("target"), 2^256/difficulty
    //   result[3] - hex encoded block number
    virtual ::grpc::Status GetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::txpool::GetWorkReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::GetWorkReply>> AsyncGetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::GetWorkReply>>(AsyncGetWorkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::GetWorkReply>> PrepareAsyncGetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::GetWorkReply>>(PrepareAsyncGetWorkRaw(context, request, cq));
    }
    // SubmitWork can be used by external miner to submit their POW solution.
    // It returns an indication if the work was accepted.
    // Note either an invalid solution, a stale work a non-existent work will return false.
    virtual ::grpc::Status SubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::txpool::SubmitWorkReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitWorkReply>> AsyncSubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitWorkReply>>(AsyncSubmitWorkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitWorkReply>> PrepareAsyncSubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitWorkReply>>(PrepareAsyncSubmitWorkRaw(context, request, cq));
    }
    // SubmitHashRate can be used for remote miners to submit their hash rate.
    // This enables the node to report the combined hash rate of all miners
    // which submit work through this node.
    //
    // It accepts the miner hash rate and an identifier which must be unique
    // between nodes.
    virtual ::grpc::Status SubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::txpool::SubmitHashRateReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitHashRateReply>> AsyncSubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitHashRateReply>>(AsyncSubmitHashRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitHashRateReply>> PrepareAsyncSubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitHashRateReply>>(PrepareAsyncSubmitHashRateRaw(context, request, cq));
    }
    // HashRate returns the current hashrate for local CPU miner and remote miner.
    virtual ::grpc::Status HashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::txpool::HashRateReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::HashRateReply>> AsyncHashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::HashRateReply>>(AsyncHashRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::HashRateReply>> PrepareAsyncHashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::HashRateReply>>(PrepareAsyncHashRateRaw(context, request, cq));
    }
    // Mining returns an indication if this node is currently mining and it's mining configuration
    virtual ::grpc::Status Mining(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::txpool::MiningReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::MiningReply>> AsyncMining(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::MiningReply>>(AsyncMiningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::MiningReply>> PrepareAsyncMining(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::txpool::MiningReply>>(PrepareAsyncMiningRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Version returns the service version number
      virtual void Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // subscribe to pending blocks event
      virtual void OnPendingBlock(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest* request, ::grpc::ClientReadReactor< ::txpool::OnPendingBlockReply>* reactor) = 0;
      // subscribe to mined blocks event
      virtual void OnMinedBlock(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest* request, ::grpc::ClientReadReactor< ::txpool::OnMinedBlockReply>* reactor) = 0;
      // subscribe to pending blocks event
      virtual void OnPendingLogs(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest* request, ::grpc::ClientReadReactor< ::txpool::OnPendingLogsReply>* reactor) = 0;
      // GetWork returns a work package for external miner.
      //
      // The work package consists of 3 strings:
      //   result[0] - 32 bytes hex encoded current block header pow-hash
      //   result[1] - 32 bytes hex encoded seed hash used for DAG
      //   result[2] - 32 bytes hex encoded boundary condition ("target"), 2^256/difficulty
      //   result[3] - hex encoded block number
      virtual void GetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest* request, ::txpool::GetWorkReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest* request, ::txpool::GetWorkReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // SubmitWork can be used by external miner to submit their POW solution.
      // It returns an indication if the work was accepted.
      // Note either an invalid solution, a stale work a non-existent work will return false.
      virtual void SubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest* request, ::txpool::SubmitWorkReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest* request, ::txpool::SubmitWorkReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // SubmitHashRate can be used for remote miners to submit their hash rate.
      // This enables the node to report the combined hash rate of all miners
      // which submit work through this node.
      //
      // It accepts the miner hash rate and an identifier which must be unique
      // between nodes.
      virtual void SubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest* request, ::txpool::SubmitHashRateReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest* request, ::txpool::SubmitHashRateReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // HashRate returns the current hashrate for local CPU miner and remote miner.
      virtual void HashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest* request, ::txpool::HashRateReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest* request, ::txpool::HashRateReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Mining returns an indication if this node is currently mining and it's mining configuration
      virtual void Mining(::grpc::ClientContext* context, const ::txpool::MiningRequest* request, ::txpool::MiningReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Mining(::grpc::ClientContext* context, const ::txpool::MiningRequest* request, ::txpool::MiningReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>* AsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::txpool::OnPendingBlockReply>* OnPendingBlockRaw(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingBlockReply>* AsyncOnPendingBlockRaw(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingBlockReply>* PrepareAsyncOnPendingBlockRaw(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::txpool::OnMinedBlockReply>* OnMinedBlockRaw(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::txpool::OnMinedBlockReply>* AsyncOnMinedBlockRaw(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::txpool::OnMinedBlockReply>* PrepareAsyncOnMinedBlockRaw(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::txpool::OnPendingLogsReply>* OnPendingLogsRaw(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingLogsReply>* AsyncOnPendingLogsRaw(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::txpool::OnPendingLogsReply>* PrepareAsyncOnPendingLogsRaw(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::GetWorkReply>* AsyncGetWorkRaw(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::GetWorkReply>* PrepareAsyncGetWorkRaw(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitWorkReply>* AsyncSubmitWorkRaw(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitWorkReply>* PrepareAsyncSubmitWorkRaw(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitHashRateReply>* AsyncSubmitHashRateRaw(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::SubmitHashRateReply>* PrepareAsyncSubmitHashRateRaw(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::HashRateReply>* AsyncHashRateRaw(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::HashRateReply>* PrepareAsyncHashRateRaw(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::MiningReply>* AsyncMiningRaw(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::txpool::MiningReply>* PrepareAsyncMiningRaw(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Version(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::VersionReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::VersionReply>> AsyncVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::VersionReply>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::VersionReply>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::VersionReply>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::txpool::OnPendingBlockReply>> OnPendingBlock(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::txpool::OnPendingBlockReply>>(OnPendingBlockRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnPendingBlockReply>> AsyncOnPendingBlock(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnPendingBlockReply>>(AsyncOnPendingBlockRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnPendingBlockReply>> PrepareAsyncOnPendingBlock(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnPendingBlockReply>>(PrepareAsyncOnPendingBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::txpool::OnMinedBlockReply>> OnMinedBlock(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::txpool::OnMinedBlockReply>>(OnMinedBlockRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnMinedBlockReply>> AsyncOnMinedBlock(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnMinedBlockReply>>(AsyncOnMinedBlockRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnMinedBlockReply>> PrepareAsyncOnMinedBlock(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnMinedBlockReply>>(PrepareAsyncOnMinedBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::txpool::OnPendingLogsReply>> OnPendingLogs(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::txpool::OnPendingLogsReply>>(OnPendingLogsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnPendingLogsReply>> AsyncOnPendingLogs(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnPendingLogsReply>>(AsyncOnPendingLogsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnPendingLogsReply>> PrepareAsyncOnPendingLogs(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::txpool::OnPendingLogsReply>>(PrepareAsyncOnPendingLogsRaw(context, request, cq));
    }
    ::grpc::Status GetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::txpool::GetWorkReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::GetWorkReply>> AsyncGetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::GetWorkReply>>(AsyncGetWorkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::GetWorkReply>> PrepareAsyncGetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::GetWorkReply>>(PrepareAsyncGetWorkRaw(context, request, cq));
    }
    ::grpc::Status SubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::txpool::SubmitWorkReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::SubmitWorkReply>> AsyncSubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::SubmitWorkReply>>(AsyncSubmitWorkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::SubmitWorkReply>> PrepareAsyncSubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::SubmitWorkReply>>(PrepareAsyncSubmitWorkRaw(context, request, cq));
    }
    ::grpc::Status SubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::txpool::SubmitHashRateReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::SubmitHashRateReply>> AsyncSubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::SubmitHashRateReply>>(AsyncSubmitHashRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::SubmitHashRateReply>> PrepareAsyncSubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::SubmitHashRateReply>>(PrepareAsyncSubmitHashRateRaw(context, request, cq));
    }
    ::grpc::Status HashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::txpool::HashRateReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::HashRateReply>> AsyncHashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::HashRateReply>>(AsyncHashRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::HashRateReply>> PrepareAsyncHashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::HashRateReply>>(PrepareAsyncHashRateRaw(context, request, cq));
    }
    ::grpc::Status Mining(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::txpool::MiningReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::MiningReply>> AsyncMining(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::MiningReply>>(AsyncMiningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::MiningReply>> PrepareAsyncMining(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::txpool::MiningReply>>(PrepareAsyncMiningRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, std::function<void(::grpc::Status)>) override;
      void Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void OnPendingBlock(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest* request, ::grpc::ClientReadReactor< ::txpool::OnPendingBlockReply>* reactor) override;
      void OnMinedBlock(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest* request, ::grpc::ClientReadReactor< ::txpool::OnMinedBlockReply>* reactor) override;
      void OnPendingLogs(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest* request, ::grpc::ClientReadReactor< ::txpool::OnPendingLogsReply>* reactor) override;
      void GetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest* request, ::txpool::GetWorkReply* response, std::function<void(::grpc::Status)>) override;
      void GetWork(::grpc::ClientContext* context, const ::txpool::GetWorkRequest* request, ::txpool::GetWorkReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest* request, ::txpool::SubmitWorkReply* response, std::function<void(::grpc::Status)>) override;
      void SubmitWork(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest* request, ::txpool::SubmitWorkReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest* request, ::txpool::SubmitHashRateReply* response, std::function<void(::grpc::Status)>) override;
      void SubmitHashRate(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest* request, ::txpool::SubmitHashRateReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest* request, ::txpool::HashRateReply* response, std::function<void(::grpc::Status)>) override;
      void HashRate(::grpc::ClientContext* context, const ::txpool::HashRateRequest* request, ::txpool::HashRateReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Mining(::grpc::ClientContext* context, const ::txpool::MiningRequest* request, ::txpool::MiningReply* response, std::function<void(::grpc::Status)>) override;
      void Mining(::grpc::ClientContext* context, const ::txpool::MiningRequest* request, ::txpool::MiningReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::types::VersionReply>* AsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::types::VersionReply>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::txpool::OnPendingBlockReply>* OnPendingBlockRaw(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request) override;
    ::grpc::ClientAsyncReader< ::txpool::OnPendingBlockReply>* AsyncOnPendingBlockRaw(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::txpool::OnPendingBlockReply>* PrepareAsyncOnPendingBlockRaw(::grpc::ClientContext* context, const ::txpool::OnPendingBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::txpool::OnMinedBlockReply>* OnMinedBlockRaw(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request) override;
    ::grpc::ClientAsyncReader< ::txpool::OnMinedBlockReply>* AsyncOnMinedBlockRaw(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::txpool::OnMinedBlockReply>* PrepareAsyncOnMinedBlockRaw(::grpc::ClientContext* context, const ::txpool::OnMinedBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::txpool::OnPendingLogsReply>* OnPendingLogsRaw(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request) override;
    ::grpc::ClientAsyncReader< ::txpool::OnPendingLogsReply>* AsyncOnPendingLogsRaw(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::txpool::OnPendingLogsReply>* PrepareAsyncOnPendingLogsRaw(::grpc::ClientContext* context, const ::txpool::OnPendingLogsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::GetWorkReply>* AsyncGetWorkRaw(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::GetWorkReply>* PrepareAsyncGetWorkRaw(::grpc::ClientContext* context, const ::txpool::GetWorkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::SubmitWorkReply>* AsyncSubmitWorkRaw(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::SubmitWorkReply>* PrepareAsyncSubmitWorkRaw(::grpc::ClientContext* context, const ::txpool::SubmitWorkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::SubmitHashRateReply>* AsyncSubmitHashRateRaw(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::SubmitHashRateReply>* PrepareAsyncSubmitHashRateRaw(::grpc::ClientContext* context, const ::txpool::SubmitHashRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::HashRateReply>* AsyncHashRateRaw(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::HashRateReply>* PrepareAsyncHashRateRaw(::grpc::ClientContext* context, const ::txpool::HashRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::MiningReply>* AsyncMiningRaw(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::txpool::MiningReply>* PrepareAsyncMiningRaw(::grpc::ClientContext* context, const ::txpool::MiningRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Version_;
    const ::grpc::internal::RpcMethod rpcmethod_OnPendingBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_OnMinedBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_OnPendingLogs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWork_;
    const ::grpc::internal::RpcMethod rpcmethod_SubmitWork_;
    const ::grpc::internal::RpcMethod rpcmethod_SubmitHashRate_;
    const ::grpc::internal::RpcMethod rpcmethod_HashRate_;
    const ::grpc::internal::RpcMethod rpcmethod_Mining_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Version returns the service version number
    virtual ::grpc::Status Version(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response);
    // subscribe to pending blocks event
    virtual ::grpc::Status OnPendingBlock(::grpc::ServerContext* context, const ::txpool::OnPendingBlockRequest* request, ::grpc::ServerWriter< ::txpool::OnPendingBlockReply>* writer);
    // subscribe to mined blocks event
    virtual ::grpc::Status OnMinedBlock(::grpc::ServerContext* context, const ::txpool::OnMinedBlockRequest* request, ::grpc::ServerWriter< ::txpool::OnMinedBlockReply>* writer);
    // subscribe to pending blocks event
    virtual ::grpc::Status OnPendingLogs(::grpc::ServerContext* context, const ::txpool::OnPendingLogsRequest* request, ::grpc::ServerWriter< ::txpool::OnPendingLogsReply>* writer);
    // GetWork returns a work package for external miner.
    //
    // The work package consists of 3 strings:
    //   result[0] - 32 bytes hex encoded current block header pow-hash
    //   result[1] - 32 bytes hex encoded seed hash used for DAG
    //   result[2] - 32 bytes hex encoded boundary condition ("target"), 2^256/difficulty
    //   result[3] - hex encoded block number
    virtual ::grpc::Status GetWork(::grpc::ServerContext* context, const ::txpool::GetWorkRequest* request, ::txpool::GetWorkReply* response);
    // SubmitWork can be used by external miner to submit their POW solution.
    // It returns an indication if the work was accepted.
    // Note either an invalid solution, a stale work a non-existent work will return false.
    virtual ::grpc::Status SubmitWork(::grpc::ServerContext* context, const ::txpool::SubmitWorkRequest* request, ::txpool::SubmitWorkReply* response);
    // SubmitHashRate can be used for remote miners to submit their hash rate.
    // This enables the node to report the combined hash rate of all miners
    // which submit work through this node.
    //
    // It accepts the miner hash rate and an identifier which must be unique
    // between nodes.
    virtual ::grpc::Status SubmitHashRate(::grpc::ServerContext* context, const ::txpool::SubmitHashRateRequest* request, ::txpool::SubmitHashRateReply* response);
    // HashRate returns the current hashrate for local CPU miner and remote miner.
    virtual ::grpc::Status HashRate(::grpc::ServerContext* context, const ::txpool::HashRateRequest* request, ::txpool::HashRateReply* response);
    // Mining returns an indication if this node is currently mining and it's mining configuration
    virtual ::grpc::Status Mining(::grpc::ServerContext* context, const ::txpool::MiningRequest* request, ::txpool::MiningReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Version() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::types::VersionReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnPendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OnPendingBlock() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_OnPendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnPendingBlock(::grpc::ServerContext* context, ::txpool::OnPendingBlockRequest* request, ::grpc::ServerAsyncWriter< ::txpool::OnPendingBlockReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnMinedBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OnMinedBlock() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_OnMinedBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnMinedBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnMinedBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnMinedBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnMinedBlock(::grpc::ServerContext* context, ::txpool::OnMinedBlockRequest* request, ::grpc::ServerAsyncWriter< ::txpool::OnMinedBlockReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnPendingLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OnPendingLogs() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_OnPendingLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingLogs(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingLogsRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingLogsReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnPendingLogs(::grpc::ServerContext* context, ::txpool::OnPendingLogsRequest* request, ::grpc::ServerAsyncWriter< ::txpool::OnPendingLogsReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWork() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWork(::grpc::ServerContext* /*context*/, const ::txpool::GetWorkRequest* /*request*/, ::txpool::GetWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWork(::grpc::ServerContext* context, ::txpool::GetWorkRequest* request, ::grpc::ServerAsyncResponseWriter< ::txpool::GetWorkReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubmitWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubmitWork() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SubmitWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitWork(::grpc::ServerContext* /*context*/, const ::txpool::SubmitWorkRequest* /*request*/, ::txpool::SubmitWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubmitWork(::grpc::ServerContext* context, ::txpool::SubmitWorkRequest* request, ::grpc::ServerAsyncResponseWriter< ::txpool::SubmitWorkReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubmitHashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubmitHashRate() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SubmitHashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitHashRate(::grpc::ServerContext* /*context*/, const ::txpool::SubmitHashRateRequest* /*request*/, ::txpool::SubmitHashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubmitHashRate(::grpc::ServerContext* context, ::txpool::SubmitHashRateRequest* request, ::grpc::ServerAsyncResponseWriter< ::txpool::SubmitHashRateReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HashRate() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_HashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRate(::grpc::ServerContext* /*context*/, const ::txpool::HashRateRequest* /*request*/, ::txpool::HashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashRate(::grpc::ServerContext* context, ::txpool::HashRateRequest* request, ::grpc::ServerAsyncResponseWriter< ::txpool::HashRateReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Mining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Mining() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Mining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mining(::grpc::ServerContext* /*context*/, const ::txpool::MiningRequest* /*request*/, ::txpool::MiningReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMining(::grpc::ServerContext* context, ::txpool::MiningRequest* request, ::grpc::ServerAsyncResponseWriter< ::txpool::MiningReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Version<WithAsyncMethod_OnPendingBlock<WithAsyncMethod_OnMinedBlock<WithAsyncMethod_OnPendingLogs<WithAsyncMethod_GetWork<WithAsyncMethod_SubmitWork<WithAsyncMethod_SubmitHashRate<WithAsyncMethod_HashRate<WithAsyncMethod_Mining<Service > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Version() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::types::VersionReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response) { return this->Version(context, request, response); }));}
    void SetMessageAllocatorFor_Version(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::types::VersionReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::types::VersionReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Version(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OnPendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OnPendingBlock() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::txpool::OnPendingBlockRequest, ::txpool::OnPendingBlockReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::txpool::OnPendingBlockRequest* request) { return this->OnPendingBlock(context, request); }));
    }
    ~WithCallbackMethod_OnPendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::txpool::OnPendingBlockReply>* OnPendingBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::txpool::OnPendingBlockRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OnMinedBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OnMinedBlock() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::txpool::OnMinedBlockRequest, ::txpool::OnMinedBlockReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::txpool::OnMinedBlockRequest* request) { return this->OnMinedBlock(context, request); }));
    }
    ~WithCallbackMethod_OnMinedBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnMinedBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnMinedBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnMinedBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::txpool::OnMinedBlockReply>* OnMinedBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::txpool::OnMinedBlockRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OnPendingLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OnPendingLogs() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::txpool::OnPendingLogsRequest, ::txpool::OnPendingLogsReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::txpool::OnPendingLogsRequest* request) { return this->OnPendingLogs(context, request); }));
    }
    ~WithCallbackMethod_OnPendingLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingLogs(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingLogsRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingLogsReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::txpool::OnPendingLogsReply>* OnPendingLogs(
      ::grpc::CallbackServerContext* /*context*/, const ::txpool::OnPendingLogsRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetWork() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::txpool::GetWorkRequest, ::txpool::GetWorkReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::txpool::GetWorkRequest* request, ::txpool::GetWorkReply* response) { return this->GetWork(context, request, response); }));}
    void SetMessageAllocatorFor_GetWork(
        ::grpc::MessageAllocator< ::txpool::GetWorkRequest, ::txpool::GetWorkReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::txpool::GetWorkRequest, ::txpool::GetWorkReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWork(::grpc::ServerContext* /*context*/, const ::txpool::GetWorkRequest* /*request*/, ::txpool::GetWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWork(
      ::grpc::CallbackServerContext* /*context*/, const ::txpool::GetWorkRequest* /*request*/, ::txpool::GetWorkReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubmitWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubmitWork() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::txpool::SubmitWorkRequest, ::txpool::SubmitWorkReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::txpool::SubmitWorkRequest* request, ::txpool::SubmitWorkReply* response) { return this->SubmitWork(context, request, response); }));}
    void SetMessageAllocatorFor_SubmitWork(
        ::grpc::MessageAllocator< ::txpool::SubmitWorkRequest, ::txpool::SubmitWorkReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::txpool::SubmitWorkRequest, ::txpool::SubmitWorkReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubmitWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitWork(::grpc::ServerContext* /*context*/, const ::txpool::SubmitWorkRequest* /*request*/, ::txpool::SubmitWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubmitWork(
      ::grpc::CallbackServerContext* /*context*/, const ::txpool::SubmitWorkRequest* /*request*/, ::txpool::SubmitWorkReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubmitHashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubmitHashRate() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::txpool::SubmitHashRateRequest, ::txpool::SubmitHashRateReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::txpool::SubmitHashRateRequest* request, ::txpool::SubmitHashRateReply* response) { return this->SubmitHashRate(context, request, response); }));}
    void SetMessageAllocatorFor_SubmitHashRate(
        ::grpc::MessageAllocator< ::txpool::SubmitHashRateRequest, ::txpool::SubmitHashRateReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::txpool::SubmitHashRateRequest, ::txpool::SubmitHashRateReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubmitHashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitHashRate(::grpc::ServerContext* /*context*/, const ::txpool::SubmitHashRateRequest* /*request*/, ::txpool::SubmitHashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubmitHashRate(
      ::grpc::CallbackServerContext* /*context*/, const ::txpool::SubmitHashRateRequest* /*request*/, ::txpool::SubmitHashRateReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HashRate() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::txpool::HashRateRequest, ::txpool::HashRateReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::txpool::HashRateRequest* request, ::txpool::HashRateReply* response) { return this->HashRate(context, request, response); }));}
    void SetMessageAllocatorFor_HashRate(
        ::grpc::MessageAllocator< ::txpool::HashRateRequest, ::txpool::HashRateReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::txpool::HashRateRequest, ::txpool::HashRateReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRate(::grpc::ServerContext* /*context*/, const ::txpool::HashRateRequest* /*request*/, ::txpool::HashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HashRate(
      ::grpc::CallbackServerContext* /*context*/, const ::txpool::HashRateRequest* /*request*/, ::txpool::HashRateReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Mining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Mining() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::txpool::MiningRequest, ::txpool::MiningReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::txpool::MiningRequest* request, ::txpool::MiningReply* response) { return this->Mining(context, request, response); }));}
    void SetMessageAllocatorFor_Mining(
        ::grpc::MessageAllocator< ::txpool::MiningRequest, ::txpool::MiningReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::txpool::MiningRequest, ::txpool::MiningReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Mining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mining(::grpc::ServerContext* /*context*/, const ::txpool::MiningRequest* /*request*/, ::txpool::MiningReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Mining(
      ::grpc::CallbackServerContext* /*context*/, const ::txpool::MiningRequest* /*request*/, ::txpool::MiningReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Version<WithCallbackMethod_OnPendingBlock<WithCallbackMethod_OnMinedBlock<WithCallbackMethod_OnPendingLogs<WithCallbackMethod_GetWork<WithCallbackMethod_SubmitWork<WithCallbackMethod_SubmitHashRate<WithCallbackMethod_HashRate<WithCallbackMethod_Mining<Service > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Version() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnPendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OnPendingBlock() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_OnPendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnMinedBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OnMinedBlock() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_OnMinedBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnMinedBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnMinedBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnMinedBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnPendingLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OnPendingLogs() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_OnPendingLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingLogs(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingLogsRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingLogsReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWork() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWork(::grpc::ServerContext* /*context*/, const ::txpool::GetWorkRequest* /*request*/, ::txpool::GetWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubmitWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubmitWork() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SubmitWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitWork(::grpc::ServerContext* /*context*/, const ::txpool::SubmitWorkRequest* /*request*/, ::txpool::SubmitWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubmitHashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubmitHashRate() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SubmitHashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitHashRate(::grpc::ServerContext* /*context*/, const ::txpool::SubmitHashRateRequest* /*request*/, ::txpool::SubmitHashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HashRate() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_HashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRate(::grpc::ServerContext* /*context*/, const ::txpool::HashRateRequest* /*request*/, ::txpool::HashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Mining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Mining() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Mining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mining(::grpc::ServerContext* /*context*/, const ::txpool::MiningRequest* /*request*/, ::txpool::MiningReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Version() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OnPendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OnPendingBlock() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_OnPendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnPendingBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OnMinedBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OnMinedBlock() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_OnMinedBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnMinedBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnMinedBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnMinedBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnMinedBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OnPendingLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OnPendingLogs() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_OnPendingLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingLogs(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingLogsRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingLogsReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnPendingLogs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWork() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWork(::grpc::ServerContext* /*context*/, const ::txpool::GetWorkRequest* /*request*/, ::txpool::GetWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWork(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubmitWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubmitWork() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SubmitWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitWork(::grpc::ServerContext* /*context*/, const ::txpool::SubmitWorkRequest* /*request*/, ::txpool::SubmitWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubmitWork(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubmitHashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubmitHashRate() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SubmitHashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitHashRate(::grpc::ServerContext* /*context*/, const ::txpool::SubmitHashRateRequest* /*request*/, ::txpool::SubmitHashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubmitHashRate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HashRate() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_HashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRate(::grpc::ServerContext* /*context*/, const ::txpool::HashRateRequest* /*request*/, ::txpool::HashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashRate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Mining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Mining() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Mining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mining(::grpc::ServerContext* /*context*/, const ::txpool::MiningRequest* /*request*/, ::txpool::MiningReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMining(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Version() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Version(context, request, response); }));
    }
    ~WithRawCallbackMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Version(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OnPendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OnPendingBlock() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->OnPendingBlock(context, request); }));
    }
    ~WithRawCallbackMethod_OnPendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* OnPendingBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OnMinedBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OnMinedBlock() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->OnMinedBlock(context, request); }));
    }
    ~WithRawCallbackMethod_OnMinedBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnMinedBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnMinedBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnMinedBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* OnMinedBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OnPendingLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OnPendingLogs() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->OnPendingLogs(context, request); }));
    }
    ~WithRawCallbackMethod_OnPendingLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnPendingLogs(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingLogsRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingLogsReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* OnPendingLogs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetWork() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWork(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWork(::grpc::ServerContext* /*context*/, const ::txpool::GetWorkRequest* /*request*/, ::txpool::GetWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWork(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubmitWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubmitWork() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubmitWork(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubmitWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitWork(::grpc::ServerContext* /*context*/, const ::txpool::SubmitWorkRequest* /*request*/, ::txpool::SubmitWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubmitWork(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubmitHashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubmitHashRate() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubmitHashRate(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubmitHashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitHashRate(::grpc::ServerContext* /*context*/, const ::txpool::SubmitHashRateRequest* /*request*/, ::txpool::SubmitHashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubmitHashRate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HashRate() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HashRate(context, request, response); }));
    }
    ~WithRawCallbackMethod_HashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRate(::grpc::ServerContext* /*context*/, const ::txpool::HashRateRequest* /*request*/, ::txpool::HashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HashRate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Mining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Mining() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Mining(context, request, response); }));
    }
    ~WithRawCallbackMethod_Mining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Mining(::grpc::ServerContext* /*context*/, const ::txpool::MiningRequest* /*request*/, ::txpool::MiningReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Mining(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Version() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::types::VersionReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::types::VersionReply>* streamer) {
                       return this->StreamedVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::types::VersionReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWork() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::txpool::GetWorkRequest, ::txpool::GetWorkReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::txpool::GetWorkRequest, ::txpool::GetWorkReply>* streamer) {
                       return this->StreamedGetWork(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWork(::grpc::ServerContext* /*context*/, const ::txpool::GetWorkRequest* /*request*/, ::txpool::GetWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWork(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::txpool::GetWorkRequest,::txpool::GetWorkReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubmitWork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubmitWork() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::txpool::SubmitWorkRequest, ::txpool::SubmitWorkReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::txpool::SubmitWorkRequest, ::txpool::SubmitWorkReply>* streamer) {
                       return this->StreamedSubmitWork(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubmitWork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubmitWork(::grpc::ServerContext* /*context*/, const ::txpool::SubmitWorkRequest* /*request*/, ::txpool::SubmitWorkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubmitWork(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::txpool::SubmitWorkRequest,::txpool::SubmitWorkReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubmitHashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubmitHashRate() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::txpool::SubmitHashRateRequest, ::txpool::SubmitHashRateReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::txpool::SubmitHashRateRequest, ::txpool::SubmitHashRateReply>* streamer) {
                       return this->StreamedSubmitHashRate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubmitHashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubmitHashRate(::grpc::ServerContext* /*context*/, const ::txpool::SubmitHashRateRequest* /*request*/, ::txpool::SubmitHashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubmitHashRate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::txpool::SubmitHashRateRequest,::txpool::SubmitHashRateReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HashRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HashRate() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::txpool::HashRateRequest, ::txpool::HashRateReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::txpool::HashRateRequest, ::txpool::HashRateReply>* streamer) {
                       return this->StreamedHashRate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HashRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HashRate(::grpc::ServerContext* /*context*/, const ::txpool::HashRateRequest* /*request*/, ::txpool::HashRateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHashRate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::txpool::HashRateRequest,::txpool::HashRateReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Mining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Mining() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::txpool::MiningRequest, ::txpool::MiningReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::txpool::MiningRequest, ::txpool::MiningReply>* streamer) {
                       return this->StreamedMining(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Mining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Mining(::grpc::ServerContext* /*context*/, const ::txpool::MiningRequest* /*request*/, ::txpool::MiningReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMining(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::txpool::MiningRequest,::txpool::MiningReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_GetWork<WithStreamedUnaryMethod_SubmitWork<WithStreamedUnaryMethod_SubmitHashRate<WithStreamedUnaryMethod_HashRate<WithStreamedUnaryMethod_Mining<Service > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_OnPendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_OnPendingBlock() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::txpool::OnPendingBlockRequest, ::txpool::OnPendingBlockReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::txpool::OnPendingBlockRequest, ::txpool::OnPendingBlockReply>* streamer) {
                       return this->StreamedOnPendingBlock(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_OnPendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnPendingBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOnPendingBlock(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::txpool::OnPendingBlockRequest,::txpool::OnPendingBlockReply>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_OnMinedBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_OnMinedBlock() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::txpool::OnMinedBlockRequest, ::txpool::OnMinedBlockReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::txpool::OnMinedBlockRequest, ::txpool::OnMinedBlockReply>* streamer) {
                       return this->StreamedOnMinedBlock(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_OnMinedBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnMinedBlock(::grpc::ServerContext* /*context*/, const ::txpool::OnMinedBlockRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnMinedBlockReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOnMinedBlock(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::txpool::OnMinedBlockRequest,::txpool::OnMinedBlockReply>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_OnPendingLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_OnPendingLogs() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::txpool::OnPendingLogsRequest, ::txpool::OnPendingLogsReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::txpool::OnPendingLogsRequest, ::txpool::OnPendingLogsReply>* streamer) {
                       return this->StreamedOnPendingLogs(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_OnPendingLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnPendingLogs(::grpc::ServerContext* /*context*/, const ::txpool::OnPendingLogsRequest* /*request*/, ::grpc::ServerWriter< ::txpool::OnPendingLogsReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOnPendingLogs(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::txpool::OnPendingLogsRequest,::txpool::OnPendingLogsReply>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_OnPendingBlock<WithSplitStreamingMethod_OnMinedBlock<WithSplitStreamingMethod_OnPendingLogs<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Version<WithSplitStreamingMethod_OnPendingBlock<WithSplitStreamingMethod_OnMinedBlock<WithSplitStreamingMethod_OnPendingLogs<WithStreamedUnaryMethod_GetWork<WithStreamedUnaryMethod_SubmitWork<WithStreamedUnaryMethod_SubmitHashRate<WithStreamedUnaryMethod_HashRate<WithStreamedUnaryMethod_Mining<Service > > > > > > > > > StreamedService;
};

}  // namespace txpool


#endif  // GRPC_txpool_2fmining_2eproto__INCLUDED
