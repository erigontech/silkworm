// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: txpool/mining.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_txpool_2fmining_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_txpool_2fmining_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_txpool_2fmining_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_txpool_2fmining_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_txpool_2fmining_2eproto;
namespace txpool {
class GetWorkReply;
struct GetWorkReplyDefaultTypeInternal;
extern GetWorkReplyDefaultTypeInternal _GetWorkReply_default_instance_;
class GetWorkRequest;
struct GetWorkRequestDefaultTypeInternal;
extern GetWorkRequestDefaultTypeInternal _GetWorkRequest_default_instance_;
class HashRateReply;
struct HashRateReplyDefaultTypeInternal;
extern HashRateReplyDefaultTypeInternal _HashRateReply_default_instance_;
class HashRateRequest;
struct HashRateRequestDefaultTypeInternal;
extern HashRateRequestDefaultTypeInternal _HashRateRequest_default_instance_;
class MiningReply;
struct MiningReplyDefaultTypeInternal;
extern MiningReplyDefaultTypeInternal _MiningReply_default_instance_;
class MiningRequest;
struct MiningRequestDefaultTypeInternal;
extern MiningRequestDefaultTypeInternal _MiningRequest_default_instance_;
class OnMinedBlockReply;
struct OnMinedBlockReplyDefaultTypeInternal;
extern OnMinedBlockReplyDefaultTypeInternal _OnMinedBlockReply_default_instance_;
class OnMinedBlockRequest;
struct OnMinedBlockRequestDefaultTypeInternal;
extern OnMinedBlockRequestDefaultTypeInternal _OnMinedBlockRequest_default_instance_;
class OnPendingBlockReply;
struct OnPendingBlockReplyDefaultTypeInternal;
extern OnPendingBlockReplyDefaultTypeInternal _OnPendingBlockReply_default_instance_;
class OnPendingBlockRequest;
struct OnPendingBlockRequestDefaultTypeInternal;
extern OnPendingBlockRequestDefaultTypeInternal _OnPendingBlockRequest_default_instance_;
class OnPendingLogsReply;
struct OnPendingLogsReplyDefaultTypeInternal;
extern OnPendingLogsReplyDefaultTypeInternal _OnPendingLogsReply_default_instance_;
class OnPendingLogsRequest;
struct OnPendingLogsRequestDefaultTypeInternal;
extern OnPendingLogsRequestDefaultTypeInternal _OnPendingLogsRequest_default_instance_;
class SubmitHashRateReply;
struct SubmitHashRateReplyDefaultTypeInternal;
extern SubmitHashRateReplyDefaultTypeInternal _SubmitHashRateReply_default_instance_;
class SubmitHashRateRequest;
struct SubmitHashRateRequestDefaultTypeInternal;
extern SubmitHashRateRequestDefaultTypeInternal _SubmitHashRateRequest_default_instance_;
class SubmitWorkReply;
struct SubmitWorkReplyDefaultTypeInternal;
extern SubmitWorkReplyDefaultTypeInternal _SubmitWorkReply_default_instance_;
class SubmitWorkRequest;
struct SubmitWorkRequestDefaultTypeInternal;
extern SubmitWorkRequestDefaultTypeInternal _SubmitWorkRequest_default_instance_;
}  // namespace txpool
PROTOBUF_NAMESPACE_OPEN
template<> ::txpool::GetWorkReply* Arena::CreateMaybeMessage<::txpool::GetWorkReply>(Arena*);
template<> ::txpool::GetWorkRequest* Arena::CreateMaybeMessage<::txpool::GetWorkRequest>(Arena*);
template<> ::txpool::HashRateReply* Arena::CreateMaybeMessage<::txpool::HashRateReply>(Arena*);
template<> ::txpool::HashRateRequest* Arena::CreateMaybeMessage<::txpool::HashRateRequest>(Arena*);
template<> ::txpool::MiningReply* Arena::CreateMaybeMessage<::txpool::MiningReply>(Arena*);
template<> ::txpool::MiningRequest* Arena::CreateMaybeMessage<::txpool::MiningRequest>(Arena*);
template<> ::txpool::OnMinedBlockReply* Arena::CreateMaybeMessage<::txpool::OnMinedBlockReply>(Arena*);
template<> ::txpool::OnMinedBlockRequest* Arena::CreateMaybeMessage<::txpool::OnMinedBlockRequest>(Arena*);
template<> ::txpool::OnPendingBlockReply* Arena::CreateMaybeMessage<::txpool::OnPendingBlockReply>(Arena*);
template<> ::txpool::OnPendingBlockRequest* Arena::CreateMaybeMessage<::txpool::OnPendingBlockRequest>(Arena*);
template<> ::txpool::OnPendingLogsReply* Arena::CreateMaybeMessage<::txpool::OnPendingLogsReply>(Arena*);
template<> ::txpool::OnPendingLogsRequest* Arena::CreateMaybeMessage<::txpool::OnPendingLogsRequest>(Arena*);
template<> ::txpool::SubmitHashRateReply* Arena::CreateMaybeMessage<::txpool::SubmitHashRateReply>(Arena*);
template<> ::txpool::SubmitHashRateRequest* Arena::CreateMaybeMessage<::txpool::SubmitHashRateRequest>(Arena*);
template<> ::txpool::SubmitWorkReply* Arena::CreateMaybeMessage<::txpool::SubmitWorkReply>(Arena*);
template<> ::txpool::SubmitWorkRequest* Arena::CreateMaybeMessage<::txpool::SubmitWorkRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace txpool {

// ===================================================================

class OnPendingBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.OnPendingBlockRequest) */ {
 public:
  inline OnPendingBlockRequest() : OnPendingBlockRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OnPendingBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPendingBlockRequest(const OnPendingBlockRequest& from);
  OnPendingBlockRequest(OnPendingBlockRequest&& from) noexcept
    : OnPendingBlockRequest() {
    *this = ::std::move(from);
  }

  inline OnPendingBlockRequest& operator=(const OnPendingBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPendingBlockRequest& operator=(OnPendingBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnPendingBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPendingBlockRequest* internal_default_instance() {
    return reinterpret_cast<const OnPendingBlockRequest*>(
               &_OnPendingBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OnPendingBlockRequest& a, OnPendingBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OnPendingBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPendingBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPendingBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPendingBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OnPendingBlockRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OnPendingBlockRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnPendingBlockRequest";
  }
  protected:
  explicit OnPendingBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.OnPendingBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnPendingBlockReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.OnPendingBlockReply) */ {
 public:
  inline OnPendingBlockReply() : OnPendingBlockReply(nullptr) {}
  ~OnPendingBlockReply() override;
  explicit PROTOBUF_CONSTEXPR OnPendingBlockReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPendingBlockReply(const OnPendingBlockReply& from);
  OnPendingBlockReply(OnPendingBlockReply&& from) noexcept
    : OnPendingBlockReply() {
    *this = ::std::move(from);
  }

  inline OnPendingBlockReply& operator=(const OnPendingBlockReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPendingBlockReply& operator=(OnPendingBlockReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnPendingBlockReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPendingBlockReply* internal_default_instance() {
    return reinterpret_cast<const OnPendingBlockReply*>(
               &_OnPendingBlockReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OnPendingBlockReply& a, OnPendingBlockReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OnPendingBlockReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPendingBlockReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPendingBlockReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPendingBlockReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnPendingBlockReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnPendingBlockReply& from) {
    OnPendingBlockReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnPendingBlockReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnPendingBlockReply";
  }
  protected:
  explicit OnPendingBlockReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRplBlockFieldNumber = 1,
  };
  // bytes rplBlock = 1;
  void clear_rplblock();
  const std::string& rplblock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rplblock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rplblock();
  PROTOBUF_NODISCARD std::string* release_rplblock();
  void set_allocated_rplblock(std::string* rplblock);
  private:
  const std::string& _internal_rplblock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rplblock(const std::string& value);
  std::string* _internal_mutable_rplblock();
  public:

  // @@protoc_insertion_point(class_scope:txpool.OnPendingBlockReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rplblock_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnMinedBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.OnMinedBlockRequest) */ {
 public:
  inline OnMinedBlockRequest() : OnMinedBlockRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OnMinedBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnMinedBlockRequest(const OnMinedBlockRequest& from);
  OnMinedBlockRequest(OnMinedBlockRequest&& from) noexcept
    : OnMinedBlockRequest() {
    *this = ::std::move(from);
  }

  inline OnMinedBlockRequest& operator=(const OnMinedBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnMinedBlockRequest& operator=(OnMinedBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnMinedBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnMinedBlockRequest* internal_default_instance() {
    return reinterpret_cast<const OnMinedBlockRequest*>(
               &_OnMinedBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OnMinedBlockRequest& a, OnMinedBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OnMinedBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnMinedBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnMinedBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnMinedBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OnMinedBlockRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OnMinedBlockRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnMinedBlockRequest";
  }
  protected:
  explicit OnMinedBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.OnMinedBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnMinedBlockReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.OnMinedBlockReply) */ {
 public:
  inline OnMinedBlockReply() : OnMinedBlockReply(nullptr) {}
  ~OnMinedBlockReply() override;
  explicit PROTOBUF_CONSTEXPR OnMinedBlockReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnMinedBlockReply(const OnMinedBlockReply& from);
  OnMinedBlockReply(OnMinedBlockReply&& from) noexcept
    : OnMinedBlockReply() {
    *this = ::std::move(from);
  }

  inline OnMinedBlockReply& operator=(const OnMinedBlockReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnMinedBlockReply& operator=(OnMinedBlockReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnMinedBlockReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnMinedBlockReply* internal_default_instance() {
    return reinterpret_cast<const OnMinedBlockReply*>(
               &_OnMinedBlockReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OnMinedBlockReply& a, OnMinedBlockReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OnMinedBlockReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnMinedBlockReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnMinedBlockReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnMinedBlockReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnMinedBlockReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnMinedBlockReply& from) {
    OnMinedBlockReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnMinedBlockReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnMinedBlockReply";
  }
  protected:
  explicit OnMinedBlockReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRplBlockFieldNumber = 1,
  };
  // bytes rplBlock = 1;
  void clear_rplblock();
  const std::string& rplblock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rplblock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rplblock();
  PROTOBUF_NODISCARD std::string* release_rplblock();
  void set_allocated_rplblock(std::string* rplblock);
  private:
  const std::string& _internal_rplblock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rplblock(const std::string& value);
  std::string* _internal_mutable_rplblock();
  public:

  // @@protoc_insertion_point(class_scope:txpool.OnMinedBlockReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rplblock_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnPendingLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.OnPendingLogsRequest) */ {
 public:
  inline OnPendingLogsRequest() : OnPendingLogsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OnPendingLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPendingLogsRequest(const OnPendingLogsRequest& from);
  OnPendingLogsRequest(OnPendingLogsRequest&& from) noexcept
    : OnPendingLogsRequest() {
    *this = ::std::move(from);
  }

  inline OnPendingLogsRequest& operator=(const OnPendingLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPendingLogsRequest& operator=(OnPendingLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnPendingLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPendingLogsRequest* internal_default_instance() {
    return reinterpret_cast<const OnPendingLogsRequest*>(
               &_OnPendingLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OnPendingLogsRequest& a, OnPendingLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OnPendingLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPendingLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPendingLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPendingLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OnPendingLogsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OnPendingLogsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnPendingLogsRequest";
  }
  protected:
  explicit OnPendingLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.OnPendingLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnPendingLogsReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.OnPendingLogsReply) */ {
 public:
  inline OnPendingLogsReply() : OnPendingLogsReply(nullptr) {}
  ~OnPendingLogsReply() override;
  explicit PROTOBUF_CONSTEXPR OnPendingLogsReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPendingLogsReply(const OnPendingLogsReply& from);
  OnPendingLogsReply(OnPendingLogsReply&& from) noexcept
    : OnPendingLogsReply() {
    *this = ::std::move(from);
  }

  inline OnPendingLogsReply& operator=(const OnPendingLogsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPendingLogsReply& operator=(OnPendingLogsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnPendingLogsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPendingLogsReply* internal_default_instance() {
    return reinterpret_cast<const OnPendingLogsReply*>(
               &_OnPendingLogsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OnPendingLogsReply& a, OnPendingLogsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OnPendingLogsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPendingLogsReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPendingLogsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPendingLogsReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnPendingLogsReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnPendingLogsReply& from) {
    OnPendingLogsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnPendingLogsReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnPendingLogsReply";
  }
  protected:
  explicit OnPendingLogsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRplLogsFieldNumber = 1,
  };
  // bytes rplLogs = 1;
  void clear_rpllogs();
  const std::string& rpllogs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rpllogs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rpllogs();
  PROTOBUF_NODISCARD std::string* release_rpllogs();
  void set_allocated_rpllogs(std::string* rpllogs);
  private:
  const std::string& _internal_rpllogs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rpllogs(const std::string& value);
  std::string* _internal_mutable_rpllogs();
  public:

  // @@protoc_insertion_point(class_scope:txpool.OnPendingLogsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpllogs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class GetWorkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.GetWorkRequest) */ {
 public:
  inline GetWorkRequest() : GetWorkRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetWorkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkRequest(const GetWorkRequest& from);
  GetWorkRequest(GetWorkRequest&& from) noexcept
    : GetWorkRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkRequest& operator=(const GetWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkRequest& operator=(GetWorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkRequest*>(
               &_GetWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetWorkRequest& a, GetWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetWorkRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetWorkRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.GetWorkRequest";
  }
  protected:
  explicit GetWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.GetWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class GetWorkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.GetWorkReply) */ {
 public:
  inline GetWorkReply() : GetWorkReply(nullptr) {}
  ~GetWorkReply() override;
  explicit PROTOBUF_CONSTEXPR GetWorkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkReply(const GetWorkReply& from);
  GetWorkReply(GetWorkReply&& from) noexcept
    : GetWorkReply() {
    *this = ::std::move(from);
  }

  inline GetWorkReply& operator=(const GetWorkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkReply& operator=(GetWorkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkReply* internal_default_instance() {
    return reinterpret_cast<const GetWorkReply*>(
               &_GetWorkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetWorkReply& a, GetWorkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWorkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWorkReply& from) {
    GetWorkReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.GetWorkReply";
  }
  protected:
  explicit GetWorkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderHashFieldNumber = 1,
    kSeedHashFieldNumber = 2,
    kTargetFieldNumber = 3,
    kBlockNumberFieldNumber = 4,
  };
  // string headerHash = 1;
  void clear_headerhash();
  const std::string& headerhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headerhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headerhash();
  PROTOBUF_NODISCARD std::string* release_headerhash();
  void set_allocated_headerhash(std::string* headerhash);
  private:
  const std::string& _internal_headerhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headerhash(const std::string& value);
  std::string* _internal_mutable_headerhash();
  public:

  // string seedHash = 2;
  void clear_seedhash();
  const std::string& seedhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seedhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seedhash();
  PROTOBUF_NODISCARD std::string* release_seedhash();
  void set_allocated_seedhash(std::string* seedhash);
  private:
  const std::string& _internal_seedhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seedhash(const std::string& value);
  std::string* _internal_mutable_seedhash();
  public:

  // string target = 3;
  void clear_target();
  const std::string& target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* target);
  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(const std::string& value);
  std::string* _internal_mutable_target();
  public:

  // string blockNumber = 4;
  void clear_blocknumber();
  const std::string& blocknumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blocknumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blocknumber();
  PROTOBUF_NODISCARD std::string* release_blocknumber();
  void set_allocated_blocknumber(std::string* blocknumber);
  private:
  const std::string& _internal_blocknumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blocknumber(const std::string& value);
  std::string* _internal_mutable_blocknumber();
  public:

  // @@protoc_insertion_point(class_scope:txpool.GetWorkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headerhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seedhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blocknumber_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.SubmitWorkRequest) */ {
 public:
  inline SubmitWorkRequest() : SubmitWorkRequest(nullptr) {}
  ~SubmitWorkRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitWorkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitWorkRequest(const SubmitWorkRequest& from);
  SubmitWorkRequest(SubmitWorkRequest&& from) noexcept
    : SubmitWorkRequest() {
    *this = ::std::move(from);
  }

  inline SubmitWorkRequest& operator=(const SubmitWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkRequest& operator=(SubmitWorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitWorkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitWorkRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkRequest*>(
               &_SubmitWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SubmitWorkRequest& a, SubmitWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitWorkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitWorkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitWorkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitWorkRequest& from) {
    SubmitWorkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitWorkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.SubmitWorkRequest";
  }
  protected:
  explicit SubmitWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockNonceFieldNumber = 1,
    kPowHashFieldNumber = 2,
    kDigestFieldNumber = 3,
  };
  // bytes blockNonce = 1;
  void clear_blocknonce();
  const std::string& blocknonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blocknonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blocknonce();
  PROTOBUF_NODISCARD std::string* release_blocknonce();
  void set_allocated_blocknonce(std::string* blocknonce);
  private:
  const std::string& _internal_blocknonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blocknonce(const std::string& value);
  std::string* _internal_mutable_blocknonce();
  public:

  // bytes powHash = 2;
  void clear_powhash();
  const std::string& powhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_powhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_powhash();
  PROTOBUF_NODISCARD std::string* release_powhash();
  void set_allocated_powhash(std::string* powhash);
  private:
  const std::string& _internal_powhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_powhash(const std::string& value);
  std::string* _internal_mutable_powhash();
  public:

  // bytes digest = 3;
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_NODISCARD std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // @@protoc_insertion_point(class_scope:txpool.SubmitWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blocknonce_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr powhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.SubmitWorkReply) */ {
 public:
  inline SubmitWorkReply() : SubmitWorkReply(nullptr) {}
  ~SubmitWorkReply() override;
  explicit PROTOBUF_CONSTEXPR SubmitWorkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitWorkReply(const SubmitWorkReply& from);
  SubmitWorkReply(SubmitWorkReply&& from) noexcept
    : SubmitWorkReply() {
    *this = ::std::move(from);
  }

  inline SubmitWorkReply& operator=(const SubmitWorkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkReply& operator=(SubmitWorkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitWorkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitWorkReply* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkReply*>(
               &_SubmitWorkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SubmitWorkReply& a, SubmitWorkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitWorkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitWorkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitWorkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitWorkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitWorkReply& from) {
    SubmitWorkReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitWorkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.SubmitWorkReply";
  }
  protected:
  explicit SubmitWorkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.SubmitWorkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class SubmitHashRateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.SubmitHashRateRequest) */ {
 public:
  inline SubmitHashRateRequest() : SubmitHashRateRequest(nullptr) {}
  ~SubmitHashRateRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitHashRateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitHashRateRequest(const SubmitHashRateRequest& from);
  SubmitHashRateRequest(SubmitHashRateRequest&& from) noexcept
    : SubmitHashRateRequest() {
    *this = ::std::move(from);
  }

  inline SubmitHashRateRequest& operator=(const SubmitHashRateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitHashRateRequest& operator=(SubmitHashRateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitHashRateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitHashRateRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitHashRateRequest*>(
               &_SubmitHashRateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SubmitHashRateRequest& a, SubmitHashRateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitHashRateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitHashRateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitHashRateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitHashRateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitHashRateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitHashRateRequest& from) {
    SubmitHashRateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitHashRateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.SubmitHashRateRequest";
  }
  protected:
  explicit SubmitHashRateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kRateFieldNumber = 1,
  };
  // bytes id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 rate = 1;
  void clear_rate();
  uint64_t rate() const;
  void set_rate(uint64_t value);
  private:
  uint64_t _internal_rate() const;
  void _internal_set_rate(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.SubmitHashRateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    uint64_t rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class SubmitHashRateReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.SubmitHashRateReply) */ {
 public:
  inline SubmitHashRateReply() : SubmitHashRateReply(nullptr) {}
  ~SubmitHashRateReply() override;
  explicit PROTOBUF_CONSTEXPR SubmitHashRateReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitHashRateReply(const SubmitHashRateReply& from);
  SubmitHashRateReply(SubmitHashRateReply&& from) noexcept
    : SubmitHashRateReply() {
    *this = ::std::move(from);
  }

  inline SubmitHashRateReply& operator=(const SubmitHashRateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitHashRateReply& operator=(SubmitHashRateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitHashRateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitHashRateReply* internal_default_instance() {
    return reinterpret_cast<const SubmitHashRateReply*>(
               &_SubmitHashRateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SubmitHashRateReply& a, SubmitHashRateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitHashRateReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitHashRateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitHashRateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitHashRateReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitHashRateReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitHashRateReply& from) {
    SubmitHashRateReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitHashRateReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.SubmitHashRateReply";
  }
  protected:
  explicit SubmitHashRateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.SubmitHashRateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class HashRateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.HashRateRequest) */ {
 public:
  inline HashRateRequest() : HashRateRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HashRateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashRateRequest(const HashRateRequest& from);
  HashRateRequest(HashRateRequest&& from) noexcept
    : HashRateRequest() {
    *this = ::std::move(from);
  }

  inline HashRateRequest& operator=(const HashRateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashRateRequest& operator=(HashRateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashRateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashRateRequest* internal_default_instance() {
    return reinterpret_cast<const HashRateRequest*>(
               &_HashRateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HashRateRequest& a, HashRateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HashRateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashRateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashRateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashRateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HashRateRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HashRateRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.HashRateRequest";
  }
  protected:
  explicit HashRateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.HashRateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class HashRateReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.HashRateReply) */ {
 public:
  inline HashRateReply() : HashRateReply(nullptr) {}
  ~HashRateReply() override;
  explicit PROTOBUF_CONSTEXPR HashRateReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashRateReply(const HashRateReply& from);
  HashRateReply(HashRateReply&& from) noexcept
    : HashRateReply() {
    *this = ::std::move(from);
  }

  inline HashRateReply& operator=(const HashRateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashRateReply& operator=(HashRateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashRateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashRateReply* internal_default_instance() {
    return reinterpret_cast<const HashRateReply*>(
               &_HashRateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HashRateReply& a, HashRateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HashRateReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashRateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashRateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashRateReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HashRateReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HashRateReply& from) {
    HashRateReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashRateReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.HashRateReply";
  }
  protected:
  explicit HashRateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashRateFieldNumber = 1,
  };
  // uint64 hashRate = 1;
  void clear_hashrate();
  uint64_t hashrate() const;
  void set_hashrate(uint64_t value);
  private:
  uint64_t _internal_hashrate() const;
  void _internal_set_hashrate(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.HashRateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hashrate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class MiningRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.MiningRequest) */ {
 public:
  inline MiningRequest() : MiningRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MiningRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MiningRequest(const MiningRequest& from);
  MiningRequest(MiningRequest&& from) noexcept
    : MiningRequest() {
    *this = ::std::move(from);
  }

  inline MiningRequest& operator=(const MiningRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MiningRequest& operator=(MiningRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MiningRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MiningRequest* internal_default_instance() {
    return reinterpret_cast<const MiningRequest*>(
               &_MiningRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MiningRequest& a, MiningRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MiningRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MiningRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MiningRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MiningRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MiningRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MiningRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.MiningRequest";
  }
  protected:
  explicit MiningRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.MiningRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class MiningReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.MiningReply) */ {
 public:
  inline MiningReply() : MiningReply(nullptr) {}
  ~MiningReply() override;
  explicit PROTOBUF_CONSTEXPR MiningReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MiningReply(const MiningReply& from);
  MiningReply(MiningReply&& from) noexcept
    : MiningReply() {
    *this = ::std::move(from);
  }

  inline MiningReply& operator=(const MiningReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MiningReply& operator=(MiningReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MiningReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MiningReply* internal_default_instance() {
    return reinterpret_cast<const MiningReply*>(
               &_MiningReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MiningReply& a, MiningReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MiningReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MiningReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MiningReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MiningReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MiningReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MiningReply& from) {
    MiningReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MiningReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.MiningReply";
  }
  protected:
  explicit MiningReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kRunningFieldNumber = 2,
  };
  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool running = 2;
  void clear_running();
  bool running() const;
  void set_running(bool value);
  private:
  bool _internal_running() const;
  void _internal_set_running(bool value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.MiningReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enabled_;
    bool running_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OnPendingBlockRequest

// -------------------------------------------------------------------

// OnPendingBlockReply

// bytes rplBlock = 1;
inline void OnPendingBlockReply::clear_rplblock() {
  _impl_.rplblock_.ClearToEmpty();
}
inline const std::string& OnPendingBlockReply::rplblock() const {
  // @@protoc_insertion_point(field_get:txpool.OnPendingBlockReply.rplBlock)
  return _internal_rplblock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnPendingBlockReply::set_rplblock(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rplblock_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.OnPendingBlockReply.rplBlock)
}
inline std::string* OnPendingBlockReply::mutable_rplblock() {
  std::string* _s = _internal_mutable_rplblock();
  // @@protoc_insertion_point(field_mutable:txpool.OnPendingBlockReply.rplBlock)
  return _s;
}
inline const std::string& OnPendingBlockReply::_internal_rplblock() const {
  return _impl_.rplblock_.Get();
}
inline void OnPendingBlockReply::_internal_set_rplblock(const std::string& value) {
  
  _impl_.rplblock_.Set(value, GetArenaForAllocation());
}
inline std::string* OnPendingBlockReply::_internal_mutable_rplblock() {
  
  return _impl_.rplblock_.Mutable(GetArenaForAllocation());
}
inline std::string* OnPendingBlockReply::release_rplblock() {
  // @@protoc_insertion_point(field_release:txpool.OnPendingBlockReply.rplBlock)
  return _impl_.rplblock_.Release();
}
inline void OnPendingBlockReply::set_allocated_rplblock(std::string* rplblock) {
  if (rplblock != nullptr) {
    
  } else {
    
  }
  _impl_.rplblock_.SetAllocated(rplblock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rplblock_.IsDefault()) {
    _impl_.rplblock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.OnPendingBlockReply.rplBlock)
}

// -------------------------------------------------------------------

// OnMinedBlockRequest

// -------------------------------------------------------------------

// OnMinedBlockReply

// bytes rplBlock = 1;
inline void OnMinedBlockReply::clear_rplblock() {
  _impl_.rplblock_.ClearToEmpty();
}
inline const std::string& OnMinedBlockReply::rplblock() const {
  // @@protoc_insertion_point(field_get:txpool.OnMinedBlockReply.rplBlock)
  return _internal_rplblock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnMinedBlockReply::set_rplblock(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rplblock_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.OnMinedBlockReply.rplBlock)
}
inline std::string* OnMinedBlockReply::mutable_rplblock() {
  std::string* _s = _internal_mutable_rplblock();
  // @@protoc_insertion_point(field_mutable:txpool.OnMinedBlockReply.rplBlock)
  return _s;
}
inline const std::string& OnMinedBlockReply::_internal_rplblock() const {
  return _impl_.rplblock_.Get();
}
inline void OnMinedBlockReply::_internal_set_rplblock(const std::string& value) {
  
  _impl_.rplblock_.Set(value, GetArenaForAllocation());
}
inline std::string* OnMinedBlockReply::_internal_mutable_rplblock() {
  
  return _impl_.rplblock_.Mutable(GetArenaForAllocation());
}
inline std::string* OnMinedBlockReply::release_rplblock() {
  // @@protoc_insertion_point(field_release:txpool.OnMinedBlockReply.rplBlock)
  return _impl_.rplblock_.Release();
}
inline void OnMinedBlockReply::set_allocated_rplblock(std::string* rplblock) {
  if (rplblock != nullptr) {
    
  } else {
    
  }
  _impl_.rplblock_.SetAllocated(rplblock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rplblock_.IsDefault()) {
    _impl_.rplblock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.OnMinedBlockReply.rplBlock)
}

// -------------------------------------------------------------------

// OnPendingLogsRequest

// -------------------------------------------------------------------

// OnPendingLogsReply

// bytes rplLogs = 1;
inline void OnPendingLogsReply::clear_rpllogs() {
  _impl_.rpllogs_.ClearToEmpty();
}
inline const std::string& OnPendingLogsReply::rpllogs() const {
  // @@protoc_insertion_point(field_get:txpool.OnPendingLogsReply.rplLogs)
  return _internal_rpllogs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnPendingLogsReply::set_rpllogs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rpllogs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.OnPendingLogsReply.rplLogs)
}
inline std::string* OnPendingLogsReply::mutable_rpllogs() {
  std::string* _s = _internal_mutable_rpllogs();
  // @@protoc_insertion_point(field_mutable:txpool.OnPendingLogsReply.rplLogs)
  return _s;
}
inline const std::string& OnPendingLogsReply::_internal_rpllogs() const {
  return _impl_.rpllogs_.Get();
}
inline void OnPendingLogsReply::_internal_set_rpllogs(const std::string& value) {
  
  _impl_.rpllogs_.Set(value, GetArenaForAllocation());
}
inline std::string* OnPendingLogsReply::_internal_mutable_rpllogs() {
  
  return _impl_.rpllogs_.Mutable(GetArenaForAllocation());
}
inline std::string* OnPendingLogsReply::release_rpllogs() {
  // @@protoc_insertion_point(field_release:txpool.OnPendingLogsReply.rplLogs)
  return _impl_.rpllogs_.Release();
}
inline void OnPendingLogsReply::set_allocated_rpllogs(std::string* rpllogs) {
  if (rpllogs != nullptr) {
    
  } else {
    
  }
  _impl_.rpllogs_.SetAllocated(rpllogs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rpllogs_.IsDefault()) {
    _impl_.rpllogs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.OnPendingLogsReply.rplLogs)
}

// -------------------------------------------------------------------

// GetWorkRequest

// -------------------------------------------------------------------

// GetWorkReply

// string headerHash = 1;
inline void GetWorkReply::clear_headerhash() {
  _impl_.headerhash_.ClearToEmpty();
}
inline const std::string& GetWorkReply::headerhash() const {
  // @@protoc_insertion_point(field_get:txpool.GetWorkReply.headerHash)
  return _internal_headerhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkReply::set_headerhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.headerhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.GetWorkReply.headerHash)
}
inline std::string* GetWorkReply::mutable_headerhash() {
  std::string* _s = _internal_mutable_headerhash();
  // @@protoc_insertion_point(field_mutable:txpool.GetWorkReply.headerHash)
  return _s;
}
inline const std::string& GetWorkReply::_internal_headerhash() const {
  return _impl_.headerhash_.Get();
}
inline void GetWorkReply::_internal_set_headerhash(const std::string& value) {
  
  _impl_.headerhash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkReply::_internal_mutable_headerhash() {
  
  return _impl_.headerhash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkReply::release_headerhash() {
  // @@protoc_insertion_point(field_release:txpool.GetWorkReply.headerHash)
  return _impl_.headerhash_.Release();
}
inline void GetWorkReply::set_allocated_headerhash(std::string* headerhash) {
  if (headerhash != nullptr) {
    
  } else {
    
  }
  _impl_.headerhash_.SetAllocated(headerhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.headerhash_.IsDefault()) {
    _impl_.headerhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.GetWorkReply.headerHash)
}

// string seedHash = 2;
inline void GetWorkReply::clear_seedhash() {
  _impl_.seedhash_.ClearToEmpty();
}
inline const std::string& GetWorkReply::seedhash() const {
  // @@protoc_insertion_point(field_get:txpool.GetWorkReply.seedHash)
  return _internal_seedhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkReply::set_seedhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.seedhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.GetWorkReply.seedHash)
}
inline std::string* GetWorkReply::mutable_seedhash() {
  std::string* _s = _internal_mutable_seedhash();
  // @@protoc_insertion_point(field_mutable:txpool.GetWorkReply.seedHash)
  return _s;
}
inline const std::string& GetWorkReply::_internal_seedhash() const {
  return _impl_.seedhash_.Get();
}
inline void GetWorkReply::_internal_set_seedhash(const std::string& value) {
  
  _impl_.seedhash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkReply::_internal_mutable_seedhash() {
  
  return _impl_.seedhash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkReply::release_seedhash() {
  // @@protoc_insertion_point(field_release:txpool.GetWorkReply.seedHash)
  return _impl_.seedhash_.Release();
}
inline void GetWorkReply::set_allocated_seedhash(std::string* seedhash) {
  if (seedhash != nullptr) {
    
  } else {
    
  }
  _impl_.seedhash_.SetAllocated(seedhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seedhash_.IsDefault()) {
    _impl_.seedhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.GetWorkReply.seedHash)
}

// string target = 3;
inline void GetWorkReply::clear_target() {
  _impl_.target_.ClearToEmpty();
}
inline const std::string& GetWorkReply::target() const {
  // @@protoc_insertion_point(field_get:txpool.GetWorkReply.target)
  return _internal_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkReply::set_target(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.GetWorkReply.target)
}
inline std::string* GetWorkReply::mutable_target() {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:txpool.GetWorkReply.target)
  return _s;
}
inline const std::string& GetWorkReply::_internal_target() const {
  return _impl_.target_.Get();
}
inline void GetWorkReply::_internal_set_target(const std::string& value) {
  
  _impl_.target_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkReply::_internal_mutable_target() {
  
  return _impl_.target_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkReply::release_target() {
  // @@protoc_insertion_point(field_release:txpool.GetWorkReply.target)
  return _impl_.target_.Release();
}
inline void GetWorkReply::set_allocated_target(std::string* target) {
  if (target != nullptr) {
    
  } else {
    
  }
  _impl_.target_.SetAllocated(target, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.GetWorkReply.target)
}

// string blockNumber = 4;
inline void GetWorkReply::clear_blocknumber() {
  _impl_.blocknumber_.ClearToEmpty();
}
inline const std::string& GetWorkReply::blocknumber() const {
  // @@protoc_insertion_point(field_get:txpool.GetWorkReply.blockNumber)
  return _internal_blocknumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkReply::set_blocknumber(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blocknumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.GetWorkReply.blockNumber)
}
inline std::string* GetWorkReply::mutable_blocknumber() {
  std::string* _s = _internal_mutable_blocknumber();
  // @@protoc_insertion_point(field_mutable:txpool.GetWorkReply.blockNumber)
  return _s;
}
inline const std::string& GetWorkReply::_internal_blocknumber() const {
  return _impl_.blocknumber_.Get();
}
inline void GetWorkReply::_internal_set_blocknumber(const std::string& value) {
  
  _impl_.blocknumber_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkReply::_internal_mutable_blocknumber() {
  
  return _impl_.blocknumber_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkReply::release_blocknumber() {
  // @@protoc_insertion_point(field_release:txpool.GetWorkReply.blockNumber)
  return _impl_.blocknumber_.Release();
}
inline void GetWorkReply::set_allocated_blocknumber(std::string* blocknumber) {
  if (blocknumber != nullptr) {
    
  } else {
    
  }
  _impl_.blocknumber_.SetAllocated(blocknumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blocknumber_.IsDefault()) {
    _impl_.blocknumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.GetWorkReply.blockNumber)
}

// -------------------------------------------------------------------

// SubmitWorkRequest

// bytes blockNonce = 1;
inline void SubmitWorkRequest::clear_blocknonce() {
  _impl_.blocknonce_.ClearToEmpty();
}
inline const std::string& SubmitWorkRequest::blocknonce() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitWorkRequest.blockNonce)
  return _internal_blocknonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitWorkRequest::set_blocknonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blocknonce_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.SubmitWorkRequest.blockNonce)
}
inline std::string* SubmitWorkRequest::mutable_blocknonce() {
  std::string* _s = _internal_mutable_blocknonce();
  // @@protoc_insertion_point(field_mutable:txpool.SubmitWorkRequest.blockNonce)
  return _s;
}
inline const std::string& SubmitWorkRequest::_internal_blocknonce() const {
  return _impl_.blocknonce_.Get();
}
inline void SubmitWorkRequest::_internal_set_blocknonce(const std::string& value) {
  
  _impl_.blocknonce_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::_internal_mutable_blocknonce() {
  
  return _impl_.blocknonce_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::release_blocknonce() {
  // @@protoc_insertion_point(field_release:txpool.SubmitWorkRequest.blockNonce)
  return _impl_.blocknonce_.Release();
}
inline void SubmitWorkRequest::set_allocated_blocknonce(std::string* blocknonce) {
  if (blocknonce != nullptr) {
    
  } else {
    
  }
  _impl_.blocknonce_.SetAllocated(blocknonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blocknonce_.IsDefault()) {
    _impl_.blocknonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.SubmitWorkRequest.blockNonce)
}

// bytes powHash = 2;
inline void SubmitWorkRequest::clear_powhash() {
  _impl_.powhash_.ClearToEmpty();
}
inline const std::string& SubmitWorkRequest::powhash() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitWorkRequest.powHash)
  return _internal_powhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitWorkRequest::set_powhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.powhash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.SubmitWorkRequest.powHash)
}
inline std::string* SubmitWorkRequest::mutable_powhash() {
  std::string* _s = _internal_mutable_powhash();
  // @@protoc_insertion_point(field_mutable:txpool.SubmitWorkRequest.powHash)
  return _s;
}
inline const std::string& SubmitWorkRequest::_internal_powhash() const {
  return _impl_.powhash_.Get();
}
inline void SubmitWorkRequest::_internal_set_powhash(const std::string& value) {
  
  _impl_.powhash_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::_internal_mutable_powhash() {
  
  return _impl_.powhash_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::release_powhash() {
  // @@protoc_insertion_point(field_release:txpool.SubmitWorkRequest.powHash)
  return _impl_.powhash_.Release();
}
inline void SubmitWorkRequest::set_allocated_powhash(std::string* powhash) {
  if (powhash != nullptr) {
    
  } else {
    
  }
  _impl_.powhash_.SetAllocated(powhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.powhash_.IsDefault()) {
    _impl_.powhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.SubmitWorkRequest.powHash)
}

// bytes digest = 3;
inline void SubmitWorkRequest::clear_digest() {
  _impl_.digest_.ClearToEmpty();
}
inline const std::string& SubmitWorkRequest::digest() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitWorkRequest.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitWorkRequest::set_digest(ArgT0&& arg0, ArgT... args) {
 
 _impl_.digest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.SubmitWorkRequest.digest)
}
inline std::string* SubmitWorkRequest::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:txpool.SubmitWorkRequest.digest)
  return _s;
}
inline const std::string& SubmitWorkRequest::_internal_digest() const {
  return _impl_.digest_.Get();
}
inline void SubmitWorkRequest::_internal_set_digest(const std::string& value) {
  
  _impl_.digest_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::_internal_mutable_digest() {
  
  return _impl_.digest_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::release_digest() {
  // @@protoc_insertion_point(field_release:txpool.SubmitWorkRequest.digest)
  return _impl_.digest_.Release();
}
inline void SubmitWorkRequest::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  _impl_.digest_.SetAllocated(digest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digest_.IsDefault()) {
    _impl_.digest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.SubmitWorkRequest.digest)
}

// -------------------------------------------------------------------

// SubmitWorkReply

// bool ok = 1;
inline void SubmitWorkReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SubmitWorkReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SubmitWorkReply::ok() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitWorkReply.ok)
  return _internal_ok();
}
inline void SubmitWorkReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SubmitWorkReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:txpool.SubmitWorkReply.ok)
}

// -------------------------------------------------------------------

// SubmitHashRateRequest

// uint64 rate = 1;
inline void SubmitHashRateRequest::clear_rate() {
  _impl_.rate_ = uint64_t{0u};
}
inline uint64_t SubmitHashRateRequest::_internal_rate() const {
  return _impl_.rate_;
}
inline uint64_t SubmitHashRateRequest::rate() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitHashRateRequest.rate)
  return _internal_rate();
}
inline void SubmitHashRateRequest::_internal_set_rate(uint64_t value) {
  
  _impl_.rate_ = value;
}
inline void SubmitHashRateRequest::set_rate(uint64_t value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:txpool.SubmitHashRateRequest.rate)
}

// bytes id = 2;
inline void SubmitHashRateRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SubmitHashRateRequest::id() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitHashRateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitHashRateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.SubmitHashRateRequest.id)
}
inline std::string* SubmitHashRateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:txpool.SubmitHashRateRequest.id)
  return _s;
}
inline const std::string& SubmitHashRateRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SubmitHashRateRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitHashRateRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitHashRateRequest::release_id() {
  // @@protoc_insertion_point(field_release:txpool.SubmitHashRateRequest.id)
  return _impl_.id_.Release();
}
inline void SubmitHashRateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.SubmitHashRateRequest.id)
}

// -------------------------------------------------------------------

// SubmitHashRateReply

// bool ok = 1;
inline void SubmitHashRateReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SubmitHashRateReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SubmitHashRateReply::ok() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitHashRateReply.ok)
  return _internal_ok();
}
inline void SubmitHashRateReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SubmitHashRateReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:txpool.SubmitHashRateReply.ok)
}

// -------------------------------------------------------------------

// HashRateRequest

// -------------------------------------------------------------------

// HashRateReply

// uint64 hashRate = 1;
inline void HashRateReply::clear_hashrate() {
  _impl_.hashrate_ = uint64_t{0u};
}
inline uint64_t HashRateReply::_internal_hashrate() const {
  return _impl_.hashrate_;
}
inline uint64_t HashRateReply::hashrate() const {
  // @@protoc_insertion_point(field_get:txpool.HashRateReply.hashRate)
  return _internal_hashrate();
}
inline void HashRateReply::_internal_set_hashrate(uint64_t value) {
  
  _impl_.hashrate_ = value;
}
inline void HashRateReply::set_hashrate(uint64_t value) {
  _internal_set_hashrate(value);
  // @@protoc_insertion_point(field_set:txpool.HashRateReply.hashRate)
}

// -------------------------------------------------------------------

// MiningRequest

// -------------------------------------------------------------------

// MiningReply

// bool enabled = 1;
inline void MiningReply::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool MiningReply::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool MiningReply::enabled() const {
  // @@protoc_insertion_point(field_get:txpool.MiningReply.enabled)
  return _internal_enabled();
}
inline void MiningReply::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void MiningReply::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:txpool.MiningReply.enabled)
}

// bool running = 2;
inline void MiningReply::clear_running() {
  _impl_.running_ = false;
}
inline bool MiningReply::_internal_running() const {
  return _impl_.running_;
}
inline bool MiningReply::running() const {
  // @@protoc_insertion_point(field_get:txpool.MiningReply.running)
  return _internal_running();
}
inline void MiningReply::_internal_set_running(bool value) {
  
  _impl_.running_ = value;
}
inline void MiningReply::set_running(bool value) {
  _internal_set_running(value);
  // @@protoc_insertion_point(field_set:txpool.MiningReply.running)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace txpool

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_txpool_2fmining_2eproto
