// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_types_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_types_2ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_types_2ftypes_2eproto;
namespace types {
class H1024;
class H1024DefaultTypeInternal;
extern H1024DefaultTypeInternal _H1024_default_instance_;
class H128;
class H128DefaultTypeInternal;
extern H128DefaultTypeInternal _H128_default_instance_;
class H160;
class H160DefaultTypeInternal;
extern H160DefaultTypeInternal _H160_default_instance_;
class H2048;
class H2048DefaultTypeInternal;
extern H2048DefaultTypeInternal _H2048_default_instance_;
class H256;
class H256DefaultTypeInternal;
extern H256DefaultTypeInternal _H256_default_instance_;
class H512;
class H512DefaultTypeInternal;
extern H512DefaultTypeInternal _H512_default_instance_;
class NodeInfoPorts;
class NodeInfoPortsDefaultTypeInternal;
extern NodeInfoPortsDefaultTypeInternal _NodeInfoPorts_default_instance_;
class NodeInfoReply;
class NodeInfoReplyDefaultTypeInternal;
extern NodeInfoReplyDefaultTypeInternal _NodeInfoReply_default_instance_;
class VersionReply;
class VersionReplyDefaultTypeInternal;
extern VersionReplyDefaultTypeInternal _VersionReply_default_instance_;
}  // namespace types
PROTOBUF_NAMESPACE_OPEN
template<> ::types::H1024* Arena::CreateMaybeMessage<::types::H1024>(Arena*);
template<> ::types::H128* Arena::CreateMaybeMessage<::types::H128>(Arena*);
template<> ::types::H160* Arena::CreateMaybeMessage<::types::H160>(Arena*);
template<> ::types::H2048* Arena::CreateMaybeMessage<::types::H2048>(Arena*);
template<> ::types::H256* Arena::CreateMaybeMessage<::types::H256>(Arena*);
template<> ::types::H512* Arena::CreateMaybeMessage<::types::H512>(Arena*);
template<> ::types::NodeInfoPorts* Arena::CreateMaybeMessage<::types::NodeInfoPorts>(Arena*);
template<> ::types::NodeInfoReply* Arena::CreateMaybeMessage<::types::NodeInfoReply>(Arena*);
template<> ::types::VersionReply* Arena::CreateMaybeMessage<::types::VersionReply>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace types {

// ===================================================================

class H128 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H128) */ {
 public:
  inline H128() : H128(nullptr) {}
  virtual ~H128();

  H128(const H128& from);
  H128(H128&& from) noexcept
    : H128() {
    *this = ::std::move(from);
  }

  inline H128& operator=(const H128& from) {
    CopyFrom(from);
    return *this;
  }
  inline H128& operator=(H128&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const H128& default_instance();

  static inline const H128* internal_default_instance() {
    return reinterpret_cast<const H128*>(
               &_H128_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(H128& a, H128& b) {
    a.Swap(&b);
  }
  inline void Swap(H128* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H128* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline H128* New() const final {
    return CreateMaybeMessage<H128>(nullptr);
  }

  H128* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<H128>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const H128& from);
  void MergeFrom(const H128& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H128* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H128";
  }
  protected:
  explicit H128(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // uint64 hi = 1;
  void clear_hi();
  ::PROTOBUF_NAMESPACE_ID::uint64 hi() const;
  void set_hi(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_hi() const;
  void _internal_set_hi(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 lo = 2;
  void clear_lo();
  ::PROTOBUF_NAMESPACE_ID::uint64 lo() const;
  void set_lo(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_lo() const;
  void _internal_set_lo(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:types.H128)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 hi_;
  ::PROTOBUF_NAMESPACE_ID::uint64 lo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H160 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H160) */ {
 public:
  inline H160() : H160(nullptr) {}
  virtual ~H160();

  H160(const H160& from);
  H160(H160&& from) noexcept
    : H160() {
    *this = ::std::move(from);
  }

  inline H160& operator=(const H160& from) {
    CopyFrom(from);
    return *this;
  }
  inline H160& operator=(H160&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const H160& default_instance();

  static inline const H160* internal_default_instance() {
    return reinterpret_cast<const H160*>(
               &_H160_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(H160& a, H160& b) {
    a.Swap(&b);
  }
  inline void Swap(H160* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H160* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline H160* New() const final {
    return CreateMaybeMessage<H160>(nullptr);
  }

  H160* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<H160>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const H160& from);
  void MergeFrom(const H160& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H160* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H160";
  }
  protected:
  explicit H160(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H128 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H128& hi() const;
  ::types::H128* release_hi();
  ::types::H128* mutable_hi();
  void set_allocated_hi(::types::H128* hi);
  private:
  const ::types::H128& _internal_hi() const;
  ::types::H128* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H128* hi);
  ::types::H128* unsafe_arena_release_hi();

  // uint32 lo = 2;
  void clear_lo();
  ::PROTOBUF_NAMESPACE_ID::uint32 lo() const;
  void set_lo(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lo() const;
  void _internal_set_lo(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:types.H160)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H128* hi_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H256 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H256) */ {
 public:
  inline H256() : H256(nullptr) {}
  virtual ~H256();

  H256(const H256& from);
  H256(H256&& from) noexcept
    : H256() {
    *this = ::std::move(from);
  }

  inline H256& operator=(const H256& from) {
    CopyFrom(from);
    return *this;
  }
  inline H256& operator=(H256&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const H256& default_instance();

  static inline const H256* internal_default_instance() {
    return reinterpret_cast<const H256*>(
               &_H256_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(H256& a, H256& b) {
    a.Swap(&b);
  }
  inline void Swap(H256* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H256* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline H256* New() const final {
    return CreateMaybeMessage<H256>(nullptr);
  }

  H256* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<H256>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const H256& from);
  void MergeFrom(const H256& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H256* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H256";
  }
  protected:
  explicit H256(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H128 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H128& hi() const;
  ::types::H128* release_hi();
  ::types::H128* mutable_hi();
  void set_allocated_hi(::types::H128* hi);
  private:
  const ::types::H128& _internal_hi() const;
  ::types::H128* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H128* hi);
  ::types::H128* unsafe_arena_release_hi();

  // .types.H128 lo = 2;
  bool has_lo() const;
  private:
  bool _internal_has_lo() const;
  public:
  void clear_lo();
  const ::types::H128& lo() const;
  ::types::H128* release_lo();
  ::types::H128* mutable_lo();
  void set_allocated_lo(::types::H128* lo);
  private:
  const ::types::H128& _internal_lo() const;
  ::types::H128* _internal_mutable_lo();
  public:
  void unsafe_arena_set_allocated_lo(
      ::types::H128* lo);
  ::types::H128* unsafe_arena_release_lo();

  // @@protoc_insertion_point(class_scope:types.H256)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H128* hi_;
  ::types::H128* lo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H512 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H512) */ {
 public:
  inline H512() : H512(nullptr) {}
  virtual ~H512();

  H512(const H512& from);
  H512(H512&& from) noexcept
    : H512() {
    *this = ::std::move(from);
  }

  inline H512& operator=(const H512& from) {
    CopyFrom(from);
    return *this;
  }
  inline H512& operator=(H512&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const H512& default_instance();

  static inline const H512* internal_default_instance() {
    return reinterpret_cast<const H512*>(
               &_H512_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(H512& a, H512& b) {
    a.Swap(&b);
  }
  inline void Swap(H512* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H512* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline H512* New() const final {
    return CreateMaybeMessage<H512>(nullptr);
  }

  H512* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<H512>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const H512& from);
  void MergeFrom(const H512& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H512* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H512";
  }
  protected:
  explicit H512(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H256 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H256& hi() const;
  ::types::H256* release_hi();
  ::types::H256* mutable_hi();
  void set_allocated_hi(::types::H256* hi);
  private:
  const ::types::H256& _internal_hi() const;
  ::types::H256* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H256* hi);
  ::types::H256* unsafe_arena_release_hi();

  // .types.H256 lo = 2;
  bool has_lo() const;
  private:
  bool _internal_has_lo() const;
  public:
  void clear_lo();
  const ::types::H256& lo() const;
  ::types::H256* release_lo();
  ::types::H256* mutable_lo();
  void set_allocated_lo(::types::H256* lo);
  private:
  const ::types::H256& _internal_lo() const;
  ::types::H256* _internal_mutable_lo();
  public:
  void unsafe_arena_set_allocated_lo(
      ::types::H256* lo);
  ::types::H256* unsafe_arena_release_lo();

  // @@protoc_insertion_point(class_scope:types.H512)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H256* hi_;
  ::types::H256* lo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H1024 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H1024) */ {
 public:
  inline H1024() : H1024(nullptr) {}
  virtual ~H1024();

  H1024(const H1024& from);
  H1024(H1024&& from) noexcept
    : H1024() {
    *this = ::std::move(from);
  }

  inline H1024& operator=(const H1024& from) {
    CopyFrom(from);
    return *this;
  }
  inline H1024& operator=(H1024&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const H1024& default_instance();

  static inline const H1024* internal_default_instance() {
    return reinterpret_cast<const H1024*>(
               &_H1024_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(H1024& a, H1024& b) {
    a.Swap(&b);
  }
  inline void Swap(H1024* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H1024* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline H1024* New() const final {
    return CreateMaybeMessage<H1024>(nullptr);
  }

  H1024* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<H1024>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const H1024& from);
  void MergeFrom(const H1024& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H1024* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H1024";
  }
  protected:
  explicit H1024(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H512 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H512& hi() const;
  ::types::H512* release_hi();
  ::types::H512* mutable_hi();
  void set_allocated_hi(::types::H512* hi);
  private:
  const ::types::H512& _internal_hi() const;
  ::types::H512* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H512* hi);
  ::types::H512* unsafe_arena_release_hi();

  // .types.H512 lo = 2;
  bool has_lo() const;
  private:
  bool _internal_has_lo() const;
  public:
  void clear_lo();
  const ::types::H512& lo() const;
  ::types::H512* release_lo();
  ::types::H512* mutable_lo();
  void set_allocated_lo(::types::H512* lo);
  private:
  const ::types::H512& _internal_lo() const;
  ::types::H512* _internal_mutable_lo();
  public:
  void unsafe_arena_set_allocated_lo(
      ::types::H512* lo);
  ::types::H512* unsafe_arena_release_lo();

  // @@protoc_insertion_point(class_scope:types.H1024)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H512* hi_;
  ::types::H512* lo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H2048 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H2048) */ {
 public:
  inline H2048() : H2048(nullptr) {}
  virtual ~H2048();

  H2048(const H2048& from);
  H2048(H2048&& from) noexcept
    : H2048() {
    *this = ::std::move(from);
  }

  inline H2048& operator=(const H2048& from) {
    CopyFrom(from);
    return *this;
  }
  inline H2048& operator=(H2048&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const H2048& default_instance();

  static inline const H2048* internal_default_instance() {
    return reinterpret_cast<const H2048*>(
               &_H2048_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(H2048& a, H2048& b) {
    a.Swap(&b);
  }
  inline void Swap(H2048* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H2048* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline H2048* New() const final {
    return CreateMaybeMessage<H2048>(nullptr);
  }

  H2048* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<H2048>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const H2048& from);
  void MergeFrom(const H2048& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H2048* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H2048";
  }
  protected:
  explicit H2048(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H1024 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H1024& hi() const;
  ::types::H1024* release_hi();
  ::types::H1024* mutable_hi();
  void set_allocated_hi(::types::H1024* hi);
  private:
  const ::types::H1024& _internal_hi() const;
  ::types::H1024* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H1024* hi);
  ::types::H1024* unsafe_arena_release_hi();

  // .types.H1024 lo = 2;
  bool has_lo() const;
  private:
  bool _internal_has_lo() const;
  public:
  void clear_lo();
  const ::types::H1024& lo() const;
  ::types::H1024* release_lo();
  ::types::H1024* mutable_lo();
  void set_allocated_lo(::types::H1024* lo);
  private:
  const ::types::H1024& _internal_lo() const;
  ::types::H1024* _internal_mutable_lo();
  public:
  void unsafe_arena_set_allocated_lo(
      ::types::H1024* lo);
  ::types::H1024* unsafe_arena_release_lo();

  // @@protoc_insertion_point(class_scope:types.H2048)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H1024* hi_;
  ::types::H1024* lo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class VersionReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.VersionReply) */ {
 public:
  inline VersionReply() : VersionReply(nullptr) {}
  virtual ~VersionReply();

  VersionReply(const VersionReply& from);
  VersionReply(VersionReply&& from) noexcept
    : VersionReply() {
    *this = ::std::move(from);
  }

  inline VersionReply& operator=(const VersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionReply& operator=(VersionReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionReply& default_instance();

  static inline const VersionReply* internal_default_instance() {
    return reinterpret_cast<const VersionReply*>(
               &_VersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VersionReply& a, VersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionReply* New() const final {
    return CreateMaybeMessage<VersionReply>(nullptr);
  }

  VersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionReply& from);
  void MergeFrom(const VersionReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.VersionReply";
  }
  protected:
  explicit VersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // uint32 major = 1;
  void clear_major();
  ::PROTOBUF_NAMESPACE_ID::uint32 major() const;
  void set_major(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_major() const;
  void _internal_set_major(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 minor = 2;
  void clear_minor();
  ::PROTOBUF_NAMESPACE_ID::uint32 minor() const;
  void set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_minor() const;
  void _internal_set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 patch = 3;
  void clear_patch();
  ::PROTOBUF_NAMESPACE_ID::uint32 patch() const;
  void set_patch(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_patch() const;
  void _internal_set_patch(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:types.VersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 major_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 patch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoPorts PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.NodeInfoPorts) */ {
 public:
  inline NodeInfoPorts() : NodeInfoPorts(nullptr) {}
  virtual ~NodeInfoPorts();

  NodeInfoPorts(const NodeInfoPorts& from);
  NodeInfoPorts(NodeInfoPorts&& from) noexcept
    : NodeInfoPorts() {
    *this = ::std::move(from);
  }

  inline NodeInfoPorts& operator=(const NodeInfoPorts& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoPorts& operator=(NodeInfoPorts&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeInfoPorts& default_instance();

  static inline const NodeInfoPorts* internal_default_instance() {
    return reinterpret_cast<const NodeInfoPorts*>(
               &_NodeInfoPorts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NodeInfoPorts& a, NodeInfoPorts& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoPorts* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoPorts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfoPorts* New() const final {
    return CreateMaybeMessage<NodeInfoPorts>(nullptr);
  }

  NodeInfoPorts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfoPorts>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeInfoPorts& from);
  void MergeFrom(const NodeInfoPorts& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfoPorts* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.NodeInfoPorts";
  }
  protected:
  explicit NodeInfoPorts(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiscoveryFieldNumber = 1,
    kListenerFieldNumber = 2,
  };
  // uint32 discovery = 1;
  void clear_discovery();
  ::PROTOBUF_NAMESPACE_ID::uint32 discovery() const;
  void set_discovery(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_discovery() const;
  void _internal_set_discovery(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 listener = 2;
  void clear_listener();
  ::PROTOBUF_NAMESPACE_ID::uint32 listener() const;
  void set_listener(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_listener() const;
  void _internal_set_listener(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:types.NodeInfoPorts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 discovery_;
  ::PROTOBUF_NAMESPACE_ID::uint32 listener_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.NodeInfoReply) */ {
 public:
  inline NodeInfoReply() : NodeInfoReply(nullptr) {}
  virtual ~NodeInfoReply();

  NodeInfoReply(const NodeInfoReply& from);
  NodeInfoReply(NodeInfoReply&& from) noexcept
    : NodeInfoReply() {
    *this = ::std::move(from);
  }

  inline NodeInfoReply& operator=(const NodeInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoReply& operator=(NodeInfoReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeInfoReply& default_instance();

  static inline const NodeInfoReply* internal_default_instance() {
    return reinterpret_cast<const NodeInfoReply*>(
               &_NodeInfoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NodeInfoReply& a, NodeInfoReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfoReply* New() const final {
    return CreateMaybeMessage<NodeInfoReply>(nullptr);
  }

  NodeInfoReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfoReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeInfoReply& from);
  void MergeFrom(const NodeInfoReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfoReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.NodeInfoReply";
  }
  protected:
  explicit NodeInfoReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2ftypes_2eproto);
    return ::descriptor_table_types_2ftypes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kEnodeFieldNumber = 3,
    kEnrFieldNumber = 4,
    kListenerAddrFieldNumber = 6,
    kProtocolsFieldNumber = 7,
    kPortsFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string enode = 3;
  void clear_enode();
  const std::string& enode() const;
  void set_enode(const std::string& value);
  void set_enode(std::string&& value);
  void set_enode(const char* value);
  void set_enode(const char* value, size_t size);
  std::string* mutable_enode();
  std::string* release_enode();
  void set_allocated_enode(std::string* enode);
  private:
  const std::string& _internal_enode() const;
  void _internal_set_enode(const std::string& value);
  std::string* _internal_mutable_enode();
  public:

  // string enr = 4;
  void clear_enr();
  const std::string& enr() const;
  void set_enr(const std::string& value);
  void set_enr(std::string&& value);
  void set_enr(const char* value);
  void set_enr(const char* value, size_t size);
  std::string* mutable_enr();
  std::string* release_enr();
  void set_allocated_enr(std::string* enr);
  private:
  const std::string& _internal_enr() const;
  void _internal_set_enr(const std::string& value);
  std::string* _internal_mutable_enr();
  public:

  // string listenerAddr = 6;
  void clear_listeneraddr();
  const std::string& listeneraddr() const;
  void set_listeneraddr(const std::string& value);
  void set_listeneraddr(std::string&& value);
  void set_listeneraddr(const char* value);
  void set_listeneraddr(const char* value, size_t size);
  std::string* mutable_listeneraddr();
  std::string* release_listeneraddr();
  void set_allocated_listeneraddr(std::string* listeneraddr);
  private:
  const std::string& _internal_listeneraddr() const;
  void _internal_set_listeneraddr(const std::string& value);
  std::string* _internal_mutable_listeneraddr();
  public:

  // bytes protocols = 7;
  void clear_protocols();
  const std::string& protocols() const;
  void set_protocols(const std::string& value);
  void set_protocols(std::string&& value);
  void set_protocols(const char* value);
  void set_protocols(const void* value, size_t size);
  std::string* mutable_protocols();
  std::string* release_protocols();
  void set_allocated_protocols(std::string* protocols);
  private:
  const std::string& _internal_protocols() const;
  void _internal_set_protocols(const std::string& value);
  std::string* _internal_mutable_protocols();
  public:

  // .types.NodeInfoPorts ports = 5;
  bool has_ports() const;
  private:
  bool _internal_has_ports() const;
  public:
  void clear_ports();
  const ::types::NodeInfoPorts& ports() const;
  ::types::NodeInfoPorts* release_ports();
  ::types::NodeInfoPorts* mutable_ports();
  void set_allocated_ports(::types::NodeInfoPorts* ports);
  private:
  const ::types::NodeInfoPorts& _internal_ports() const;
  ::types::NodeInfoPorts* _internal_mutable_ports();
  public:
  void unsafe_arena_set_allocated_ports(
      ::types::NodeInfoPorts* ports);
  ::types::NodeInfoPorts* unsafe_arena_release_ports();

  // @@protoc_insertion_point(class_scope:types.NodeInfoReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr listeneraddr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocols_;
  ::types::NodeInfoPorts* ports_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// ===================================================================

static const int kServiceMajorVersionFieldNumber = 50001;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< ::PROTOBUF_NAMESPACE_ID::uint32 >, 13, false >
  service_major_version;
static const int kServiceMinorVersionFieldNumber = 50002;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< ::PROTOBUF_NAMESPACE_ID::uint32 >, 13, false >
  service_minor_version;
static const int kServicePatchVersionFieldNumber = 50003;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< ::PROTOBUF_NAMESPACE_ID::uint32 >, 13, false >
  service_patch_version;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// H128

// uint64 hi = 1;
inline void H128::clear_hi() {
  hi_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 H128::_internal_hi() const {
  return hi_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 H128::hi() const {
  // @@protoc_insertion_point(field_get:types.H128.hi)
  return _internal_hi();
}
inline void H128::_internal_set_hi(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  hi_ = value;
}
inline void H128::set_hi(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_hi(value);
  // @@protoc_insertion_point(field_set:types.H128.hi)
}

// uint64 lo = 2;
inline void H128::clear_lo() {
  lo_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 H128::_internal_lo() const {
  return lo_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 H128::lo() const {
  // @@protoc_insertion_point(field_get:types.H128.lo)
  return _internal_lo();
}
inline void H128::_internal_set_lo(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  lo_ = value;
}
inline void H128::set_lo(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:types.H128.lo)
}

// -------------------------------------------------------------------

// H160

// .types.H128 hi = 1;
inline bool H160::_internal_has_hi() const {
  return this != internal_default_instance() && hi_ != nullptr;
}
inline bool H160::has_hi() const {
  return _internal_has_hi();
}
inline void H160::clear_hi() {
  if (GetArena() == nullptr && hi_ != nullptr) {
    delete hi_;
  }
  hi_ = nullptr;
}
inline const ::types::H128& H160::_internal_hi() const {
  const ::types::H128* p = hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(
      ::types::_H128_default_instance_);
}
inline const ::types::H128& H160::hi() const {
  // @@protoc_insertion_point(field_get:types.H160.hi)
  return _internal_hi();
}
inline void H160::unsafe_arena_set_allocated_hi(
    ::types::H128* hi) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hi_);
  }
  hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H160.hi)
}
inline ::types::H128* H160::release_hi() {
  
  ::types::H128* temp = hi_;
  hi_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H128* H160::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H160.hi)
  
  ::types::H128* temp = hi_;
  hi_ = nullptr;
  return temp;
}
inline ::types::H128* H160::_internal_mutable_hi() {
  
  if (hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H128>(GetArena());
    hi_ = p;
  }
  return hi_;
}
inline ::types::H128* H160::mutable_hi() {
  // @@protoc_insertion_point(field_mutable:types.H160.hi)
  return _internal_mutable_hi();
}
inline void H160::set_allocated_hi(::types::H128* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H160.hi)
}

// uint32 lo = 2;
inline void H160::clear_lo() {
  lo_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 H160::_internal_lo() const {
  return lo_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 H160::lo() const {
  // @@protoc_insertion_point(field_get:types.H160.lo)
  return _internal_lo();
}
inline void H160::_internal_set_lo(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lo_ = value;
}
inline void H160::set_lo(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:types.H160.lo)
}

// -------------------------------------------------------------------

// H256

// .types.H128 hi = 1;
inline bool H256::_internal_has_hi() const {
  return this != internal_default_instance() && hi_ != nullptr;
}
inline bool H256::has_hi() const {
  return _internal_has_hi();
}
inline void H256::clear_hi() {
  if (GetArena() == nullptr && hi_ != nullptr) {
    delete hi_;
  }
  hi_ = nullptr;
}
inline const ::types::H128& H256::_internal_hi() const {
  const ::types::H128* p = hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(
      ::types::_H128_default_instance_);
}
inline const ::types::H128& H256::hi() const {
  // @@protoc_insertion_point(field_get:types.H256.hi)
  return _internal_hi();
}
inline void H256::unsafe_arena_set_allocated_hi(
    ::types::H128* hi) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hi_);
  }
  hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H256.hi)
}
inline ::types::H128* H256::release_hi() {
  
  ::types::H128* temp = hi_;
  hi_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H128* H256::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H256.hi)
  
  ::types::H128* temp = hi_;
  hi_ = nullptr;
  return temp;
}
inline ::types::H128* H256::_internal_mutable_hi() {
  
  if (hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H128>(GetArena());
    hi_ = p;
  }
  return hi_;
}
inline ::types::H128* H256::mutable_hi() {
  // @@protoc_insertion_point(field_mutable:types.H256.hi)
  return _internal_mutable_hi();
}
inline void H256::set_allocated_hi(::types::H128* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H256.hi)
}

// .types.H128 lo = 2;
inline bool H256::_internal_has_lo() const {
  return this != internal_default_instance() && lo_ != nullptr;
}
inline bool H256::has_lo() const {
  return _internal_has_lo();
}
inline void H256::clear_lo() {
  if (GetArena() == nullptr && lo_ != nullptr) {
    delete lo_;
  }
  lo_ = nullptr;
}
inline const ::types::H128& H256::_internal_lo() const {
  const ::types::H128* p = lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(
      ::types::_H128_default_instance_);
}
inline const ::types::H128& H256::lo() const {
  // @@protoc_insertion_point(field_get:types.H256.lo)
  return _internal_lo();
}
inline void H256::unsafe_arena_set_allocated_lo(
    ::types::H128* lo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lo_);
  }
  lo_ = lo;
  if (lo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H256.lo)
}
inline ::types::H128* H256::release_lo() {
  
  ::types::H128* temp = lo_;
  lo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H128* H256::unsafe_arena_release_lo() {
  // @@protoc_insertion_point(field_release:types.H256.lo)
  
  ::types::H128* temp = lo_;
  lo_ = nullptr;
  return temp;
}
inline ::types::H128* H256::_internal_mutable_lo() {
  
  if (lo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H128>(GetArena());
    lo_ = p;
  }
  return lo_;
}
inline ::types::H128* H256::mutable_lo() {
  // @@protoc_insertion_point(field_mutable:types.H256.lo)
  return _internal_mutable_lo();
}
inline void H256::set_allocated_lo(::types::H128* lo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lo_;
  }
  if (lo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lo);
    if (message_arena != submessage_arena) {
      lo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:types.H256.lo)
}

// -------------------------------------------------------------------

// H512

// .types.H256 hi = 1;
inline bool H512::_internal_has_hi() const {
  return this != internal_default_instance() && hi_ != nullptr;
}
inline bool H512::has_hi() const {
  return _internal_has_hi();
}
inline void H512::clear_hi() {
  if (GetArena() == nullptr && hi_ != nullptr) {
    delete hi_;
  }
  hi_ = nullptr;
}
inline const ::types::H256& H512::_internal_hi() const {
  const ::types::H256* p = hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& H512::hi() const {
  // @@protoc_insertion_point(field_get:types.H512.hi)
  return _internal_hi();
}
inline void H512::unsafe_arena_set_allocated_hi(
    ::types::H256* hi) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hi_);
  }
  hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H512.hi)
}
inline ::types::H256* H512::release_hi() {
  
  ::types::H256* temp = hi_;
  hi_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H256* H512::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H512.hi)
  
  ::types::H256* temp = hi_;
  hi_ = nullptr;
  return temp;
}
inline ::types::H256* H512::_internal_mutable_hi() {
  
  if (hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArena());
    hi_ = p;
  }
  return hi_;
}
inline ::types::H256* H512::mutable_hi() {
  // @@protoc_insertion_point(field_mutable:types.H512.hi)
  return _internal_mutable_hi();
}
inline void H512::set_allocated_hi(::types::H256* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H512.hi)
}

// .types.H256 lo = 2;
inline bool H512::_internal_has_lo() const {
  return this != internal_default_instance() && lo_ != nullptr;
}
inline bool H512::has_lo() const {
  return _internal_has_lo();
}
inline void H512::clear_lo() {
  if (GetArena() == nullptr && lo_ != nullptr) {
    delete lo_;
  }
  lo_ = nullptr;
}
inline const ::types::H256& H512::_internal_lo() const {
  const ::types::H256* p = lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& H512::lo() const {
  // @@protoc_insertion_point(field_get:types.H512.lo)
  return _internal_lo();
}
inline void H512::unsafe_arena_set_allocated_lo(
    ::types::H256* lo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lo_);
  }
  lo_ = lo;
  if (lo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H512.lo)
}
inline ::types::H256* H512::release_lo() {
  
  ::types::H256* temp = lo_;
  lo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H256* H512::unsafe_arena_release_lo() {
  // @@protoc_insertion_point(field_release:types.H512.lo)
  
  ::types::H256* temp = lo_;
  lo_ = nullptr;
  return temp;
}
inline ::types::H256* H512::_internal_mutable_lo() {
  
  if (lo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArena());
    lo_ = p;
  }
  return lo_;
}
inline ::types::H256* H512::mutable_lo() {
  // @@protoc_insertion_point(field_mutable:types.H512.lo)
  return _internal_mutable_lo();
}
inline void H512::set_allocated_lo(::types::H256* lo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lo_;
  }
  if (lo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lo);
    if (message_arena != submessage_arena) {
      lo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:types.H512.lo)
}

// -------------------------------------------------------------------

// H1024

// .types.H512 hi = 1;
inline bool H1024::_internal_has_hi() const {
  return this != internal_default_instance() && hi_ != nullptr;
}
inline bool H1024::has_hi() const {
  return _internal_has_hi();
}
inline void H1024::clear_hi() {
  if (GetArena() == nullptr && hi_ != nullptr) {
    delete hi_;
  }
  hi_ = nullptr;
}
inline const ::types::H512& H1024::_internal_hi() const {
  const ::types::H512* p = hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& H1024::hi() const {
  // @@protoc_insertion_point(field_get:types.H1024.hi)
  return _internal_hi();
}
inline void H1024::unsafe_arena_set_allocated_hi(
    ::types::H512* hi) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hi_);
  }
  hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H1024.hi)
}
inline ::types::H512* H1024::release_hi() {
  
  ::types::H512* temp = hi_;
  hi_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H512* H1024::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H1024.hi)
  
  ::types::H512* temp = hi_;
  hi_ = nullptr;
  return temp;
}
inline ::types::H512* H1024::_internal_mutable_hi() {
  
  if (hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArena());
    hi_ = p;
  }
  return hi_;
}
inline ::types::H512* H1024::mutable_hi() {
  // @@protoc_insertion_point(field_mutable:types.H1024.hi)
  return _internal_mutable_hi();
}
inline void H1024::set_allocated_hi(::types::H512* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H1024.hi)
}

// .types.H512 lo = 2;
inline bool H1024::_internal_has_lo() const {
  return this != internal_default_instance() && lo_ != nullptr;
}
inline bool H1024::has_lo() const {
  return _internal_has_lo();
}
inline void H1024::clear_lo() {
  if (GetArena() == nullptr && lo_ != nullptr) {
    delete lo_;
  }
  lo_ = nullptr;
}
inline const ::types::H512& H1024::_internal_lo() const {
  const ::types::H512* p = lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& H1024::lo() const {
  // @@protoc_insertion_point(field_get:types.H1024.lo)
  return _internal_lo();
}
inline void H1024::unsafe_arena_set_allocated_lo(
    ::types::H512* lo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lo_);
  }
  lo_ = lo;
  if (lo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H1024.lo)
}
inline ::types::H512* H1024::release_lo() {
  
  ::types::H512* temp = lo_;
  lo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H512* H1024::unsafe_arena_release_lo() {
  // @@protoc_insertion_point(field_release:types.H1024.lo)
  
  ::types::H512* temp = lo_;
  lo_ = nullptr;
  return temp;
}
inline ::types::H512* H1024::_internal_mutable_lo() {
  
  if (lo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArena());
    lo_ = p;
  }
  return lo_;
}
inline ::types::H512* H1024::mutable_lo() {
  // @@protoc_insertion_point(field_mutable:types.H1024.lo)
  return _internal_mutable_lo();
}
inline void H1024::set_allocated_lo(::types::H512* lo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lo_;
  }
  if (lo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lo);
    if (message_arena != submessage_arena) {
      lo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:types.H1024.lo)
}

// -------------------------------------------------------------------

// H2048

// .types.H1024 hi = 1;
inline bool H2048::_internal_has_hi() const {
  return this != internal_default_instance() && hi_ != nullptr;
}
inline bool H2048::has_hi() const {
  return _internal_has_hi();
}
inline void H2048::clear_hi() {
  if (GetArena() == nullptr && hi_ != nullptr) {
    delete hi_;
  }
  hi_ = nullptr;
}
inline const ::types::H1024& H2048::_internal_hi() const {
  const ::types::H1024* p = hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H1024&>(
      ::types::_H1024_default_instance_);
}
inline const ::types::H1024& H2048::hi() const {
  // @@protoc_insertion_point(field_get:types.H2048.hi)
  return _internal_hi();
}
inline void H2048::unsafe_arena_set_allocated_hi(
    ::types::H1024* hi) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hi_);
  }
  hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H2048.hi)
}
inline ::types::H1024* H2048::release_hi() {
  
  ::types::H1024* temp = hi_;
  hi_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H1024* H2048::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H2048.hi)
  
  ::types::H1024* temp = hi_;
  hi_ = nullptr;
  return temp;
}
inline ::types::H1024* H2048::_internal_mutable_hi() {
  
  if (hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H1024>(GetArena());
    hi_ = p;
  }
  return hi_;
}
inline ::types::H1024* H2048::mutable_hi() {
  // @@protoc_insertion_point(field_mutable:types.H2048.hi)
  return _internal_mutable_hi();
}
inline void H2048::set_allocated_hi(::types::H1024* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H2048.hi)
}

// .types.H1024 lo = 2;
inline bool H2048::_internal_has_lo() const {
  return this != internal_default_instance() && lo_ != nullptr;
}
inline bool H2048::has_lo() const {
  return _internal_has_lo();
}
inline void H2048::clear_lo() {
  if (GetArena() == nullptr && lo_ != nullptr) {
    delete lo_;
  }
  lo_ = nullptr;
}
inline const ::types::H1024& H2048::_internal_lo() const {
  const ::types::H1024* p = lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H1024&>(
      ::types::_H1024_default_instance_);
}
inline const ::types::H1024& H2048::lo() const {
  // @@protoc_insertion_point(field_get:types.H2048.lo)
  return _internal_lo();
}
inline void H2048::unsafe_arena_set_allocated_lo(
    ::types::H1024* lo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lo_);
  }
  lo_ = lo;
  if (lo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H2048.lo)
}
inline ::types::H1024* H2048::release_lo() {
  
  ::types::H1024* temp = lo_;
  lo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H1024* H2048::unsafe_arena_release_lo() {
  // @@protoc_insertion_point(field_release:types.H2048.lo)
  
  ::types::H1024* temp = lo_;
  lo_ = nullptr;
  return temp;
}
inline ::types::H1024* H2048::_internal_mutable_lo() {
  
  if (lo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H1024>(GetArena());
    lo_ = p;
  }
  return lo_;
}
inline ::types::H1024* H2048::mutable_lo() {
  // @@protoc_insertion_point(field_mutable:types.H2048.lo)
  return _internal_mutable_lo();
}
inline void H2048::set_allocated_lo(::types::H1024* lo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lo_;
  }
  if (lo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lo);
    if (message_arena != submessage_arena) {
      lo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:types.H2048.lo)
}

// -------------------------------------------------------------------

// VersionReply

// uint32 major = 1;
inline void VersionReply::clear_major() {
  major_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionReply::_internal_major() const {
  return major_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionReply::major() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.major)
  return _internal_major();
}
inline void VersionReply::_internal_set_major(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  major_ = value;
}
inline void VersionReply::set_major(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.major)
}

// uint32 minor = 2;
inline void VersionReply::clear_minor() {
  minor_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionReply::_internal_minor() const {
  return minor_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionReply::minor() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.minor)
  return _internal_minor();
}
inline void VersionReply::_internal_set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  minor_ = value;
}
inline void VersionReply::set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.minor)
}

// uint32 patch = 3;
inline void VersionReply::clear_patch() {
  patch_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionReply::_internal_patch() const {
  return patch_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionReply::patch() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.patch)
  return _internal_patch();
}
inline void VersionReply::_internal_set_patch(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  patch_ = value;
}
inline void VersionReply::set_patch(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.patch)
}

// -------------------------------------------------------------------

// NodeInfoPorts

// uint32 discovery = 1;
inline void NodeInfoPorts::clear_discovery() {
  discovery_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NodeInfoPorts::_internal_discovery() const {
  return discovery_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NodeInfoPorts::discovery() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoPorts.discovery)
  return _internal_discovery();
}
inline void NodeInfoPorts::_internal_set_discovery(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  discovery_ = value;
}
inline void NodeInfoPorts::set_discovery(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_discovery(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoPorts.discovery)
}

// uint32 listener = 2;
inline void NodeInfoPorts::clear_listener() {
  listener_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NodeInfoPorts::_internal_listener() const {
  return listener_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NodeInfoPorts::listener() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoPorts.listener)
  return _internal_listener();
}
inline void NodeInfoPorts::_internal_set_listener(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  listener_ = value;
}
inline void NodeInfoPorts::set_listener(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_listener(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoPorts.listener)
}

// -------------------------------------------------------------------

// NodeInfoReply

// string id = 1;
inline void NodeInfoReply::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::id() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.id)
  return _internal_id();
}
inline void NodeInfoReply::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.id)
}
inline std::string* NodeInfoReply::mutable_id() {
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.id)
  return _internal_mutable_id();
}
inline const std::string& NodeInfoReply::_internal_id() const {
  return id_.Get();
}
inline void NodeInfoReply::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeInfoReply::set_id(std::string&& value) {
  
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:types.NodeInfoReply.id)
}
inline void NodeInfoReply::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:types.NodeInfoReply.id)
}
inline void NodeInfoReply::set_id(const char* value,
    size_t size) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:types.NodeInfoReply.id)
}
inline std::string* NodeInfoReply::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeInfoReply::release_id() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfoReply::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.id)
}

// string name = 2;
inline void NodeInfoReply::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::name() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.name)
  return _internal_name();
}
inline void NodeInfoReply::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.name)
}
inline std::string* NodeInfoReply::mutable_name() {
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.name)
  return _internal_mutable_name();
}
inline const std::string& NodeInfoReply::_internal_name() const {
  return name_.Get();
}
inline void NodeInfoReply::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeInfoReply::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:types.NodeInfoReply.name)
}
inline void NodeInfoReply::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:types.NodeInfoReply.name)
}
inline void NodeInfoReply::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:types.NodeInfoReply.name)
}
inline std::string* NodeInfoReply::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeInfoReply::release_name() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfoReply::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.name)
}

// string enode = 3;
inline void NodeInfoReply::clear_enode() {
  enode_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::enode() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.enode)
  return _internal_enode();
}
inline void NodeInfoReply::set_enode(const std::string& value) {
  _internal_set_enode(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.enode)
}
inline std::string* NodeInfoReply::mutable_enode() {
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.enode)
  return _internal_mutable_enode();
}
inline const std::string& NodeInfoReply::_internal_enode() const {
  return enode_.Get();
}
inline void NodeInfoReply::_internal_set_enode(const std::string& value) {
  
  enode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeInfoReply::set_enode(std::string&& value) {
  
  enode_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:types.NodeInfoReply.enode)
}
inline void NodeInfoReply::set_enode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  enode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:types.NodeInfoReply.enode)
}
inline void NodeInfoReply::set_enode(const char* value,
    size_t size) {
  
  enode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:types.NodeInfoReply.enode)
}
inline std::string* NodeInfoReply::_internal_mutable_enode() {
  
  return enode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeInfoReply::release_enode() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.enode)
  return enode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfoReply::set_allocated_enode(std::string* enode) {
  if (enode != nullptr) {
    
  } else {
    
  }
  enode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enode,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.enode)
}

// string enr = 4;
inline void NodeInfoReply::clear_enr() {
  enr_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::enr() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.enr)
  return _internal_enr();
}
inline void NodeInfoReply::set_enr(const std::string& value) {
  _internal_set_enr(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.enr)
}
inline std::string* NodeInfoReply::mutable_enr() {
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.enr)
  return _internal_mutable_enr();
}
inline const std::string& NodeInfoReply::_internal_enr() const {
  return enr_.Get();
}
inline void NodeInfoReply::_internal_set_enr(const std::string& value) {
  
  enr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeInfoReply::set_enr(std::string&& value) {
  
  enr_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:types.NodeInfoReply.enr)
}
inline void NodeInfoReply::set_enr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  enr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:types.NodeInfoReply.enr)
}
inline void NodeInfoReply::set_enr(const char* value,
    size_t size) {
  
  enr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:types.NodeInfoReply.enr)
}
inline std::string* NodeInfoReply::_internal_mutable_enr() {
  
  return enr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeInfoReply::release_enr() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.enr)
  return enr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfoReply::set_allocated_enr(std::string* enr) {
  if (enr != nullptr) {
    
  } else {
    
  }
  enr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.enr)
}

// .types.NodeInfoPorts ports = 5;
inline bool NodeInfoReply::_internal_has_ports() const {
  return this != internal_default_instance() && ports_ != nullptr;
}
inline bool NodeInfoReply::has_ports() const {
  return _internal_has_ports();
}
inline void NodeInfoReply::clear_ports() {
  if (GetArena() == nullptr && ports_ != nullptr) {
    delete ports_;
  }
  ports_ = nullptr;
}
inline const ::types::NodeInfoPorts& NodeInfoReply::_internal_ports() const {
  const ::types::NodeInfoPorts* p = ports_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::NodeInfoPorts&>(
      ::types::_NodeInfoPorts_default_instance_);
}
inline const ::types::NodeInfoPorts& NodeInfoReply::ports() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.ports)
  return _internal_ports();
}
inline void NodeInfoReply::unsafe_arena_set_allocated_ports(
    ::types::NodeInfoPorts* ports) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ports_);
  }
  ports_ = ports;
  if (ports) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.NodeInfoReply.ports)
}
inline ::types::NodeInfoPorts* NodeInfoReply::release_ports() {
  
  ::types::NodeInfoPorts* temp = ports_;
  ports_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::NodeInfoPorts* NodeInfoReply::unsafe_arena_release_ports() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.ports)
  
  ::types::NodeInfoPorts* temp = ports_;
  ports_ = nullptr;
  return temp;
}
inline ::types::NodeInfoPorts* NodeInfoReply::_internal_mutable_ports() {
  
  if (ports_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::NodeInfoPorts>(GetArena());
    ports_ = p;
  }
  return ports_;
}
inline ::types::NodeInfoPorts* NodeInfoReply::mutable_ports() {
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.ports)
  return _internal_mutable_ports();
}
inline void NodeInfoReply::set_allocated_ports(::types::NodeInfoPorts* ports) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ports_;
  }
  if (ports) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ports);
    if (message_arena != submessage_arena) {
      ports = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ports, submessage_arena);
    }
    
  } else {
    
  }
  ports_ = ports;
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.ports)
}

// string listenerAddr = 6;
inline void NodeInfoReply::clear_listeneraddr() {
  listeneraddr_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::listeneraddr() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.listenerAddr)
  return _internal_listeneraddr();
}
inline void NodeInfoReply::set_listeneraddr(const std::string& value) {
  _internal_set_listeneraddr(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.listenerAddr)
}
inline std::string* NodeInfoReply::mutable_listeneraddr() {
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.listenerAddr)
  return _internal_mutable_listeneraddr();
}
inline const std::string& NodeInfoReply::_internal_listeneraddr() const {
  return listeneraddr_.Get();
}
inline void NodeInfoReply::_internal_set_listeneraddr(const std::string& value) {
  
  listeneraddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeInfoReply::set_listeneraddr(std::string&& value) {
  
  listeneraddr_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:types.NodeInfoReply.listenerAddr)
}
inline void NodeInfoReply::set_listeneraddr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  listeneraddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:types.NodeInfoReply.listenerAddr)
}
inline void NodeInfoReply::set_listeneraddr(const char* value,
    size_t size) {
  
  listeneraddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:types.NodeInfoReply.listenerAddr)
}
inline std::string* NodeInfoReply::_internal_mutable_listeneraddr() {
  
  return listeneraddr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeInfoReply::release_listeneraddr() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.listenerAddr)
  return listeneraddr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfoReply::set_allocated_listeneraddr(std::string* listeneraddr) {
  if (listeneraddr != nullptr) {
    
  } else {
    
  }
  listeneraddr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), listeneraddr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.listenerAddr)
}

// bytes protocols = 7;
inline void NodeInfoReply::clear_protocols() {
  protocols_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::protocols() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.protocols)
  return _internal_protocols();
}
inline void NodeInfoReply::set_protocols(const std::string& value) {
  _internal_set_protocols(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.protocols)
}
inline std::string* NodeInfoReply::mutable_protocols() {
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.protocols)
  return _internal_mutable_protocols();
}
inline const std::string& NodeInfoReply::_internal_protocols() const {
  return protocols_.Get();
}
inline void NodeInfoReply::_internal_set_protocols(const std::string& value) {
  
  protocols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeInfoReply::set_protocols(std::string&& value) {
  
  protocols_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:types.NodeInfoReply.protocols)
}
inline void NodeInfoReply::set_protocols(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  protocols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:types.NodeInfoReply.protocols)
}
inline void NodeInfoReply::set_protocols(const void* value,
    size_t size) {
  
  protocols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:types.NodeInfoReply.protocols)
}
inline std::string* NodeInfoReply::_internal_mutable_protocols() {
  
  return protocols_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeInfoReply::release_protocols() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.protocols)
  return protocols_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfoReply::set_allocated_protocols(std::string* protocols) {
  if (protocols != nullptr) {
    
  } else {
    
  }
  protocols_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocols,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.protocols)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto
