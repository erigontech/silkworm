// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: execution/execution.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_execution_2fexecution_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_execution_2fexecution_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_execution_2fexecution_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_execution_2fexecution_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_execution_2fexecution_2eproto;
namespace execution {
class BlockBody;
struct BlockBodyDefaultTypeInternal;
extern BlockBodyDefaultTypeInternal _BlockBody_default_instance_;
class EmptyMessage;
struct EmptyMessageDefaultTypeInternal;
extern EmptyMessageDefaultTypeInternal _EmptyMessage_default_instance_;
class ForkChoiceReceipt;
struct ForkChoiceReceiptDefaultTypeInternal;
extern ForkChoiceReceiptDefaultTypeInternal _ForkChoiceReceipt_default_instance_;
class GetBodyResponse;
struct GetBodyResponseDefaultTypeInternal;
extern GetBodyResponseDefaultTypeInternal _GetBodyResponse_default_instance_;
class GetHeaderHashNumberResponse;
struct GetHeaderHashNumberResponseDefaultTypeInternal;
extern GetHeaderHashNumberResponseDefaultTypeInternal _GetHeaderHashNumberResponse_default_instance_;
class GetHeaderResponse;
struct GetHeaderResponseDefaultTypeInternal;
extern GetHeaderResponseDefaultTypeInternal _GetHeaderResponse_default_instance_;
class GetSegmentRequest;
struct GetSegmentRequestDefaultTypeInternal;
extern GetSegmentRequestDefaultTypeInternal _GetSegmentRequest_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class InsertBodiesRequest;
struct InsertBodiesRequestDefaultTypeInternal;
extern InsertBodiesRequestDefaultTypeInternal _InsertBodiesRequest_default_instance_;
class InsertHeadersRequest;
struct InsertHeadersRequestDefaultTypeInternal;
extern InsertHeadersRequestDefaultTypeInternal _InsertHeadersRequest_default_instance_;
class IsCanonicalResponse;
struct IsCanonicalResponseDefaultTypeInternal;
extern IsCanonicalResponseDefaultTypeInternal _IsCanonicalResponse_default_instance_;
class ValidationReceipt;
struct ValidationReceiptDefaultTypeInternal;
extern ValidationReceiptDefaultTypeInternal _ValidationReceipt_default_instance_;
}  // namespace execution
PROTOBUF_NAMESPACE_OPEN
template<> ::execution::BlockBody* Arena::CreateMaybeMessage<::execution::BlockBody>(Arena*);
template<> ::execution::EmptyMessage* Arena::CreateMaybeMessage<::execution::EmptyMessage>(Arena*);
template<> ::execution::ForkChoiceReceipt* Arena::CreateMaybeMessage<::execution::ForkChoiceReceipt>(Arena*);
template<> ::execution::GetBodyResponse* Arena::CreateMaybeMessage<::execution::GetBodyResponse>(Arena*);
template<> ::execution::GetHeaderHashNumberResponse* Arena::CreateMaybeMessage<::execution::GetHeaderHashNumberResponse>(Arena*);
template<> ::execution::GetHeaderResponse* Arena::CreateMaybeMessage<::execution::GetHeaderResponse>(Arena*);
template<> ::execution::GetSegmentRequest* Arena::CreateMaybeMessage<::execution::GetSegmentRequest>(Arena*);
template<> ::execution::Header* Arena::CreateMaybeMessage<::execution::Header>(Arena*);
template<> ::execution::InsertBodiesRequest* Arena::CreateMaybeMessage<::execution::InsertBodiesRequest>(Arena*);
template<> ::execution::InsertHeadersRequest* Arena::CreateMaybeMessage<::execution::InsertHeadersRequest>(Arena*);
template<> ::execution::IsCanonicalResponse* Arena::CreateMaybeMessage<::execution::IsCanonicalResponse>(Arena*);
template<> ::execution::ValidationReceipt* Arena::CreateMaybeMessage<::execution::ValidationReceipt>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace execution {

enum ValidationStatus : int {
  Success = 0,
  InvalidChain = 1,
  TooFarAway = 2,
  MissingSegment = 3,
  ValidationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ValidationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ValidationStatus_IsValid(int value);
constexpr ValidationStatus ValidationStatus_MIN = Success;
constexpr ValidationStatus ValidationStatus_MAX = MissingSegment;
constexpr int ValidationStatus_ARRAYSIZE = ValidationStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValidationStatus_descriptor();
template<typename T>
inline const std::string& ValidationStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValidationStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValidationStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValidationStatus_descriptor(), enum_t_value);
}
inline bool ValidationStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValidationStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValidationStatus>(
    ValidationStatus_descriptor(), name, value);
}
// ===================================================================

class ForkChoiceReceipt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.ForkChoiceReceipt) */ {
 public:
  inline ForkChoiceReceipt() : ForkChoiceReceipt(nullptr) {}
  ~ForkChoiceReceipt() override;
  explicit PROTOBUF_CONSTEXPR ForkChoiceReceipt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForkChoiceReceipt(const ForkChoiceReceipt& from);
  ForkChoiceReceipt(ForkChoiceReceipt&& from) noexcept
    : ForkChoiceReceipt() {
    *this = ::std::move(from);
  }

  inline ForkChoiceReceipt& operator=(const ForkChoiceReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForkChoiceReceipt& operator=(ForkChoiceReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForkChoiceReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForkChoiceReceipt* internal_default_instance() {
    return reinterpret_cast<const ForkChoiceReceipt*>(
               &_ForkChoiceReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ForkChoiceReceipt& a, ForkChoiceReceipt& b) {
    a.Swap(&b);
  }
  inline void Swap(ForkChoiceReceipt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForkChoiceReceipt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForkChoiceReceipt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForkChoiceReceipt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForkChoiceReceipt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForkChoiceReceipt& from) {
    ForkChoiceReceipt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForkChoiceReceipt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.ForkChoiceReceipt";
  }
  protected:
  explicit ForkChoiceReceipt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestValidHashFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .types.H256 latest_valid_hash = 2;
  bool has_latest_valid_hash() const;
  private:
  bool _internal_has_latest_valid_hash() const;
  public:
  void clear_latest_valid_hash();
  const ::types::H256& latest_valid_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_latest_valid_hash();
  ::types::H256* mutable_latest_valid_hash();
  void set_allocated_latest_valid_hash(::types::H256* latest_valid_hash);
  private:
  const ::types::H256& _internal_latest_valid_hash() const;
  ::types::H256* _internal_mutable_latest_valid_hash();
  public:
  void unsafe_arena_set_allocated_latest_valid_hash(
      ::types::H256* latest_valid_hash);
  ::types::H256* unsafe_arena_release_latest_valid_hash();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:execution.ForkChoiceReceipt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H256* latest_valid_hash_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ValidationReceipt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.ValidationReceipt) */ {
 public:
  inline ValidationReceipt() : ValidationReceipt(nullptr) {}
  ~ValidationReceipt() override;
  explicit PROTOBUF_CONSTEXPR ValidationReceipt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidationReceipt(const ValidationReceipt& from);
  ValidationReceipt(ValidationReceipt&& from) noexcept
    : ValidationReceipt() {
    *this = ::std::move(from);
  }

  inline ValidationReceipt& operator=(const ValidationReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidationReceipt& operator=(ValidationReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidationReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidationReceipt* internal_default_instance() {
    return reinterpret_cast<const ValidationReceipt*>(
               &_ValidationReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ValidationReceipt& a, ValidationReceipt& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidationReceipt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidationReceipt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidationReceipt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidationReceipt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidationReceipt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidationReceipt& from) {
    ValidationReceipt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidationReceipt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.ValidationReceipt";
  }
  protected:
  explicit ValidationReceipt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestValidHashFieldNumber = 2,
    kMissingHashFieldNumber = 3,
    kValidationStatusFieldNumber = 1,
  };
  // .types.H256 latest_valid_hash = 2;
  bool has_latest_valid_hash() const;
  private:
  bool _internal_has_latest_valid_hash() const;
  public:
  void clear_latest_valid_hash();
  const ::types::H256& latest_valid_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_latest_valid_hash();
  ::types::H256* mutable_latest_valid_hash();
  void set_allocated_latest_valid_hash(::types::H256* latest_valid_hash);
  private:
  const ::types::H256& _internal_latest_valid_hash() const;
  ::types::H256* _internal_mutable_latest_valid_hash();
  public:
  void unsafe_arena_set_allocated_latest_valid_hash(
      ::types::H256* latest_valid_hash);
  ::types::H256* unsafe_arena_release_latest_valid_hash();

  // optional .types.H256 missing_hash = 3;
  bool has_missing_hash() const;
  private:
  bool _internal_has_missing_hash() const;
  public:
  void clear_missing_hash();
  const ::types::H256& missing_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_missing_hash();
  ::types::H256* mutable_missing_hash();
  void set_allocated_missing_hash(::types::H256* missing_hash);
  private:
  const ::types::H256& _internal_missing_hash() const;
  ::types::H256* _internal_mutable_missing_hash();
  public:
  void unsafe_arena_set_allocated_missing_hash(
      ::types::H256* missing_hash);
  ::types::H256* unsafe_arena_release_missing_hash();

  // .execution.ValidationStatus validation_status = 1;
  void clear_validation_status();
  ::execution::ValidationStatus validation_status() const;
  void set_validation_status(::execution::ValidationStatus value);
  private:
  ::execution::ValidationStatus _internal_validation_status() const;
  void _internal_set_validation_status(::execution::ValidationStatus value);
  public:

  // @@protoc_insertion_point(class_scope:execution.ValidationReceipt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::types::H256* latest_valid_hash_;
    ::types::H256* missing_hash_;
    int validation_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class IsCanonicalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.IsCanonicalResponse) */ {
 public:
  inline IsCanonicalResponse() : IsCanonicalResponse(nullptr) {}
  ~IsCanonicalResponse() override;
  explicit PROTOBUF_CONSTEXPR IsCanonicalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsCanonicalResponse(const IsCanonicalResponse& from);
  IsCanonicalResponse(IsCanonicalResponse&& from) noexcept
    : IsCanonicalResponse() {
    *this = ::std::move(from);
  }

  inline IsCanonicalResponse& operator=(const IsCanonicalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsCanonicalResponse& operator=(IsCanonicalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsCanonicalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsCanonicalResponse* internal_default_instance() {
    return reinterpret_cast<const IsCanonicalResponse*>(
               &_IsCanonicalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IsCanonicalResponse& a, IsCanonicalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IsCanonicalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsCanonicalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsCanonicalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsCanonicalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsCanonicalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsCanonicalResponse& from) {
    IsCanonicalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsCanonicalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.IsCanonicalResponse";
  }
  protected:
  explicit IsCanonicalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanonicalFieldNumber = 1,
  };
  // bool canonical = 1;
  void clear_canonical();
  bool canonical() const;
  void set_canonical(bool value);
  private:
  bool _internal_canonical() const;
  void _internal_set_canonical(bool value);
  public:

  // @@protoc_insertion_point(class_scope:execution.IsCanonicalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool canonical_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraDataFieldNumber = 12,
    kParentHashFieldNumber = 1,
    kCoinbaseFieldNumber = 2,
    kStateRootFieldNumber = 3,
    kReceiptRootFieldNumber = 4,
    kLogsBloomFieldNumber = 5,
    kPrevRandaoFieldNumber = 6,
    kDifficultyFieldNumber = 13,
    kBlockHashFieldNumber = 14,
    kOmmerHashFieldNumber = 15,
    kTransactionHashFieldNumber = 16,
    kBaseFeePerGasFieldNumber = 17,
    kWithdrawalHashFieldNumber = 18,
    kExcessDataGasFieldNumber = 19,
    kBlockNumberFieldNumber = 7,
    kGasLimitFieldNumber = 8,
    kGasUsedFieldNumber = 9,
    kTimestampFieldNumber = 10,
    kNonceFieldNumber = 11,
  };
  // bytes extra_data = 12;
  void clear_extra_data();
  const std::string& extra_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra_data();
  PROTOBUF_NODISCARD std::string* release_extra_data();
  void set_allocated_extra_data(std::string* extra_data);
  private:
  const std::string& _internal_extra_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_data(const std::string& value);
  std::string* _internal_mutable_extra_data();
  public:

  // .types.H256 parent_hash = 1;
  bool has_parent_hash() const;
  private:
  bool _internal_has_parent_hash() const;
  public:
  void clear_parent_hash();
  const ::types::H256& parent_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_parent_hash();
  ::types::H256* mutable_parent_hash();
  void set_allocated_parent_hash(::types::H256* parent_hash);
  private:
  const ::types::H256& _internal_parent_hash() const;
  ::types::H256* _internal_mutable_parent_hash();
  public:
  void unsafe_arena_set_allocated_parent_hash(
      ::types::H256* parent_hash);
  ::types::H256* unsafe_arena_release_parent_hash();

  // .types.H160 coinbase = 2;
  bool has_coinbase() const;
  private:
  bool _internal_has_coinbase() const;
  public:
  void clear_coinbase();
  const ::types::H160& coinbase() const;
  PROTOBUF_NODISCARD ::types::H160* release_coinbase();
  ::types::H160* mutable_coinbase();
  void set_allocated_coinbase(::types::H160* coinbase);
  private:
  const ::types::H160& _internal_coinbase() const;
  ::types::H160* _internal_mutable_coinbase();
  public:
  void unsafe_arena_set_allocated_coinbase(
      ::types::H160* coinbase);
  ::types::H160* unsafe_arena_release_coinbase();

  // .types.H256 state_root = 3;
  bool has_state_root() const;
  private:
  bool _internal_has_state_root() const;
  public:
  void clear_state_root();
  const ::types::H256& state_root() const;
  PROTOBUF_NODISCARD ::types::H256* release_state_root();
  ::types::H256* mutable_state_root();
  void set_allocated_state_root(::types::H256* state_root);
  private:
  const ::types::H256& _internal_state_root() const;
  ::types::H256* _internal_mutable_state_root();
  public:
  void unsafe_arena_set_allocated_state_root(
      ::types::H256* state_root);
  ::types::H256* unsafe_arena_release_state_root();

  // .types.H256 receipt_root = 4;
  bool has_receipt_root() const;
  private:
  bool _internal_has_receipt_root() const;
  public:
  void clear_receipt_root();
  const ::types::H256& receipt_root() const;
  PROTOBUF_NODISCARD ::types::H256* release_receipt_root();
  ::types::H256* mutable_receipt_root();
  void set_allocated_receipt_root(::types::H256* receipt_root);
  private:
  const ::types::H256& _internal_receipt_root() const;
  ::types::H256* _internal_mutable_receipt_root();
  public:
  void unsafe_arena_set_allocated_receipt_root(
      ::types::H256* receipt_root);
  ::types::H256* unsafe_arena_release_receipt_root();

  // .types.H2048 logs_bloom = 5;
  bool has_logs_bloom() const;
  private:
  bool _internal_has_logs_bloom() const;
  public:
  void clear_logs_bloom();
  const ::types::H2048& logs_bloom() const;
  PROTOBUF_NODISCARD ::types::H2048* release_logs_bloom();
  ::types::H2048* mutable_logs_bloom();
  void set_allocated_logs_bloom(::types::H2048* logs_bloom);
  private:
  const ::types::H2048& _internal_logs_bloom() const;
  ::types::H2048* _internal_mutable_logs_bloom();
  public:
  void unsafe_arena_set_allocated_logs_bloom(
      ::types::H2048* logs_bloom);
  ::types::H2048* unsafe_arena_release_logs_bloom();

  // .types.H256 prev_randao = 6;
  bool has_prev_randao() const;
  private:
  bool _internal_has_prev_randao() const;
  public:
  void clear_prev_randao();
  const ::types::H256& prev_randao() const;
  PROTOBUF_NODISCARD ::types::H256* release_prev_randao();
  ::types::H256* mutable_prev_randao();
  void set_allocated_prev_randao(::types::H256* prev_randao);
  private:
  const ::types::H256& _internal_prev_randao() const;
  ::types::H256* _internal_mutable_prev_randao();
  public:
  void unsafe_arena_set_allocated_prev_randao(
      ::types::H256* prev_randao);
  ::types::H256* unsafe_arena_release_prev_randao();

  // .types.H256 difficulty = 13;
  bool has_difficulty() const;
  private:
  bool _internal_has_difficulty() const;
  public:
  void clear_difficulty();
  const ::types::H256& difficulty() const;
  PROTOBUF_NODISCARD ::types::H256* release_difficulty();
  ::types::H256* mutable_difficulty();
  void set_allocated_difficulty(::types::H256* difficulty);
  private:
  const ::types::H256& _internal_difficulty() const;
  ::types::H256* _internal_mutable_difficulty();
  public:
  void unsafe_arena_set_allocated_difficulty(
      ::types::H256* difficulty);
  ::types::H256* unsafe_arena_release_difficulty();

  // .types.H256 block_hash = 14;
  bool has_block_hash() const;
  private:
  bool _internal_has_block_hash() const;
  public:
  void clear_block_hash();
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* block_hash);
  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();
  public:
  void unsafe_arena_set_allocated_block_hash(
      ::types::H256* block_hash);
  ::types::H256* unsafe_arena_release_block_hash();

  // .types.H256 ommer_hash = 15;
  bool has_ommer_hash() const;
  private:
  bool _internal_has_ommer_hash() const;
  public:
  void clear_ommer_hash();
  const ::types::H256& ommer_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_ommer_hash();
  ::types::H256* mutable_ommer_hash();
  void set_allocated_ommer_hash(::types::H256* ommer_hash);
  private:
  const ::types::H256& _internal_ommer_hash() const;
  ::types::H256* _internal_mutable_ommer_hash();
  public:
  void unsafe_arena_set_allocated_ommer_hash(
      ::types::H256* ommer_hash);
  ::types::H256* unsafe_arena_release_ommer_hash();

  // .types.H256 transaction_hash = 16;
  bool has_transaction_hash() const;
  private:
  bool _internal_has_transaction_hash() const;
  public:
  void clear_transaction_hash();
  const ::types::H256& transaction_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_transaction_hash();
  ::types::H256* mutable_transaction_hash();
  void set_allocated_transaction_hash(::types::H256* transaction_hash);
  private:
  const ::types::H256& _internal_transaction_hash() const;
  ::types::H256* _internal_mutable_transaction_hash();
  public:
  void unsafe_arena_set_allocated_transaction_hash(
      ::types::H256* transaction_hash);
  ::types::H256* unsafe_arena_release_transaction_hash();

  // optional .types.H256 base_fee_per_gas = 17;
  bool has_base_fee_per_gas() const;
  private:
  bool _internal_has_base_fee_per_gas() const;
  public:
  void clear_base_fee_per_gas();
  const ::types::H256& base_fee_per_gas() const;
  PROTOBUF_NODISCARD ::types::H256* release_base_fee_per_gas();
  ::types::H256* mutable_base_fee_per_gas();
  void set_allocated_base_fee_per_gas(::types::H256* base_fee_per_gas);
  private:
  const ::types::H256& _internal_base_fee_per_gas() const;
  ::types::H256* _internal_mutable_base_fee_per_gas();
  public:
  void unsafe_arena_set_allocated_base_fee_per_gas(
      ::types::H256* base_fee_per_gas);
  ::types::H256* unsafe_arena_release_base_fee_per_gas();

  // optional .types.H256 withdrawal_hash = 18;
  bool has_withdrawal_hash() const;
  private:
  bool _internal_has_withdrawal_hash() const;
  public:
  void clear_withdrawal_hash();
  const ::types::H256& withdrawal_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_withdrawal_hash();
  ::types::H256* mutable_withdrawal_hash();
  void set_allocated_withdrawal_hash(::types::H256* withdrawal_hash);
  private:
  const ::types::H256& _internal_withdrawal_hash() const;
  ::types::H256* _internal_mutable_withdrawal_hash();
  public:
  void unsafe_arena_set_allocated_withdrawal_hash(
      ::types::H256* withdrawal_hash);
  ::types::H256* unsafe_arena_release_withdrawal_hash();

  // optional .types.H256 excess_data_gas = 19;
  bool has_excess_data_gas() const;
  private:
  bool _internal_has_excess_data_gas() const;
  public:
  void clear_excess_data_gas();
  const ::types::H256& excess_data_gas() const;
  PROTOBUF_NODISCARD ::types::H256* release_excess_data_gas();
  ::types::H256* mutable_excess_data_gas();
  void set_allocated_excess_data_gas(::types::H256* excess_data_gas);
  private:
  const ::types::H256& _internal_excess_data_gas() const;
  ::types::H256* _internal_mutable_excess_data_gas();
  public:
  void unsafe_arena_set_allocated_excess_data_gas(
      ::types::H256* excess_data_gas);
  ::types::H256* unsafe_arena_release_excess_data_gas();

  // uint64 block_number = 7;
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // uint64 gas_limit = 8;
  void clear_gas_limit();
  uint64_t gas_limit() const;
  void set_gas_limit(uint64_t value);
  private:
  uint64_t _internal_gas_limit() const;
  void _internal_set_gas_limit(uint64_t value);
  public:

  // uint64 gas_used = 9;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint64 timestamp = 10;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint64 nonce = 11;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:execution.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_data_;
    ::types::H256* parent_hash_;
    ::types::H160* coinbase_;
    ::types::H256* state_root_;
    ::types::H256* receipt_root_;
    ::types::H2048* logs_bloom_;
    ::types::H256* prev_randao_;
    ::types::H256* difficulty_;
    ::types::H256* block_hash_;
    ::types::H256* ommer_hash_;
    ::types::H256* transaction_hash_;
    ::types::H256* base_fee_per_gas_;
    ::types::H256* withdrawal_hash_;
    ::types::H256* excess_data_gas_;
    uint64_t block_number_;
    uint64_t gas_limit_;
    uint64_t gas_used_;
    uint64_t timestamp_;
    uint64_t nonce_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class BlockBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.BlockBody) */ {
 public:
  inline BlockBody() : BlockBody(nullptr) {}
  ~BlockBody() override;
  explicit PROTOBUF_CONSTEXPR BlockBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBody(const BlockBody& from);
  BlockBody(BlockBody&& from) noexcept
    : BlockBody() {
    *this = ::std::move(from);
  }

  inline BlockBody& operator=(const BlockBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBody& operator=(BlockBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBody* internal_default_instance() {
    return reinterpret_cast<const BlockBody*>(
               &_BlockBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlockBody& a, BlockBody& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBody& from) {
    BlockBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.BlockBody";
  }
  protected:
  explicit BlockBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 3,
    kUnclesFieldNumber = 4,
    kWithdrawalsFieldNumber = 5,
    kBlockHashFieldNumber = 1,
    kBlockNumberFieldNumber = 2,
  };
  // repeated bytes transactions = 3;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  const std::string& transactions(int index) const;
  std::string* mutable_transactions(int index);
  void set_transactions(int index, const std::string& value);
  void set_transactions(int index, std::string&& value);
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, size_t size);
  std::string* add_transactions();
  void add_transactions(const std::string& value);
  void add_transactions(std::string&& value);
  void add_transactions(const char* value);
  void add_transactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transactions();
  private:
  const std::string& _internal_transactions(int index) const;
  std::string* _internal_add_transactions();
  public:

  // repeated .execution.Header uncles = 4;
  int uncles_size() const;
  private:
  int _internal_uncles_size() const;
  public:
  void clear_uncles();
  ::execution::Header* mutable_uncles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header >*
      mutable_uncles();
  private:
  const ::execution::Header& _internal_uncles(int index) const;
  ::execution::Header* _internal_add_uncles();
  public:
  const ::execution::Header& uncles(int index) const;
  ::execution::Header* add_uncles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header >&
      uncles() const;

  // repeated .types.Withdrawal withdrawals = 5;
  int withdrawals_size() const;
  private:
  int _internal_withdrawals_size() const;
  public:
  void clear_withdrawals();
  ::types::Withdrawal* mutable_withdrawals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >*
      mutable_withdrawals();
  private:
  const ::types::Withdrawal& _internal_withdrawals(int index) const;
  ::types::Withdrawal* _internal_add_withdrawals();
  public:
  const ::types::Withdrawal& withdrawals(int index) const;
  ::types::Withdrawal* add_withdrawals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >&
      withdrawals() const;

  // .types.H256 block_hash = 1;
  bool has_block_hash() const;
  private:
  bool _internal_has_block_hash() const;
  public:
  void clear_block_hash();
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* block_hash);
  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();
  public:
  void unsafe_arena_set_allocated_block_hash(
      ::types::H256* block_hash);
  ::types::H256* unsafe_arena_release_block_hash();

  // uint64 block_number = 2;
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:execution.BlockBody)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transactions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header > uncles_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal > withdrawals_;
    ::types::H256* block_hash_;
    uint64_t block_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetHeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.GetHeaderResponse) */ {
 public:
  inline GetHeaderResponse() : GetHeaderResponse(nullptr) {}
  ~GetHeaderResponse() override;
  explicit PROTOBUF_CONSTEXPR GetHeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHeaderResponse(const GetHeaderResponse& from);
  GetHeaderResponse(GetHeaderResponse&& from) noexcept
    : GetHeaderResponse() {
    *this = ::std::move(from);
  }

  inline GetHeaderResponse& operator=(const GetHeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHeaderResponse& operator=(GetHeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHeaderResponse* internal_default_instance() {
    return reinterpret_cast<const GetHeaderResponse*>(
               &_GetHeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetHeaderResponse& a, GetHeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHeaderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetHeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetHeaderResponse& from) {
    GetHeaderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHeaderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.GetHeaderResponse";
  }
  protected:
  explicit GetHeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // optional .execution.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::execution::Header& header() const;
  PROTOBUF_NODISCARD ::execution::Header* release_header();
  ::execution::Header* mutable_header();
  void set_allocated_header(::execution::Header* header);
  private:
  const ::execution::Header& _internal_header() const;
  ::execution::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::execution::Header* header);
  ::execution::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:execution.GetHeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::execution::Header* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetBodyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.GetBodyResponse) */ {
 public:
  inline GetBodyResponse() : GetBodyResponse(nullptr) {}
  ~GetBodyResponse() override;
  explicit PROTOBUF_CONSTEXPR GetBodyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBodyResponse(const GetBodyResponse& from);
  GetBodyResponse(GetBodyResponse&& from) noexcept
    : GetBodyResponse() {
    *this = ::std::move(from);
  }

  inline GetBodyResponse& operator=(const GetBodyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBodyResponse& operator=(GetBodyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBodyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBodyResponse* internal_default_instance() {
    return reinterpret_cast<const GetBodyResponse*>(
               &_GetBodyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetBodyResponse& a, GetBodyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBodyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBodyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBodyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBodyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBodyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBodyResponse& from) {
    GetBodyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBodyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.GetBodyResponse";
  }
  protected:
  explicit GetBodyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 1,
  };
  // optional .execution.BlockBody body = 1;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::execution::BlockBody& body() const;
  PROTOBUF_NODISCARD ::execution::BlockBody* release_body();
  ::execution::BlockBody* mutable_body();
  void set_allocated_body(::execution::BlockBody* body);
  private:
  const ::execution::BlockBody& _internal_body() const;
  ::execution::BlockBody* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::execution::BlockBody* body);
  ::execution::BlockBody* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:execution.GetBodyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::execution::BlockBody* body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetHeaderHashNumberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.GetHeaderHashNumberResponse) */ {
 public:
  inline GetHeaderHashNumberResponse() : GetHeaderHashNumberResponse(nullptr) {}
  ~GetHeaderHashNumberResponse() override;
  explicit PROTOBUF_CONSTEXPR GetHeaderHashNumberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHeaderHashNumberResponse(const GetHeaderHashNumberResponse& from);
  GetHeaderHashNumberResponse(GetHeaderHashNumberResponse&& from) noexcept
    : GetHeaderHashNumberResponse() {
    *this = ::std::move(from);
  }

  inline GetHeaderHashNumberResponse& operator=(const GetHeaderHashNumberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHeaderHashNumberResponse& operator=(GetHeaderHashNumberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHeaderHashNumberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHeaderHashNumberResponse* internal_default_instance() {
    return reinterpret_cast<const GetHeaderHashNumberResponse*>(
               &_GetHeaderHashNumberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetHeaderHashNumberResponse& a, GetHeaderHashNumberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHeaderHashNumberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHeaderHashNumberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHeaderHashNumberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetHeaderHashNumberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHeaderHashNumberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetHeaderHashNumberResponse& from) {
    GetHeaderHashNumberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHeaderHashNumberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.GetHeaderHashNumberResponse";
  }
  protected:
  explicit GetHeaderHashNumberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockNumberFieldNumber = 1,
  };
  // optional uint64 block_number = 1;
  bool has_block_number() const;
  private:
  bool _internal_has_block_number() const;
  public:
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:execution.GetHeaderHashNumberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t block_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetSegmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.GetSegmentRequest) */ {
 public:
  inline GetSegmentRequest() : GetSegmentRequest(nullptr) {}
  ~GetSegmentRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSegmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSegmentRequest(const GetSegmentRequest& from);
  GetSegmentRequest(GetSegmentRequest&& from) noexcept
    : GetSegmentRequest() {
    *this = ::std::move(from);
  }

  inline GetSegmentRequest& operator=(const GetSegmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSegmentRequest& operator=(GetSegmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSegmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSegmentRequest* internal_default_instance() {
    return reinterpret_cast<const GetSegmentRequest*>(
               &_GetSegmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetSegmentRequest& a, GetSegmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSegmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSegmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSegmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSegmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSegmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSegmentRequest& from) {
    GetSegmentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSegmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.GetSegmentRequest";
  }
  protected:
  explicit GetSegmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHashFieldNumber = 2,
    kBlockNumberFieldNumber = 1,
  };
  // optional .types.H256 block_hash = 2;
  bool has_block_hash() const;
  private:
  bool _internal_has_block_hash() const;
  public:
  void clear_block_hash();
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* block_hash);
  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();
  public:
  void unsafe_arena_set_allocated_block_hash(
      ::types::H256* block_hash);
  ::types::H256* unsafe_arena_release_block_hash();

  // optional uint64 block_number = 1;
  bool has_block_number() const;
  private:
  bool _internal_has_block_number() const;
  public:
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:execution.GetSegmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::types::H256* block_hash_;
    uint64_t block_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class InsertHeadersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.InsertHeadersRequest) */ {
 public:
  inline InsertHeadersRequest() : InsertHeadersRequest(nullptr) {}
  ~InsertHeadersRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertHeadersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertHeadersRequest(const InsertHeadersRequest& from);
  InsertHeadersRequest(InsertHeadersRequest&& from) noexcept
    : InsertHeadersRequest() {
    *this = ::std::move(from);
  }

  inline InsertHeadersRequest& operator=(const InsertHeadersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertHeadersRequest& operator=(InsertHeadersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertHeadersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertHeadersRequest* internal_default_instance() {
    return reinterpret_cast<const InsertHeadersRequest*>(
               &_InsertHeadersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InsertHeadersRequest& a, InsertHeadersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertHeadersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertHeadersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertHeadersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertHeadersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertHeadersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertHeadersRequest& from) {
    InsertHeadersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertHeadersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.InsertHeadersRequest";
  }
  protected:
  explicit InsertHeadersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 1,
  };
  // repeated .execution.Header headers = 1;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  ::execution::Header* mutable_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header >*
      mutable_headers();
  private:
  const ::execution::Header& _internal_headers(int index) const;
  ::execution::Header* _internal_add_headers();
  public:
  const ::execution::Header& headers(int index) const;
  ::execution::Header* add_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header >&
      headers() const;

  // @@protoc_insertion_point(class_scope:execution.InsertHeadersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header > headers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class InsertBodiesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:execution.InsertBodiesRequest) */ {
 public:
  inline InsertBodiesRequest() : InsertBodiesRequest(nullptr) {}
  ~InsertBodiesRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertBodiesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertBodiesRequest(const InsertBodiesRequest& from);
  InsertBodiesRequest(InsertBodiesRequest&& from) noexcept
    : InsertBodiesRequest() {
    *this = ::std::move(from);
  }

  inline InsertBodiesRequest& operator=(const InsertBodiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertBodiesRequest& operator=(InsertBodiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertBodiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertBodiesRequest* internal_default_instance() {
    return reinterpret_cast<const InsertBodiesRequest*>(
               &_InsertBodiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InsertBodiesRequest& a, InsertBodiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertBodiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertBodiesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertBodiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertBodiesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertBodiesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertBodiesRequest& from) {
    InsertBodiesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertBodiesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.InsertBodiesRequest";
  }
  protected:
  explicit InsertBodiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodiesFieldNumber = 1,
  };
  // repeated .execution.BlockBody bodies = 1;
  int bodies_size() const;
  private:
  int _internal_bodies_size() const;
  public:
  void clear_bodies();
  ::execution::BlockBody* mutable_bodies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::BlockBody >*
      mutable_bodies();
  private:
  const ::execution::BlockBody& _internal_bodies(int index) const;
  ::execution::BlockBody* _internal_add_bodies();
  public:
  const ::execution::BlockBody& bodies(int index) const;
  ::execution::BlockBody* add_bodies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::BlockBody >&
      bodies() const;

  // @@protoc_insertion_point(class_scope:execution.InsertBodiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::BlockBody > bodies_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class EmptyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:execution.EmptyMessage) */ {
 public:
  inline EmptyMessage() : EmptyMessage(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EmptyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyMessage(const EmptyMessage& from);
  EmptyMessage(EmptyMessage&& from) noexcept
    : EmptyMessage() {
    *this = ::std::move(from);
  }

  inline EmptyMessage& operator=(const EmptyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyMessage& operator=(EmptyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyMessage* internal_default_instance() {
    return reinterpret_cast<const EmptyMessage*>(
               &_EmptyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EmptyMessage& a, EmptyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "execution.EmptyMessage";
  }
  protected:
  explicit EmptyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:execution.EmptyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ForkChoiceReceipt

// bool success = 1;
inline void ForkChoiceReceipt::clear_success() {
  _impl_.success_ = false;
}
inline bool ForkChoiceReceipt::_internal_success() const {
  return _impl_.success_;
}
inline bool ForkChoiceReceipt::success() const {
  // @@protoc_insertion_point(field_get:execution.ForkChoiceReceipt.success)
  return _internal_success();
}
inline void ForkChoiceReceipt::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ForkChoiceReceipt::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:execution.ForkChoiceReceipt.success)
}

// .types.H256 latest_valid_hash = 2;
inline bool ForkChoiceReceipt::_internal_has_latest_valid_hash() const {
  return this != internal_default_instance() && _impl_.latest_valid_hash_ != nullptr;
}
inline bool ForkChoiceReceipt::has_latest_valid_hash() const {
  return _internal_has_latest_valid_hash();
}
inline const ::types::H256& ForkChoiceReceipt::_internal_latest_valid_hash() const {
  const ::types::H256* p = _impl_.latest_valid_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ForkChoiceReceipt::latest_valid_hash() const {
  // @@protoc_insertion_point(field_get:execution.ForkChoiceReceipt.latest_valid_hash)
  return _internal_latest_valid_hash();
}
inline void ForkChoiceReceipt::unsafe_arena_set_allocated_latest_valid_hash(
    ::types::H256* latest_valid_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_valid_hash_);
  }
  _impl_.latest_valid_hash_ = latest_valid_hash;
  if (latest_valid_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ForkChoiceReceipt.latest_valid_hash)
}
inline ::types::H256* ForkChoiceReceipt::release_latest_valid_hash() {
  
  ::types::H256* temp = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ForkChoiceReceipt::unsafe_arena_release_latest_valid_hash() {
  // @@protoc_insertion_point(field_release:execution.ForkChoiceReceipt.latest_valid_hash)
  
  ::types::H256* temp = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ForkChoiceReceipt::_internal_mutable_latest_valid_hash() {
  
  if (_impl_.latest_valid_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.latest_valid_hash_ = p;
  }
  return _impl_.latest_valid_hash_;
}
inline ::types::H256* ForkChoiceReceipt::mutable_latest_valid_hash() {
  ::types::H256* _msg = _internal_mutable_latest_valid_hash();
  // @@protoc_insertion_point(field_mutable:execution.ForkChoiceReceipt.latest_valid_hash)
  return _msg;
}
inline void ForkChoiceReceipt::set_allocated_latest_valid_hash(::types::H256* latest_valid_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_valid_hash_);
  }
  if (latest_valid_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latest_valid_hash));
    if (message_arena != submessage_arena) {
      latest_valid_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest_valid_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.latest_valid_hash_ = latest_valid_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.ForkChoiceReceipt.latest_valid_hash)
}

// -------------------------------------------------------------------

// ValidationReceipt

// .execution.ValidationStatus validation_status = 1;
inline void ValidationReceipt::clear_validation_status() {
  _impl_.validation_status_ = 0;
}
inline ::execution::ValidationStatus ValidationReceipt::_internal_validation_status() const {
  return static_cast< ::execution::ValidationStatus >(_impl_.validation_status_);
}
inline ::execution::ValidationStatus ValidationReceipt::validation_status() const {
  // @@protoc_insertion_point(field_get:execution.ValidationReceipt.validation_status)
  return _internal_validation_status();
}
inline void ValidationReceipt::_internal_set_validation_status(::execution::ValidationStatus value) {
  
  _impl_.validation_status_ = value;
}
inline void ValidationReceipt::set_validation_status(::execution::ValidationStatus value) {
  _internal_set_validation_status(value);
  // @@protoc_insertion_point(field_set:execution.ValidationReceipt.validation_status)
}

// .types.H256 latest_valid_hash = 2;
inline bool ValidationReceipt::_internal_has_latest_valid_hash() const {
  return this != internal_default_instance() && _impl_.latest_valid_hash_ != nullptr;
}
inline bool ValidationReceipt::has_latest_valid_hash() const {
  return _internal_has_latest_valid_hash();
}
inline const ::types::H256& ValidationReceipt::_internal_latest_valid_hash() const {
  const ::types::H256* p = _impl_.latest_valid_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ValidationReceipt::latest_valid_hash() const {
  // @@protoc_insertion_point(field_get:execution.ValidationReceipt.latest_valid_hash)
  return _internal_latest_valid_hash();
}
inline void ValidationReceipt::unsafe_arena_set_allocated_latest_valid_hash(
    ::types::H256* latest_valid_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_valid_hash_);
  }
  _impl_.latest_valid_hash_ = latest_valid_hash;
  if (latest_valid_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ValidationReceipt.latest_valid_hash)
}
inline ::types::H256* ValidationReceipt::release_latest_valid_hash() {
  
  ::types::H256* temp = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ValidationReceipt::unsafe_arena_release_latest_valid_hash() {
  // @@protoc_insertion_point(field_release:execution.ValidationReceipt.latest_valid_hash)
  
  ::types::H256* temp = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ValidationReceipt::_internal_mutable_latest_valid_hash() {
  
  if (_impl_.latest_valid_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.latest_valid_hash_ = p;
  }
  return _impl_.latest_valid_hash_;
}
inline ::types::H256* ValidationReceipt::mutable_latest_valid_hash() {
  ::types::H256* _msg = _internal_mutable_latest_valid_hash();
  // @@protoc_insertion_point(field_mutable:execution.ValidationReceipt.latest_valid_hash)
  return _msg;
}
inline void ValidationReceipt::set_allocated_latest_valid_hash(::types::H256* latest_valid_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_valid_hash_);
  }
  if (latest_valid_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latest_valid_hash));
    if (message_arena != submessage_arena) {
      latest_valid_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest_valid_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.latest_valid_hash_ = latest_valid_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.ValidationReceipt.latest_valid_hash)
}

// optional .types.H256 missing_hash = 3;
inline bool ValidationReceipt::_internal_has_missing_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.missing_hash_ != nullptr);
  return value;
}
inline bool ValidationReceipt::has_missing_hash() const {
  return _internal_has_missing_hash();
}
inline const ::types::H256& ValidationReceipt::_internal_missing_hash() const {
  const ::types::H256* p = _impl_.missing_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ValidationReceipt::missing_hash() const {
  // @@protoc_insertion_point(field_get:execution.ValidationReceipt.missing_hash)
  return _internal_missing_hash();
}
inline void ValidationReceipt::unsafe_arena_set_allocated_missing_hash(
    ::types::H256* missing_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.missing_hash_);
  }
  _impl_.missing_hash_ = missing_hash;
  if (missing_hash) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ValidationReceipt.missing_hash)
}
inline ::types::H256* ValidationReceipt::release_missing_hash() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.missing_hash_;
  _impl_.missing_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ValidationReceipt::unsafe_arena_release_missing_hash() {
  // @@protoc_insertion_point(field_release:execution.ValidationReceipt.missing_hash)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.missing_hash_;
  _impl_.missing_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ValidationReceipt::_internal_mutable_missing_hash() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.missing_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.missing_hash_ = p;
  }
  return _impl_.missing_hash_;
}
inline ::types::H256* ValidationReceipt::mutable_missing_hash() {
  ::types::H256* _msg = _internal_mutable_missing_hash();
  // @@protoc_insertion_point(field_mutable:execution.ValidationReceipt.missing_hash)
  return _msg;
}
inline void ValidationReceipt::set_allocated_missing_hash(::types::H256* missing_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.missing_hash_);
  }
  if (missing_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(missing_hash));
    if (message_arena != submessage_arena) {
      missing_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, missing_hash, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.missing_hash_ = missing_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.ValidationReceipt.missing_hash)
}

// -------------------------------------------------------------------

// IsCanonicalResponse

// bool canonical = 1;
inline void IsCanonicalResponse::clear_canonical() {
  _impl_.canonical_ = false;
}
inline bool IsCanonicalResponse::_internal_canonical() const {
  return _impl_.canonical_;
}
inline bool IsCanonicalResponse::canonical() const {
  // @@protoc_insertion_point(field_get:execution.IsCanonicalResponse.canonical)
  return _internal_canonical();
}
inline void IsCanonicalResponse::_internal_set_canonical(bool value) {
  
  _impl_.canonical_ = value;
}
inline void IsCanonicalResponse::set_canonical(bool value) {
  _internal_set_canonical(value);
  // @@protoc_insertion_point(field_set:execution.IsCanonicalResponse.canonical)
}

// -------------------------------------------------------------------

// Header

// .types.H256 parent_hash = 1;
inline bool Header::_internal_has_parent_hash() const {
  return this != internal_default_instance() && _impl_.parent_hash_ != nullptr;
}
inline bool Header::has_parent_hash() const {
  return _internal_has_parent_hash();
}
inline const ::types::H256& Header::_internal_parent_hash() const {
  const ::types::H256* p = _impl_.parent_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::parent_hash() const {
  // @@protoc_insertion_point(field_get:execution.Header.parent_hash)
  return _internal_parent_hash();
}
inline void Header::unsafe_arena_set_allocated_parent_hash(
    ::types::H256* parent_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_hash_);
  }
  _impl_.parent_hash_ = parent_hash;
  if (parent_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.parent_hash)
}
inline ::types::H256* Header::release_parent_hash() {
  
  ::types::H256* temp = _impl_.parent_hash_;
  _impl_.parent_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_parent_hash() {
  // @@protoc_insertion_point(field_release:execution.Header.parent_hash)
  
  ::types::H256* temp = _impl_.parent_hash_;
  _impl_.parent_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_parent_hash() {
  
  if (_impl_.parent_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.parent_hash_ = p;
  }
  return _impl_.parent_hash_;
}
inline ::types::H256* Header::mutable_parent_hash() {
  ::types::H256* _msg = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.parent_hash)
  return _msg;
}
inline void Header::set_allocated_parent_hash(::types::H256* parent_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_hash_);
  }
  if (parent_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_hash));
    if (message_arena != submessage_arena) {
      parent_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parent_hash_ = parent_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.parent_hash)
}

// .types.H160 coinbase = 2;
inline bool Header::_internal_has_coinbase() const {
  return this != internal_default_instance() && _impl_.coinbase_ != nullptr;
}
inline bool Header::has_coinbase() const {
  return _internal_has_coinbase();
}
inline const ::types::H160& Header::_internal_coinbase() const {
  const ::types::H160* p = _impl_.coinbase_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& Header::coinbase() const {
  // @@protoc_insertion_point(field_get:execution.Header.coinbase)
  return _internal_coinbase();
}
inline void Header::unsafe_arena_set_allocated_coinbase(
    ::types::H160* coinbase) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coinbase_);
  }
  _impl_.coinbase_ = coinbase;
  if (coinbase) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.coinbase)
}
inline ::types::H160* Header::release_coinbase() {
  
  ::types::H160* temp = _impl_.coinbase_;
  _impl_.coinbase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* Header::unsafe_arena_release_coinbase() {
  // @@protoc_insertion_point(field_release:execution.Header.coinbase)
  
  ::types::H160* temp = _impl_.coinbase_;
  _impl_.coinbase_ = nullptr;
  return temp;
}
inline ::types::H160* Header::_internal_mutable_coinbase() {
  
  if (_impl_.coinbase_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    _impl_.coinbase_ = p;
  }
  return _impl_.coinbase_;
}
inline ::types::H160* Header::mutable_coinbase() {
  ::types::H160* _msg = _internal_mutable_coinbase();
  // @@protoc_insertion_point(field_mutable:execution.Header.coinbase)
  return _msg;
}
inline void Header::set_allocated_coinbase(::types::H160* coinbase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coinbase_);
  }
  if (coinbase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coinbase));
    if (message_arena != submessage_arena) {
      coinbase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coinbase, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.coinbase_ = coinbase;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.coinbase)
}

// .types.H256 state_root = 3;
inline bool Header::_internal_has_state_root() const {
  return this != internal_default_instance() && _impl_.state_root_ != nullptr;
}
inline bool Header::has_state_root() const {
  return _internal_has_state_root();
}
inline const ::types::H256& Header::_internal_state_root() const {
  const ::types::H256* p = _impl_.state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::state_root() const {
  // @@protoc_insertion_point(field_get:execution.Header.state_root)
  return _internal_state_root();
}
inline void Header::unsafe_arena_set_allocated_state_root(
    ::types::H256* state_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_root_);
  }
  _impl_.state_root_ = state_root;
  if (state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.state_root)
}
inline ::types::H256* Header::release_state_root() {
  
  ::types::H256* temp = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_state_root() {
  // @@protoc_insertion_point(field_release:execution.Header.state_root)
  
  ::types::H256* temp = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_state_root() {
  
  if (_impl_.state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.state_root_ = p;
  }
  return _impl_.state_root_;
}
inline ::types::H256* Header::mutable_state_root() {
  ::types::H256* _msg = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:execution.Header.state_root)
  return _msg;
}
inline void Header::set_allocated_state_root(::types::H256* state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_root_);
  }
  if (state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_root));
    if (message_arena != submessage_arena) {
      state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_root_ = state_root;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.state_root)
}

// .types.H256 receipt_root = 4;
inline bool Header::_internal_has_receipt_root() const {
  return this != internal_default_instance() && _impl_.receipt_root_ != nullptr;
}
inline bool Header::has_receipt_root() const {
  return _internal_has_receipt_root();
}
inline const ::types::H256& Header::_internal_receipt_root() const {
  const ::types::H256* p = _impl_.receipt_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::receipt_root() const {
  // @@protoc_insertion_point(field_get:execution.Header.receipt_root)
  return _internal_receipt_root();
}
inline void Header::unsafe_arena_set_allocated_receipt_root(
    ::types::H256* receipt_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receipt_root_);
  }
  _impl_.receipt_root_ = receipt_root;
  if (receipt_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.receipt_root)
}
inline ::types::H256* Header::release_receipt_root() {
  
  ::types::H256* temp = _impl_.receipt_root_;
  _impl_.receipt_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_receipt_root() {
  // @@protoc_insertion_point(field_release:execution.Header.receipt_root)
  
  ::types::H256* temp = _impl_.receipt_root_;
  _impl_.receipt_root_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_receipt_root() {
  
  if (_impl_.receipt_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.receipt_root_ = p;
  }
  return _impl_.receipt_root_;
}
inline ::types::H256* Header::mutable_receipt_root() {
  ::types::H256* _msg = _internal_mutable_receipt_root();
  // @@protoc_insertion_point(field_mutable:execution.Header.receipt_root)
  return _msg;
}
inline void Header::set_allocated_receipt_root(::types::H256* receipt_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receipt_root_);
  }
  if (receipt_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(receipt_root));
    if (message_arena != submessage_arena) {
      receipt_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receipt_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.receipt_root_ = receipt_root;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.receipt_root)
}

// .types.H2048 logs_bloom = 5;
inline bool Header::_internal_has_logs_bloom() const {
  return this != internal_default_instance() && _impl_.logs_bloom_ != nullptr;
}
inline bool Header::has_logs_bloom() const {
  return _internal_has_logs_bloom();
}
inline const ::types::H2048& Header::_internal_logs_bloom() const {
  const ::types::H2048* p = _impl_.logs_bloom_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H2048&>(
      ::types::_H2048_default_instance_);
}
inline const ::types::H2048& Header::logs_bloom() const {
  // @@protoc_insertion_point(field_get:execution.Header.logs_bloom)
  return _internal_logs_bloom();
}
inline void Header::unsafe_arena_set_allocated_logs_bloom(
    ::types::H2048* logs_bloom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logs_bloom_);
  }
  _impl_.logs_bloom_ = logs_bloom;
  if (logs_bloom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.logs_bloom)
}
inline ::types::H2048* Header::release_logs_bloom() {
  
  ::types::H2048* temp = _impl_.logs_bloom_;
  _impl_.logs_bloom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H2048* Header::unsafe_arena_release_logs_bloom() {
  // @@protoc_insertion_point(field_release:execution.Header.logs_bloom)
  
  ::types::H2048* temp = _impl_.logs_bloom_;
  _impl_.logs_bloom_ = nullptr;
  return temp;
}
inline ::types::H2048* Header::_internal_mutable_logs_bloom() {
  
  if (_impl_.logs_bloom_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H2048>(GetArenaForAllocation());
    _impl_.logs_bloom_ = p;
  }
  return _impl_.logs_bloom_;
}
inline ::types::H2048* Header::mutable_logs_bloom() {
  ::types::H2048* _msg = _internal_mutable_logs_bloom();
  // @@protoc_insertion_point(field_mutable:execution.Header.logs_bloom)
  return _msg;
}
inline void Header::set_allocated_logs_bloom(::types::H2048* logs_bloom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logs_bloom_);
  }
  if (logs_bloom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logs_bloom));
    if (message_arena != submessage_arena) {
      logs_bloom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logs_bloom, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.logs_bloom_ = logs_bloom;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.logs_bloom)
}

// .types.H256 prev_randao = 6;
inline bool Header::_internal_has_prev_randao() const {
  return this != internal_default_instance() && _impl_.prev_randao_ != nullptr;
}
inline bool Header::has_prev_randao() const {
  return _internal_has_prev_randao();
}
inline const ::types::H256& Header::_internal_prev_randao() const {
  const ::types::H256* p = _impl_.prev_randao_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::prev_randao() const {
  // @@protoc_insertion_point(field_get:execution.Header.prev_randao)
  return _internal_prev_randao();
}
inline void Header::unsafe_arena_set_allocated_prev_randao(
    ::types::H256* prev_randao) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_randao_);
  }
  _impl_.prev_randao_ = prev_randao;
  if (prev_randao) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.prev_randao)
}
inline ::types::H256* Header::release_prev_randao() {
  
  ::types::H256* temp = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_prev_randao() {
  // @@protoc_insertion_point(field_release:execution.Header.prev_randao)
  
  ::types::H256* temp = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_prev_randao() {
  
  if (_impl_.prev_randao_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.prev_randao_ = p;
  }
  return _impl_.prev_randao_;
}
inline ::types::H256* Header::mutable_prev_randao() {
  ::types::H256* _msg = _internal_mutable_prev_randao();
  // @@protoc_insertion_point(field_mutable:execution.Header.prev_randao)
  return _msg;
}
inline void Header::set_allocated_prev_randao(::types::H256* prev_randao) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_randao_);
  }
  if (prev_randao) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_randao));
    if (message_arena != submessage_arena) {
      prev_randao = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_randao, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prev_randao_ = prev_randao;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.prev_randao)
}

// uint64 block_number = 7;
inline void Header::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
}
inline uint64_t Header::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t Header::block_number() const {
  // @@protoc_insertion_point(field_get:execution.Header.block_number)
  return _internal_block_number();
}
inline void Header::_internal_set_block_number(uint64_t value) {
  
  _impl_.block_number_ = value;
}
inline void Header::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:execution.Header.block_number)
}

// uint64 gas_limit = 8;
inline void Header::clear_gas_limit() {
  _impl_.gas_limit_ = uint64_t{0u};
}
inline uint64_t Header::_internal_gas_limit() const {
  return _impl_.gas_limit_;
}
inline uint64_t Header::gas_limit() const {
  // @@protoc_insertion_point(field_get:execution.Header.gas_limit)
  return _internal_gas_limit();
}
inline void Header::_internal_set_gas_limit(uint64_t value) {
  
  _impl_.gas_limit_ = value;
}
inline void Header::set_gas_limit(uint64_t value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:execution.Header.gas_limit)
}

// uint64 gas_used = 9;
inline void Header::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t Header::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t Header::gas_used() const {
  // @@protoc_insertion_point(field_get:execution.Header.gas_used)
  return _internal_gas_used();
}
inline void Header::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void Header::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:execution.Header.gas_used)
}

// uint64 timestamp = 10;
inline void Header::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t Header::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t Header::timestamp() const {
  // @@protoc_insertion_point(field_get:execution.Header.timestamp)
  return _internal_timestamp();
}
inline void Header::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Header::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:execution.Header.timestamp)
}

// uint64 nonce = 11;
inline void Header::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t Header::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t Header::nonce() const {
  // @@protoc_insertion_point(field_get:execution.Header.nonce)
  return _internal_nonce();
}
inline void Header::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void Header::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:execution.Header.nonce)
}

// bytes extra_data = 12;
inline void Header::clear_extra_data() {
  _impl_.extra_data_.ClearToEmpty();
}
inline const std::string& Header::extra_data() const {
  // @@protoc_insertion_point(field_get:execution.Header.extra_data)
  return _internal_extra_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_extra_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extra_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:execution.Header.extra_data)
}
inline std::string* Header::mutable_extra_data() {
  std::string* _s = _internal_mutable_extra_data();
  // @@protoc_insertion_point(field_mutable:execution.Header.extra_data)
  return _s;
}
inline const std::string& Header::_internal_extra_data() const {
  return _impl_.extra_data_.Get();
}
inline void Header::_internal_set_extra_data(const std::string& value) {
  
  _impl_.extra_data_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_extra_data() {
  
  return _impl_.extra_data_.Mutable(GetArenaForAllocation());
}
inline std::string* Header::release_extra_data() {
  // @@protoc_insertion_point(field_release:execution.Header.extra_data)
  return _impl_.extra_data_.Release();
}
inline void Header::set_allocated_extra_data(std::string* extra_data) {
  if (extra_data != nullptr) {
    
  } else {
    
  }
  _impl_.extra_data_.SetAllocated(extra_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_data_.IsDefault()) {
    _impl_.extra_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:execution.Header.extra_data)
}

// .types.H256 difficulty = 13;
inline bool Header::_internal_has_difficulty() const {
  return this != internal_default_instance() && _impl_.difficulty_ != nullptr;
}
inline bool Header::has_difficulty() const {
  return _internal_has_difficulty();
}
inline const ::types::H256& Header::_internal_difficulty() const {
  const ::types::H256* p = _impl_.difficulty_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::difficulty() const {
  // @@protoc_insertion_point(field_get:execution.Header.difficulty)
  return _internal_difficulty();
}
inline void Header::unsafe_arena_set_allocated_difficulty(
    ::types::H256* difficulty) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.difficulty_);
  }
  _impl_.difficulty_ = difficulty;
  if (difficulty) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.difficulty)
}
inline ::types::H256* Header::release_difficulty() {
  
  ::types::H256* temp = _impl_.difficulty_;
  _impl_.difficulty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_difficulty() {
  // @@protoc_insertion_point(field_release:execution.Header.difficulty)
  
  ::types::H256* temp = _impl_.difficulty_;
  _impl_.difficulty_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_difficulty() {
  
  if (_impl_.difficulty_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.difficulty_ = p;
  }
  return _impl_.difficulty_;
}
inline ::types::H256* Header::mutable_difficulty() {
  ::types::H256* _msg = _internal_mutable_difficulty();
  // @@protoc_insertion_point(field_mutable:execution.Header.difficulty)
  return _msg;
}
inline void Header::set_allocated_difficulty(::types::H256* difficulty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.difficulty_);
  }
  if (difficulty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(difficulty));
    if (message_arena != submessage_arena) {
      difficulty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, difficulty, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.difficulty_ = difficulty;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.difficulty)
}

// .types.H256 block_hash = 14;
inline bool Header::_internal_has_block_hash() const {
  return this != internal_default_instance() && _impl_.block_hash_ != nullptr;
}
inline bool Header::has_block_hash() const {
  return _internal_has_block_hash();
}
inline const ::types::H256& Header::_internal_block_hash() const {
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::block_hash() const {
  // @@protoc_insertion_point(field_get:execution.Header.block_hash)
  return _internal_block_hash();
}
inline void Header::unsafe_arena_set_allocated_block_hash(
    ::types::H256* block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = block_hash;
  if (block_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.block_hash)
}
inline ::types::H256* Header::release_block_hash() {
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_block_hash() {
  // @@protoc_insertion_point(field_release:execution.Header.block_hash)
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_block_hash() {
  
  if (_impl_.block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.block_hash_ = p;
  }
  return _impl_.block_hash_;
}
inline ::types::H256* Header::mutable_block_hash() {
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.block_hash)
  return _msg;
}
inline void Header::set_allocated_block_hash(::types::H256* block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  if (block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_hash));
    if (message_arena != submessage_arena) {
      block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_hash_ = block_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.block_hash)
}

// .types.H256 ommer_hash = 15;
inline bool Header::_internal_has_ommer_hash() const {
  return this != internal_default_instance() && _impl_.ommer_hash_ != nullptr;
}
inline bool Header::has_ommer_hash() const {
  return _internal_has_ommer_hash();
}
inline const ::types::H256& Header::_internal_ommer_hash() const {
  const ::types::H256* p = _impl_.ommer_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::ommer_hash() const {
  // @@protoc_insertion_point(field_get:execution.Header.ommer_hash)
  return _internal_ommer_hash();
}
inline void Header::unsafe_arena_set_allocated_ommer_hash(
    ::types::H256* ommer_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ommer_hash_);
  }
  _impl_.ommer_hash_ = ommer_hash;
  if (ommer_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.ommer_hash)
}
inline ::types::H256* Header::release_ommer_hash() {
  
  ::types::H256* temp = _impl_.ommer_hash_;
  _impl_.ommer_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_ommer_hash() {
  // @@protoc_insertion_point(field_release:execution.Header.ommer_hash)
  
  ::types::H256* temp = _impl_.ommer_hash_;
  _impl_.ommer_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_ommer_hash() {
  
  if (_impl_.ommer_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.ommer_hash_ = p;
  }
  return _impl_.ommer_hash_;
}
inline ::types::H256* Header::mutable_ommer_hash() {
  ::types::H256* _msg = _internal_mutable_ommer_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.ommer_hash)
  return _msg;
}
inline void Header::set_allocated_ommer_hash(::types::H256* ommer_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ommer_hash_);
  }
  if (ommer_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ommer_hash));
    if (message_arena != submessage_arena) {
      ommer_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ommer_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ommer_hash_ = ommer_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.ommer_hash)
}

// .types.H256 transaction_hash = 16;
inline bool Header::_internal_has_transaction_hash() const {
  return this != internal_default_instance() && _impl_.transaction_hash_ != nullptr;
}
inline bool Header::has_transaction_hash() const {
  return _internal_has_transaction_hash();
}
inline const ::types::H256& Header::_internal_transaction_hash() const {
  const ::types::H256* p = _impl_.transaction_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::transaction_hash() const {
  // @@protoc_insertion_point(field_get:execution.Header.transaction_hash)
  return _internal_transaction_hash();
}
inline void Header::unsafe_arena_set_allocated_transaction_hash(
    ::types::H256* transaction_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_hash_);
  }
  _impl_.transaction_hash_ = transaction_hash;
  if (transaction_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.transaction_hash)
}
inline ::types::H256* Header::release_transaction_hash() {
  
  ::types::H256* temp = _impl_.transaction_hash_;
  _impl_.transaction_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_transaction_hash() {
  // @@protoc_insertion_point(field_release:execution.Header.transaction_hash)
  
  ::types::H256* temp = _impl_.transaction_hash_;
  _impl_.transaction_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_transaction_hash() {
  
  if (_impl_.transaction_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.transaction_hash_ = p;
  }
  return _impl_.transaction_hash_;
}
inline ::types::H256* Header::mutable_transaction_hash() {
  ::types::H256* _msg = _internal_mutable_transaction_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.transaction_hash)
  return _msg;
}
inline void Header::set_allocated_transaction_hash(::types::H256* transaction_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_hash_);
  }
  if (transaction_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_hash));
    if (message_arena != submessage_arena) {
      transaction_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_hash_ = transaction_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.transaction_hash)
}

// optional .types.H256 base_fee_per_gas = 17;
inline bool Header::_internal_has_base_fee_per_gas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_fee_per_gas_ != nullptr);
  return value;
}
inline bool Header::has_base_fee_per_gas() const {
  return _internal_has_base_fee_per_gas();
}
inline const ::types::H256& Header::_internal_base_fee_per_gas() const {
  const ::types::H256* p = _impl_.base_fee_per_gas_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::base_fee_per_gas() const {
  // @@protoc_insertion_point(field_get:execution.Header.base_fee_per_gas)
  return _internal_base_fee_per_gas();
}
inline void Header::unsafe_arena_set_allocated_base_fee_per_gas(
    ::types::H256* base_fee_per_gas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_fee_per_gas_);
  }
  _impl_.base_fee_per_gas_ = base_fee_per_gas;
  if (base_fee_per_gas) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.base_fee_per_gas)
}
inline ::types::H256* Header::release_base_fee_per_gas() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.base_fee_per_gas_;
  _impl_.base_fee_per_gas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_base_fee_per_gas() {
  // @@protoc_insertion_point(field_release:execution.Header.base_fee_per_gas)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.base_fee_per_gas_;
  _impl_.base_fee_per_gas_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_base_fee_per_gas() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.base_fee_per_gas_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.base_fee_per_gas_ = p;
  }
  return _impl_.base_fee_per_gas_;
}
inline ::types::H256* Header::mutable_base_fee_per_gas() {
  ::types::H256* _msg = _internal_mutable_base_fee_per_gas();
  // @@protoc_insertion_point(field_mutable:execution.Header.base_fee_per_gas)
  return _msg;
}
inline void Header::set_allocated_base_fee_per_gas(::types::H256* base_fee_per_gas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_fee_per_gas_);
  }
  if (base_fee_per_gas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_fee_per_gas));
    if (message_arena != submessage_arena) {
      base_fee_per_gas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_fee_per_gas, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.base_fee_per_gas_ = base_fee_per_gas;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.base_fee_per_gas)
}

// optional .types.H256 withdrawal_hash = 18;
inline bool Header::_internal_has_withdrawal_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.withdrawal_hash_ != nullptr);
  return value;
}
inline bool Header::has_withdrawal_hash() const {
  return _internal_has_withdrawal_hash();
}
inline const ::types::H256& Header::_internal_withdrawal_hash() const {
  const ::types::H256* p = _impl_.withdrawal_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::withdrawal_hash() const {
  // @@protoc_insertion_point(field_get:execution.Header.withdrawal_hash)
  return _internal_withdrawal_hash();
}
inline void Header::unsafe_arena_set_allocated_withdrawal_hash(
    ::types::H256* withdrawal_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.withdrawal_hash_);
  }
  _impl_.withdrawal_hash_ = withdrawal_hash;
  if (withdrawal_hash) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.withdrawal_hash)
}
inline ::types::H256* Header::release_withdrawal_hash() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* temp = _impl_.withdrawal_hash_;
  _impl_.withdrawal_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_withdrawal_hash() {
  // @@protoc_insertion_point(field_release:execution.Header.withdrawal_hash)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* temp = _impl_.withdrawal_hash_;
  _impl_.withdrawal_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_withdrawal_hash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.withdrawal_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.withdrawal_hash_ = p;
  }
  return _impl_.withdrawal_hash_;
}
inline ::types::H256* Header::mutable_withdrawal_hash() {
  ::types::H256* _msg = _internal_mutable_withdrawal_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.withdrawal_hash)
  return _msg;
}
inline void Header::set_allocated_withdrawal_hash(::types::H256* withdrawal_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.withdrawal_hash_);
  }
  if (withdrawal_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(withdrawal_hash));
    if (message_arena != submessage_arena) {
      withdrawal_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, withdrawal_hash, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.withdrawal_hash_ = withdrawal_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.withdrawal_hash)
}

// optional .types.H256 excess_data_gas = 19;
inline bool Header::_internal_has_excess_data_gas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.excess_data_gas_ != nullptr);
  return value;
}
inline bool Header::has_excess_data_gas() const {
  return _internal_has_excess_data_gas();
}
inline const ::types::H256& Header::_internal_excess_data_gas() const {
  const ::types::H256* p = _impl_.excess_data_gas_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Header::excess_data_gas() const {
  // @@protoc_insertion_point(field_get:execution.Header.excess_data_gas)
  return _internal_excess_data_gas();
}
inline void Header::unsafe_arena_set_allocated_excess_data_gas(
    ::types::H256* excess_data_gas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.excess_data_gas_);
  }
  _impl_.excess_data_gas_ = excess_data_gas;
  if (excess_data_gas) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.excess_data_gas)
}
inline ::types::H256* Header::release_excess_data_gas() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H256* temp = _impl_.excess_data_gas_;
  _impl_.excess_data_gas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Header::unsafe_arena_release_excess_data_gas() {
  // @@protoc_insertion_point(field_release:execution.Header.excess_data_gas)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H256* temp = _impl_.excess_data_gas_;
  _impl_.excess_data_gas_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_excess_data_gas() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.excess_data_gas_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.excess_data_gas_ = p;
  }
  return _impl_.excess_data_gas_;
}
inline ::types::H256* Header::mutable_excess_data_gas() {
  ::types::H256* _msg = _internal_mutable_excess_data_gas();
  // @@protoc_insertion_point(field_mutable:execution.Header.excess_data_gas)
  return _msg;
}
inline void Header::set_allocated_excess_data_gas(::types::H256* excess_data_gas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.excess_data_gas_);
  }
  if (excess_data_gas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(excess_data_gas));
    if (message_arena != submessage_arena) {
      excess_data_gas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, excess_data_gas, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.excess_data_gas_ = excess_data_gas;
  // @@protoc_insertion_point(field_set_allocated:execution.Header.excess_data_gas)
}

// -------------------------------------------------------------------

// BlockBody

// .types.H256 block_hash = 1;
inline bool BlockBody::_internal_has_block_hash() const {
  return this != internal_default_instance() && _impl_.block_hash_ != nullptr;
}
inline bool BlockBody::has_block_hash() const {
  return _internal_has_block_hash();
}
inline const ::types::H256& BlockBody::_internal_block_hash() const {
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& BlockBody::block_hash() const {
  // @@protoc_insertion_point(field_get:execution.BlockBody.block_hash)
  return _internal_block_hash();
}
inline void BlockBody::unsafe_arena_set_allocated_block_hash(
    ::types::H256* block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = block_hash;
  if (block_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.BlockBody.block_hash)
}
inline ::types::H256* BlockBody::release_block_hash() {
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* BlockBody::unsafe_arena_release_block_hash() {
  // @@protoc_insertion_point(field_release:execution.BlockBody.block_hash)
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* BlockBody::_internal_mutable_block_hash() {
  
  if (_impl_.block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.block_hash_ = p;
  }
  return _impl_.block_hash_;
}
inline ::types::H256* BlockBody::mutable_block_hash() {
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.BlockBody.block_hash)
  return _msg;
}
inline void BlockBody::set_allocated_block_hash(::types::H256* block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  if (block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_hash));
    if (message_arena != submessage_arena) {
      block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_hash_ = block_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.BlockBody.block_hash)
}

// uint64 block_number = 2;
inline void BlockBody::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
}
inline uint64_t BlockBody::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t BlockBody::block_number() const {
  // @@protoc_insertion_point(field_get:execution.BlockBody.block_number)
  return _internal_block_number();
}
inline void BlockBody::_internal_set_block_number(uint64_t value) {
  
  _impl_.block_number_ = value;
}
inline void BlockBody::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:execution.BlockBody.block_number)
}

// repeated bytes transactions = 3;
inline int BlockBody::_internal_transactions_size() const {
  return _impl_.transactions_.size();
}
inline int BlockBody::transactions_size() const {
  return _internal_transactions_size();
}
inline void BlockBody::clear_transactions() {
  _impl_.transactions_.Clear();
}
inline std::string* BlockBody::add_transactions() {
  std::string* _s = _internal_add_transactions();
  // @@protoc_insertion_point(field_add_mutable:execution.BlockBody.transactions)
  return _s;
}
inline const std::string& BlockBody::_internal_transactions(int index) const {
  return _impl_.transactions_.Get(index);
}
inline const std::string& BlockBody::transactions(int index) const {
  // @@protoc_insertion_point(field_get:execution.BlockBody.transactions)
  return _internal_transactions(index);
}
inline std::string* BlockBody::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:execution.BlockBody.transactions)
  return _impl_.transactions_.Mutable(index);
}
inline void BlockBody::set_transactions(int index, const std::string& value) {
  _impl_.transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:execution.BlockBody.transactions)
}
inline void BlockBody::set_transactions(int index, std::string&& value) {
  _impl_.transactions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:execution.BlockBody.transactions)
}
inline void BlockBody::set_transactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:execution.BlockBody.transactions)
}
inline void BlockBody::set_transactions(int index, const void* value, size_t size) {
  _impl_.transactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:execution.BlockBody.transactions)
}
inline std::string* BlockBody::_internal_add_transactions() {
  return _impl_.transactions_.Add();
}
inline void BlockBody::add_transactions(const std::string& value) {
  _impl_.transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:execution.BlockBody.transactions)
}
inline void BlockBody::add_transactions(std::string&& value) {
  _impl_.transactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:execution.BlockBody.transactions)
}
inline void BlockBody::add_transactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:execution.BlockBody.transactions)
}
inline void BlockBody::add_transactions(const void* value, size_t size) {
  _impl_.transactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:execution.BlockBody.transactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockBody::transactions() const {
  // @@protoc_insertion_point(field_list:execution.BlockBody.transactions)
  return _impl_.transactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockBody::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:execution.BlockBody.transactions)
  return &_impl_.transactions_;
}

// repeated .execution.Header uncles = 4;
inline int BlockBody::_internal_uncles_size() const {
  return _impl_.uncles_.size();
}
inline int BlockBody::uncles_size() const {
  return _internal_uncles_size();
}
inline void BlockBody::clear_uncles() {
  _impl_.uncles_.Clear();
}
inline ::execution::Header* BlockBody::mutable_uncles(int index) {
  // @@protoc_insertion_point(field_mutable:execution.BlockBody.uncles)
  return _impl_.uncles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header >*
BlockBody::mutable_uncles() {
  // @@protoc_insertion_point(field_mutable_list:execution.BlockBody.uncles)
  return &_impl_.uncles_;
}
inline const ::execution::Header& BlockBody::_internal_uncles(int index) const {
  return _impl_.uncles_.Get(index);
}
inline const ::execution::Header& BlockBody::uncles(int index) const {
  // @@protoc_insertion_point(field_get:execution.BlockBody.uncles)
  return _internal_uncles(index);
}
inline ::execution::Header* BlockBody::_internal_add_uncles() {
  return _impl_.uncles_.Add();
}
inline ::execution::Header* BlockBody::add_uncles() {
  ::execution::Header* _add = _internal_add_uncles();
  // @@protoc_insertion_point(field_add:execution.BlockBody.uncles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header >&
BlockBody::uncles() const {
  // @@protoc_insertion_point(field_list:execution.BlockBody.uncles)
  return _impl_.uncles_;
}

// repeated .types.Withdrawal withdrawals = 5;
inline int BlockBody::_internal_withdrawals_size() const {
  return _impl_.withdrawals_.size();
}
inline int BlockBody::withdrawals_size() const {
  return _internal_withdrawals_size();
}
inline ::types::Withdrawal* BlockBody::mutable_withdrawals(int index) {
  // @@protoc_insertion_point(field_mutable:execution.BlockBody.withdrawals)
  return _impl_.withdrawals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >*
BlockBody::mutable_withdrawals() {
  // @@protoc_insertion_point(field_mutable_list:execution.BlockBody.withdrawals)
  return &_impl_.withdrawals_;
}
inline const ::types::Withdrawal& BlockBody::_internal_withdrawals(int index) const {
  return _impl_.withdrawals_.Get(index);
}
inline const ::types::Withdrawal& BlockBody::withdrawals(int index) const {
  // @@protoc_insertion_point(field_get:execution.BlockBody.withdrawals)
  return _internal_withdrawals(index);
}
inline ::types::Withdrawal* BlockBody::_internal_add_withdrawals() {
  return _impl_.withdrawals_.Add();
}
inline ::types::Withdrawal* BlockBody::add_withdrawals() {
  ::types::Withdrawal* _add = _internal_add_withdrawals();
  // @@protoc_insertion_point(field_add:execution.BlockBody.withdrawals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >&
BlockBody::withdrawals() const {
  // @@protoc_insertion_point(field_list:execution.BlockBody.withdrawals)
  return _impl_.withdrawals_;
}

// -------------------------------------------------------------------

// GetHeaderResponse

// optional .execution.Header header = 1;
inline bool GetHeaderResponse::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool GetHeaderResponse::has_header() const {
  return _internal_has_header();
}
inline void GetHeaderResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::execution::Header& GetHeaderResponse::_internal_header() const {
  const ::execution::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::execution::Header&>(
      ::execution::_Header_default_instance_);
}
inline const ::execution::Header& GetHeaderResponse::header() const {
  // @@protoc_insertion_point(field_get:execution.GetHeaderResponse.header)
  return _internal_header();
}
inline void GetHeaderResponse::unsafe_arena_set_allocated_header(
    ::execution::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.GetHeaderResponse.header)
}
inline ::execution::Header* GetHeaderResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::execution::Header* GetHeaderResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:execution.GetHeaderResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::execution::Header* GetHeaderResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::execution::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::execution::Header* GetHeaderResponse::mutable_header() {
  ::execution::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:execution.GetHeaderResponse.header)
  return _msg;
}
inline void GetHeaderResponse::set_allocated_header(::execution::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:execution.GetHeaderResponse.header)
}

// -------------------------------------------------------------------

// GetBodyResponse

// optional .execution.BlockBody body = 1;
inline bool GetBodyResponse::_internal_has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline bool GetBodyResponse::has_body() const {
  return _internal_has_body();
}
inline void GetBodyResponse::clear_body() {
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::execution::BlockBody& GetBodyResponse::_internal_body() const {
  const ::execution::BlockBody* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::execution::BlockBody&>(
      ::execution::_BlockBody_default_instance_);
}
inline const ::execution::BlockBody& GetBodyResponse::body() const {
  // @@protoc_insertion_point(field_get:execution.GetBodyResponse.body)
  return _internal_body();
}
inline void GetBodyResponse::unsafe_arena_set_allocated_body(
    ::execution::BlockBody* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.GetBodyResponse.body)
}
inline ::execution::BlockBody* GetBodyResponse::release_body() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::BlockBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::execution::BlockBody* GetBodyResponse::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:execution.GetBodyResponse.body)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::BlockBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::execution::BlockBody* GetBodyResponse::_internal_mutable_body() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::execution::BlockBody>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::execution::BlockBody* GetBodyResponse::mutable_body() {
  ::execution::BlockBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:execution.GetBodyResponse.body)
  return _msg;
}
inline void GetBodyResponse::set_allocated_body(::execution::BlockBody* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:execution.GetBodyResponse.body)
}

// -------------------------------------------------------------------

// GetHeaderHashNumberResponse

// optional uint64 block_number = 1;
inline bool GetHeaderHashNumberResponse::_internal_has_block_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetHeaderHashNumberResponse::has_block_number() const {
  return _internal_has_block_number();
}
inline void GetHeaderHashNumberResponse::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t GetHeaderHashNumberResponse::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t GetHeaderHashNumberResponse::block_number() const {
  // @@protoc_insertion_point(field_get:execution.GetHeaderHashNumberResponse.block_number)
  return _internal_block_number();
}
inline void GetHeaderHashNumberResponse::_internal_set_block_number(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.block_number_ = value;
}
inline void GetHeaderHashNumberResponse::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:execution.GetHeaderHashNumberResponse.block_number)
}

// -------------------------------------------------------------------

// GetSegmentRequest

// optional uint64 block_number = 1;
inline bool GetSegmentRequest::_internal_has_block_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetSegmentRequest::has_block_number() const {
  return _internal_has_block_number();
}
inline void GetSegmentRequest::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t GetSegmentRequest::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t GetSegmentRequest::block_number() const {
  // @@protoc_insertion_point(field_get:execution.GetSegmentRequest.block_number)
  return _internal_block_number();
}
inline void GetSegmentRequest::_internal_set_block_number(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.block_number_ = value;
}
inline void GetSegmentRequest::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:execution.GetSegmentRequest.block_number)
}

// optional .types.H256 block_hash = 2;
inline bool GetSegmentRequest::_internal_has_block_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_hash_ != nullptr);
  return value;
}
inline bool GetSegmentRequest::has_block_hash() const {
  return _internal_has_block_hash();
}
inline const ::types::H256& GetSegmentRequest::_internal_block_hash() const {
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& GetSegmentRequest::block_hash() const {
  // @@protoc_insertion_point(field_get:execution.GetSegmentRequest.block_hash)
  return _internal_block_hash();
}
inline void GetSegmentRequest::unsafe_arena_set_allocated_block_hash(
    ::types::H256* block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = block_hash;
  if (block_hash) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.GetSegmentRequest.block_hash)
}
inline ::types::H256* GetSegmentRequest::release_block_hash() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* GetSegmentRequest::unsafe_arena_release_block_hash() {
  // @@protoc_insertion_point(field_release:execution.GetSegmentRequest.block_hash)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* GetSegmentRequest::_internal_mutable_block_hash() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.block_hash_ = p;
  }
  return _impl_.block_hash_;
}
inline ::types::H256* GetSegmentRequest::mutable_block_hash() {
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.GetSegmentRequest.block_hash)
  return _msg;
}
inline void GetSegmentRequest::set_allocated_block_hash(::types::H256* block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  if (block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_hash));
    if (message_arena != submessage_arena) {
      block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_hash, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.block_hash_ = block_hash;
  // @@protoc_insertion_point(field_set_allocated:execution.GetSegmentRequest.block_hash)
}

// -------------------------------------------------------------------

// InsertHeadersRequest

// repeated .execution.Header headers = 1;
inline int InsertHeadersRequest::_internal_headers_size() const {
  return _impl_.headers_.size();
}
inline int InsertHeadersRequest::headers_size() const {
  return _internal_headers_size();
}
inline void InsertHeadersRequest::clear_headers() {
  _impl_.headers_.Clear();
}
inline ::execution::Header* InsertHeadersRequest::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:execution.InsertHeadersRequest.headers)
  return _impl_.headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header >*
InsertHeadersRequest::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:execution.InsertHeadersRequest.headers)
  return &_impl_.headers_;
}
inline const ::execution::Header& InsertHeadersRequest::_internal_headers(int index) const {
  return _impl_.headers_.Get(index);
}
inline const ::execution::Header& InsertHeadersRequest::headers(int index) const {
  // @@protoc_insertion_point(field_get:execution.InsertHeadersRequest.headers)
  return _internal_headers(index);
}
inline ::execution::Header* InsertHeadersRequest::_internal_add_headers() {
  return _impl_.headers_.Add();
}
inline ::execution::Header* InsertHeadersRequest::add_headers() {
  ::execution::Header* _add = _internal_add_headers();
  // @@protoc_insertion_point(field_add:execution.InsertHeadersRequest.headers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::Header >&
InsertHeadersRequest::headers() const {
  // @@protoc_insertion_point(field_list:execution.InsertHeadersRequest.headers)
  return _impl_.headers_;
}

// -------------------------------------------------------------------

// InsertBodiesRequest

// repeated .execution.BlockBody bodies = 1;
inline int InsertBodiesRequest::_internal_bodies_size() const {
  return _impl_.bodies_.size();
}
inline int InsertBodiesRequest::bodies_size() const {
  return _internal_bodies_size();
}
inline void InsertBodiesRequest::clear_bodies() {
  _impl_.bodies_.Clear();
}
inline ::execution::BlockBody* InsertBodiesRequest::mutable_bodies(int index) {
  // @@protoc_insertion_point(field_mutable:execution.InsertBodiesRequest.bodies)
  return _impl_.bodies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::BlockBody >*
InsertBodiesRequest::mutable_bodies() {
  // @@protoc_insertion_point(field_mutable_list:execution.InsertBodiesRequest.bodies)
  return &_impl_.bodies_;
}
inline const ::execution::BlockBody& InsertBodiesRequest::_internal_bodies(int index) const {
  return _impl_.bodies_.Get(index);
}
inline const ::execution::BlockBody& InsertBodiesRequest::bodies(int index) const {
  // @@protoc_insertion_point(field_get:execution.InsertBodiesRequest.bodies)
  return _internal_bodies(index);
}
inline ::execution::BlockBody* InsertBodiesRequest::_internal_add_bodies() {
  return _impl_.bodies_.Add();
}
inline ::execution::BlockBody* InsertBodiesRequest::add_bodies() {
  ::execution::BlockBody* _add = _internal_add_bodies();
  // @@protoc_insertion_point(field_add:execution.InsertBodiesRequest.bodies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::execution::BlockBody >&
InsertBodiesRequest::bodies() const {
  // @@protoc_insertion_point(field_list:execution.InsertBodiesRequest.bodies)
  return _impl_.bodies_;
}

// -------------------------------------------------------------------

// EmptyMessage

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace execution

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::execution::ValidationStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::execution::ValidationStatus>() {
  return ::execution::ValidationStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_execution_2fexecution_2eproto
