// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: remote/ethbackend.proto
#ifndef GRPC_remote_2fethbackend_2eproto__INCLUDED
#define GRPC_remote_2fethbackend_2eproto__INCLUDED

#include "remote/ethbackend.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace remote {

class ETHBACKEND final {
 public:
  static constexpr char const* service_full_name() {
    return "remote.ETHBACKEND";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::remote::EtherbaseReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::EtherbaseReply>> AsyncEtherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::EtherbaseReply>>(AsyncEtherbaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::EtherbaseReply>> PrepareAsyncEtherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::EtherbaseReply>>(PrepareAsyncEtherbaseRaw(context, request, cq));
    }
    virtual ::grpc::Status NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::remote::NetVersionReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetVersionReply>> AsyncNetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetVersionReply>>(AsyncNetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetVersionReply>> PrepareAsyncNetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetVersionReply>>(PrepareAsyncNetVersionRaw(context, request, cq));
    }
    virtual ::grpc::Status NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::remote::NetPeerCountReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetPeerCountReply>> AsyncNetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetPeerCountReply>>(AsyncNetPeerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetPeerCountReply>> PrepareAsyncNetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetPeerCountReply>>(PrepareAsyncNetPeerCountRaw(context, request, cq));
    }
    // Version returns the service version number
    virtual ::grpc::Status Version(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::VersionReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>> AsyncVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    // Syncing returns a data object detailing the status of the sync process
    virtual ::grpc::Status Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::SyncingReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::SyncingReply>> AsyncSyncing(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::SyncingReply>>(AsyncSyncingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::SyncingReply>> PrepareAsyncSyncing(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::SyncingReply>>(PrepareAsyncSyncingRaw(context, request, cq));
    }
    // ProtocolVersion returns the Ethereum protocol version number (e.g. 66 for ETH66).
    virtual ::grpc::Status ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::remote::ProtocolVersionReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::ProtocolVersionReply>> AsyncProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::ProtocolVersionReply>>(AsyncProtocolVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::ProtocolVersionReply>> PrepareAsyncProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::ProtocolVersionReply>>(PrepareAsyncProtocolVersionRaw(context, request, cq));
    }
    // ClientVersion returns the Ethereum client version string using node name convention (e.g. TurboGeth/v2021.03.2-alpha/Linux).
    virtual ::grpc::Status ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::remote::ClientVersionReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::ClientVersionReply>> AsyncClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::ClientVersionReply>>(AsyncClientVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::ClientVersionReply>> PrepareAsyncClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::ClientVersionReply>>(PrepareAsyncClientVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::remote::SubscribeReply>> Subscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::remote::SubscribeReply>>(SubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::remote::SubscribeReply>> AsyncSubscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::remote::SubscribeReply>>(AsyncSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::remote::SubscribeReply>> PrepareAsyncSubscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::remote::SubscribeReply>>(PrepareAsyncSubscribeRaw(context, request, cq));
    }
    // Only one subscription is needed to serve all the users, LogsFilterRequest allows to dynamically modifying the subscription
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>> SubscribeLogs(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>>(SubscribeLogsRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>> AsyncSubscribeLogs(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>>(AsyncSubscribeLogsRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>> PrepareAsyncSubscribeLogs(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>>(PrepareAsyncSubscribeLogsRaw(context, cq));
    }
    // High-level method - can read block from db, snapshots or apply any other logic
    // it doesn't provide consistency
    // Request fields are optional - it's ok to request block only by hash or only by number
    virtual ::grpc::Status Block(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::remote::BlockReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BlockReply>> AsyncBlock(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BlockReply>>(AsyncBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BlockReply>> PrepareAsyncBlock(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BlockReply>>(PrepareAsyncBlockRaw(context, request, cq));
    }
    // High-level method - can read block body (only storage metadata) from db, snapshots or apply any other logic
    virtual ::grpc::Status CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::remote::CanonicalBodyForStorageReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalBodyForStorageReply>> AsyncCanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalBodyForStorageReply>>(AsyncCanonicalBodyForStorageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalBodyForStorageReply>> PrepareAsyncCanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalBodyForStorageReply>>(PrepareAsyncCanonicalBodyForStorageRaw(context, request, cq));
    }
    // High-level method - can find block hash by block number
    virtual ::grpc::Status CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::remote::CanonicalHashReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalHashReply>> AsyncCanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalHashReply>>(AsyncCanonicalHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalHashReply>> PrepareAsyncCanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalHashReply>>(PrepareAsyncCanonicalHashRaw(context, request, cq));
    }
    // High-level method - can find block number by block hash
    virtual ::grpc::Status HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::remote::HeaderNumberReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::HeaderNumberReply>> AsyncHeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::HeaderNumberReply>>(AsyncHeaderNumberRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::HeaderNumberReply>> PrepareAsyncHeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::HeaderNumberReply>>(PrepareAsyncHeaderNumberRaw(context, request, cq));
    }
    // High-level method - can find block number by txn hash
    // it doesn't provide consistency
    virtual ::grpc::Status TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::remote::TxnLookupReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::TxnLookupReply>> AsyncTxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::TxnLookupReply>>(AsyncTxnLookupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::TxnLookupReply>> PrepareAsyncTxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::TxnLookupReply>>(PrepareAsyncTxnLookupRaw(context, request, cq));
    }
    // NodeInfo collects and returns NodeInfo from all running sentry instances.
    virtual ::grpc::Status NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::remote::NodesInfoReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NodesInfoReply>> AsyncNodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NodesInfoReply>>(AsyncNodeInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NodesInfoReply>> PrepareAsyncNodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::NodesInfoReply>>(PrepareAsyncNodeInfoRaw(context, request, cq));
    }
    // Peers collects and returns peers information from all running sentry instances.
    virtual ::grpc::Status Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::PeersReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::PeersReply>> AsyncPeers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::PeersReply>>(AsyncPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::PeersReply>> PrepareAsyncPeers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::PeersReply>>(PrepareAsyncPeersRaw(context, request, cq));
    }
    virtual ::grpc::Status AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::remote::AddPeerReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::AddPeerReply>> AsyncAddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::AddPeerReply>>(AsyncAddPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::AddPeerReply>> PrepareAsyncAddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::AddPeerReply>>(PrepareAsyncAddPeerRaw(context, request, cq));
    }
    // PendingBlock returns latest built block.
    virtual ::grpc::Status PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::PendingBlockReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::PendingBlockReply>> AsyncPendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::PendingBlockReply>>(AsyncPendingBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::PendingBlockReply>> PrepareAsyncPendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::PendingBlockReply>>(PrepareAsyncPendingBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::remote::BorTxnLookupReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorTxnLookupReply>> AsyncBorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorTxnLookupReply>>(AsyncBorTxnLookupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorTxnLookupReply>> PrepareAsyncBorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorTxnLookupReply>>(PrepareAsyncBorTxnLookupRaw(context, request, cq));
    }
    virtual ::grpc::Status BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::remote::BorEventsReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorEventsReply>> AsyncBorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorEventsReply>>(AsyncBorEventsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorEventsReply>> PrepareAsyncBorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorEventsReply>>(PrepareAsyncBorEventsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Version returns the service version number
      virtual void Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Syncing returns a data object detailing the status of the sync process
      virtual void Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ProtocolVersion returns the Ethereum protocol version number (e.g. 66 for ETH66).
      virtual void ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ClientVersion returns the Ethereum client version string using node name convention (e.g. TurboGeth/v2021.03.2-alpha/Linux).
      virtual void ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Subscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest* request, ::grpc::ClientReadReactor< ::remote::SubscribeReply>* reactor) = 0;
      // Only one subscription is needed to serve all the users, LogsFilterRequest allows to dynamically modifying the subscription
      virtual void SubscribeLogs(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::remote::LogsFilterRequest,::remote::SubscribeLogsReply>* reactor) = 0;
      // High-level method - can read block from db, snapshots or apply any other logic
      // it doesn't provide consistency
      // Request fields are optional - it's ok to request block only by hash or only by number
      virtual void Block(::grpc::ClientContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Block(::grpc::ClientContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // High-level method - can read block body (only storage metadata) from db, snapshots or apply any other logic
      virtual void CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // High-level method - can find block hash by block number
      virtual void CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // High-level method - can find block number by block hash
      virtual void HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // High-level method - can find block number by txn hash
      // it doesn't provide consistency
      virtual void TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // NodeInfo collects and returns NodeInfo from all running sentry instances.
      virtual void NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Peers collects and returns peers information from all running sentry instances.
      virtual void Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // PendingBlock returns latest built block.
      virtual void PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::EtherbaseReply>* AsyncEtherbaseRaw(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::EtherbaseReply>* PrepareAsyncEtherbaseRaw(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetVersionReply>* AsyncNetVersionRaw(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetVersionReply>* PrepareAsyncNetVersionRaw(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetPeerCountReply>* AsyncNetPeerCountRaw(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::NetPeerCountReply>* PrepareAsyncNetPeerCountRaw(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>* AsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::SyncingReply>* AsyncSyncingRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::SyncingReply>* PrepareAsyncSyncingRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::ProtocolVersionReply>* AsyncProtocolVersionRaw(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::ProtocolVersionReply>* PrepareAsyncProtocolVersionRaw(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::ClientVersionReply>* AsyncClientVersionRaw(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::ClientVersionReply>* PrepareAsyncClientVersionRaw(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::remote::SubscribeReply>* SubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::remote::SubscribeReply>* AsyncSubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::remote::SubscribeReply>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* SubscribeLogsRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* AsyncSubscribeLogsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* PrepareAsyncSubscribeLogsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::BlockReply>* AsyncBlockRaw(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::BlockReply>* PrepareAsyncBlockRaw(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalBodyForStorageReply>* AsyncCanonicalBodyForStorageRaw(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalBodyForStorageReply>* PrepareAsyncCanonicalBodyForStorageRaw(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalHashReply>* AsyncCanonicalHashRaw(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::CanonicalHashReply>* PrepareAsyncCanonicalHashRaw(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::HeaderNumberReply>* AsyncHeaderNumberRaw(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::HeaderNumberReply>* PrepareAsyncHeaderNumberRaw(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::TxnLookupReply>* AsyncTxnLookupRaw(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::TxnLookupReply>* PrepareAsyncTxnLookupRaw(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::NodesInfoReply>* AsyncNodeInfoRaw(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::NodesInfoReply>* PrepareAsyncNodeInfoRaw(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::PeersReply>* AsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::PeersReply>* PrepareAsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::AddPeerReply>* AsyncAddPeerRaw(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::AddPeerReply>* PrepareAsyncAddPeerRaw(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::PendingBlockReply>* AsyncPendingBlockRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::PendingBlockReply>* PrepareAsyncPendingBlockRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorTxnLookupReply>* AsyncBorTxnLookupRaw(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorTxnLookupReply>* PrepareAsyncBorTxnLookupRaw(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorEventsReply>* AsyncBorEventsRaw(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorEventsReply>* PrepareAsyncBorEventsRaw(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::remote::EtherbaseReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::EtherbaseReply>> AsyncEtherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::EtherbaseReply>>(AsyncEtherbaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::EtherbaseReply>> PrepareAsyncEtherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::EtherbaseReply>>(PrepareAsyncEtherbaseRaw(context, request, cq));
    }
    ::grpc::Status NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::remote::NetVersionReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NetVersionReply>> AsyncNetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NetVersionReply>>(AsyncNetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NetVersionReply>> PrepareAsyncNetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NetVersionReply>>(PrepareAsyncNetVersionRaw(context, request, cq));
    }
    ::grpc::Status NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::remote::NetPeerCountReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NetPeerCountReply>> AsyncNetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NetPeerCountReply>>(AsyncNetPeerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NetPeerCountReply>> PrepareAsyncNetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NetPeerCountReply>>(PrepareAsyncNetPeerCountRaw(context, request, cq));
    }
    ::grpc::Status Version(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::VersionReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::VersionReply>> AsyncVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::VersionReply>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::VersionReply>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::VersionReply>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    ::grpc::Status Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::SyncingReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::SyncingReply>> AsyncSyncing(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::SyncingReply>>(AsyncSyncingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::SyncingReply>> PrepareAsyncSyncing(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::SyncingReply>>(PrepareAsyncSyncingRaw(context, request, cq));
    }
    ::grpc::Status ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::remote::ProtocolVersionReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::ProtocolVersionReply>> AsyncProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::ProtocolVersionReply>>(AsyncProtocolVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::ProtocolVersionReply>> PrepareAsyncProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::ProtocolVersionReply>>(PrepareAsyncProtocolVersionRaw(context, request, cq));
    }
    ::grpc::Status ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::remote::ClientVersionReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::ClientVersionReply>> AsyncClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::ClientVersionReply>>(AsyncClientVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::ClientVersionReply>> PrepareAsyncClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::ClientVersionReply>>(PrepareAsyncClientVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::remote::SubscribeReply>> Subscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::remote::SubscribeReply>>(SubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::remote::SubscribeReply>> AsyncSubscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::remote::SubscribeReply>>(AsyncSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::remote::SubscribeReply>> PrepareAsyncSubscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::remote::SubscribeReply>>(PrepareAsyncSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>> SubscribeLogs(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>>(SubscribeLogsRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>> AsyncSubscribeLogs(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>>(AsyncSubscribeLogsRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>> PrepareAsyncSubscribeLogs(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>>(PrepareAsyncSubscribeLogsRaw(context, cq));
    }
    ::grpc::Status Block(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::remote::BlockReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BlockReply>> AsyncBlock(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BlockReply>>(AsyncBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BlockReply>> PrepareAsyncBlock(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BlockReply>>(PrepareAsyncBlockRaw(context, request, cq));
    }
    ::grpc::Status CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::remote::CanonicalBodyForStorageReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::CanonicalBodyForStorageReply>> AsyncCanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::CanonicalBodyForStorageReply>>(AsyncCanonicalBodyForStorageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::CanonicalBodyForStorageReply>> PrepareAsyncCanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::CanonicalBodyForStorageReply>>(PrepareAsyncCanonicalBodyForStorageRaw(context, request, cq));
    }
    ::grpc::Status CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::remote::CanonicalHashReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::CanonicalHashReply>> AsyncCanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::CanonicalHashReply>>(AsyncCanonicalHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::CanonicalHashReply>> PrepareAsyncCanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::CanonicalHashReply>>(PrepareAsyncCanonicalHashRaw(context, request, cq));
    }
    ::grpc::Status HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::remote::HeaderNumberReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::HeaderNumberReply>> AsyncHeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::HeaderNumberReply>>(AsyncHeaderNumberRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::HeaderNumberReply>> PrepareAsyncHeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::HeaderNumberReply>>(PrepareAsyncHeaderNumberRaw(context, request, cq));
    }
    ::grpc::Status TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::remote::TxnLookupReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::TxnLookupReply>> AsyncTxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::TxnLookupReply>>(AsyncTxnLookupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::TxnLookupReply>> PrepareAsyncTxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::TxnLookupReply>>(PrepareAsyncTxnLookupRaw(context, request, cq));
    }
    ::grpc::Status NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::remote::NodesInfoReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NodesInfoReply>> AsyncNodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NodesInfoReply>>(AsyncNodeInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NodesInfoReply>> PrepareAsyncNodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::NodesInfoReply>>(PrepareAsyncNodeInfoRaw(context, request, cq));
    }
    ::grpc::Status Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::PeersReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::PeersReply>> AsyncPeers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::PeersReply>>(AsyncPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::PeersReply>> PrepareAsyncPeers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::PeersReply>>(PrepareAsyncPeersRaw(context, request, cq));
    }
    ::grpc::Status AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::remote::AddPeerReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::AddPeerReply>> AsyncAddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::AddPeerReply>>(AsyncAddPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::AddPeerReply>> PrepareAsyncAddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::AddPeerReply>>(PrepareAsyncAddPeerRaw(context, request, cq));
    }
    ::grpc::Status PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::PendingBlockReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::PendingBlockReply>> AsyncPendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::PendingBlockReply>>(AsyncPendingBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::PendingBlockReply>> PrepareAsyncPendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::PendingBlockReply>>(PrepareAsyncPendingBlockRaw(context, request, cq));
    }
    ::grpc::Status BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::remote::BorTxnLookupReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BorTxnLookupReply>> AsyncBorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BorTxnLookupReply>>(AsyncBorTxnLookupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BorTxnLookupReply>> PrepareAsyncBorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BorTxnLookupReply>>(PrepareAsyncBorTxnLookupRaw(context, request, cq));
    }
    ::grpc::Status BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::remote::BorEventsReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BorEventsReply>> AsyncBorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BorEventsReply>>(AsyncBorEventsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BorEventsReply>> PrepareAsyncBorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::remote::BorEventsReply>>(PrepareAsyncBorEventsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response, std::function<void(::grpc::Status)>) override;
      void Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response, std::function<void(::grpc::Status)>) override;
      void NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response, std::function<void(::grpc::Status)>) override;
      void NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, std::function<void(::grpc::Status)>) override;
      void Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response, std::function<void(::grpc::Status)>) override;
      void Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response, std::function<void(::grpc::Status)>) override;
      void ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response, std::function<void(::grpc::Status)>) override;
      void ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Subscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest* request, ::grpc::ClientReadReactor< ::remote::SubscribeReply>* reactor) override;
      void SubscribeLogs(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::remote::LogsFilterRequest,::remote::SubscribeLogsReply>* reactor) override;
      void Block(::grpc::ClientContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response, std::function<void(::grpc::Status)>) override;
      void Block(::grpc::ClientContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response, std::function<void(::grpc::Status)>) override;
      void CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response, std::function<void(::grpc::Status)>) override;
      void CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response, std::function<void(::grpc::Status)>) override;
      void HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response, std::function<void(::grpc::Status)>) override;
      void TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response, std::function<void(::grpc::Status)>) override;
      void NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response, std::function<void(::grpc::Status)>) override;
      void Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response, std::function<void(::grpc::Status)>) override;
      void AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response, std::function<void(::grpc::Status)>) override;
      void PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response, std::function<void(::grpc::Status)>) override;
      void BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response, std::function<void(::grpc::Status)>) override;
      void BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::remote::EtherbaseReply>* AsyncEtherbaseRaw(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::EtherbaseReply>* PrepareAsyncEtherbaseRaw(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::NetVersionReply>* AsyncNetVersionRaw(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::NetVersionReply>* PrepareAsyncNetVersionRaw(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::NetPeerCountReply>* AsyncNetPeerCountRaw(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::NetPeerCountReply>* PrepareAsyncNetPeerCountRaw(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::types::VersionReply>* AsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::types::VersionReply>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::SyncingReply>* AsyncSyncingRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::SyncingReply>* PrepareAsyncSyncingRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::ProtocolVersionReply>* AsyncProtocolVersionRaw(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::ProtocolVersionReply>* PrepareAsyncProtocolVersionRaw(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::ClientVersionReply>* AsyncClientVersionRaw(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::ClientVersionReply>* PrepareAsyncClientVersionRaw(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::remote::SubscribeReply>* SubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::remote::SubscribeReply>* AsyncSubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::remote::SubscribeReply>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* SubscribeLogsRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* AsyncSubscribeLogsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* PrepareAsyncSubscribeLogsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::BlockReply>* AsyncBlockRaw(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::BlockReply>* PrepareAsyncBlockRaw(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::CanonicalBodyForStorageReply>* AsyncCanonicalBodyForStorageRaw(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::CanonicalBodyForStorageReply>* PrepareAsyncCanonicalBodyForStorageRaw(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::CanonicalHashReply>* AsyncCanonicalHashRaw(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::CanonicalHashReply>* PrepareAsyncCanonicalHashRaw(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::HeaderNumberReply>* AsyncHeaderNumberRaw(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::HeaderNumberReply>* PrepareAsyncHeaderNumberRaw(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::TxnLookupReply>* AsyncTxnLookupRaw(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::TxnLookupReply>* PrepareAsyncTxnLookupRaw(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::NodesInfoReply>* AsyncNodeInfoRaw(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::NodesInfoReply>* PrepareAsyncNodeInfoRaw(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::PeersReply>* AsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::PeersReply>* PrepareAsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::AddPeerReply>* AsyncAddPeerRaw(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::AddPeerReply>* PrepareAsyncAddPeerRaw(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::PendingBlockReply>* AsyncPendingBlockRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::PendingBlockReply>* PrepareAsyncPendingBlockRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::BorTxnLookupReply>* AsyncBorTxnLookupRaw(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::BorTxnLookupReply>* PrepareAsyncBorTxnLookupRaw(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::BorEventsReply>* AsyncBorEventsRaw(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::remote::BorEventsReply>* PrepareAsyncBorEventsRaw(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Etherbase_;
    const ::grpc::internal::RpcMethod rpcmethod_NetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_NetPeerCount_;
    const ::grpc::internal::RpcMethod rpcmethod_Version_;
    const ::grpc::internal::RpcMethod rpcmethod_Syncing_;
    const ::grpc::internal::RpcMethod rpcmethod_ProtocolVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_ClientVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_Subscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeLogs_;
    const ::grpc::internal::RpcMethod rpcmethod_Block_;
    const ::grpc::internal::RpcMethod rpcmethod_CanonicalBodyForStorage_;
    const ::grpc::internal::RpcMethod rpcmethod_CanonicalHash_;
    const ::grpc::internal::RpcMethod rpcmethod_HeaderNumber_;
    const ::grpc::internal::RpcMethod rpcmethod_TxnLookup_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_Peers_;
    const ::grpc::internal::RpcMethod rpcmethod_AddPeer_;
    const ::grpc::internal::RpcMethod rpcmethod_PendingBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_BorTxnLookup_;
    const ::grpc::internal::RpcMethod rpcmethod_BorEvents_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Etherbase(::grpc::ServerContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response);
    virtual ::grpc::Status NetVersion(::grpc::ServerContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response);
    virtual ::grpc::Status NetPeerCount(::grpc::ServerContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response);
    // Version returns the service version number
    virtual ::grpc::Status Version(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response);
    // Syncing returns a data object detailing the status of the sync process
    virtual ::grpc::Status Syncing(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response);
    // ProtocolVersion returns the Ethereum protocol version number (e.g. 66 for ETH66).
    virtual ::grpc::Status ProtocolVersion(::grpc::ServerContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response);
    // ClientVersion returns the Ethereum client version string using node name convention (e.g. TurboGeth/v2021.03.2-alpha/Linux).
    virtual ::grpc::Status ClientVersion(::grpc::ServerContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response);
    virtual ::grpc::Status Subscribe(::grpc::ServerContext* context, const ::remote::SubscribeRequest* request, ::grpc::ServerWriter< ::remote::SubscribeReply>* writer);
    // Only one subscription is needed to serve all the users, LogsFilterRequest allows to dynamically modifying the subscription
    virtual ::grpc::Status SubscribeLogs(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::remote::SubscribeLogsReply, ::remote::LogsFilterRequest>* stream);
    // High-level method - can read block from db, snapshots or apply any other logic
    // it doesn't provide consistency
    // Request fields are optional - it's ok to request block only by hash or only by number
    virtual ::grpc::Status Block(::grpc::ServerContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response);
    // High-level method - can read block body (only storage metadata) from db, snapshots or apply any other logic
    virtual ::grpc::Status CanonicalBodyForStorage(::grpc::ServerContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response);
    // High-level method - can find block hash by block number
    virtual ::grpc::Status CanonicalHash(::grpc::ServerContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response);
    // High-level method - can find block number by block hash
    virtual ::grpc::Status HeaderNumber(::grpc::ServerContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response);
    // High-level method - can find block number by txn hash
    // it doesn't provide consistency
    virtual ::grpc::Status TxnLookup(::grpc::ServerContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response);
    // NodeInfo collects and returns NodeInfo from all running sentry instances.
    virtual ::grpc::Status NodeInfo(::grpc::ServerContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response);
    // Peers collects and returns peers information from all running sentry instances.
    virtual ::grpc::Status Peers(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response);
    virtual ::grpc::Status AddPeer(::grpc::ServerContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response);
    // PendingBlock returns latest built block.
    virtual ::grpc::Status PendingBlock(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response);
    virtual ::grpc::Status BorTxnLookup(::grpc::ServerContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response);
    virtual ::grpc::Status BorEvents(::grpc::ServerContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Etherbase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Etherbase() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Etherbase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Etherbase(::grpc::ServerContext* /*context*/, const ::remote::EtherbaseRequest* /*request*/, ::remote::EtherbaseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEtherbase(::grpc::ServerContext* context, ::remote::EtherbaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::EtherbaseReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NetVersion() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_NetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetVersion(::grpc::ServerContext* /*context*/, const ::remote::NetVersionRequest* /*request*/, ::remote::NetVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNetVersion(::grpc::ServerContext* context, ::remote::NetVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::NetVersionReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NetPeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NetPeerCount() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_NetPeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetPeerCount(::grpc::ServerContext* /*context*/, const ::remote::NetPeerCountRequest* /*request*/, ::remote::NetPeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNetPeerCount(::grpc::ServerContext* context, ::remote::NetPeerCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::NetPeerCountReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Version() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::types::VersionReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Syncing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Syncing() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Syncing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Syncing(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::SyncingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSyncing(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::remote::SyncingReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProtocolVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ProtocolVersion() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ProtocolVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProtocolVersion(::grpc::ServerContext* /*context*/, const ::remote::ProtocolVersionRequest* /*request*/, ::remote::ProtocolVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProtocolVersion(::grpc::ServerContext* context, ::remote::ProtocolVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::ProtocolVersionReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClientVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClientVersion() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ClientVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientVersion(::grpc::ServerContext* /*context*/, const ::remote::ClientVersionRequest* /*request*/, ::remote::ClientVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClientVersion(::grpc::ServerContext* context, ::remote::ClientVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::ClientVersionReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Subscribe() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::remote::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::remote::SubscribeReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::remote::SubscribeRequest* request, ::grpc::ServerAsyncWriter< ::remote::SubscribeReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeLogs() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SubscribeLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeLogs(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::remote::SubscribeLogsReply, ::remote::LogsFilterRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeLogs(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::remote::SubscribeLogsReply, ::remote::LogsFilterRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(8, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Block() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::remote::BlockRequest* /*request*/, ::remote::BlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlock(::grpc::ServerContext* context, ::remote::BlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::BlockReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CanonicalBodyForStorage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CanonicalBodyForStorage() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_CanonicalBodyForStorage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalBodyForStorage(::grpc::ServerContext* /*context*/, const ::remote::CanonicalBodyForStorageRequest* /*request*/, ::remote::CanonicalBodyForStorageReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCanonicalBodyForStorage(::grpc::ServerContext* context, ::remote::CanonicalBodyForStorageRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::CanonicalBodyForStorageReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CanonicalHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CanonicalHash() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_CanonicalHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalHash(::grpc::ServerContext* /*context*/, const ::remote::CanonicalHashRequest* /*request*/, ::remote::CanonicalHashReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCanonicalHash(::grpc::ServerContext* context, ::remote::CanonicalHashRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::CanonicalHashReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HeaderNumber : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HeaderNumber() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_HeaderNumber() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeaderNumber(::grpc::ServerContext* /*context*/, const ::remote::HeaderNumberRequest* /*request*/, ::remote::HeaderNumberReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHeaderNumber(::grpc::ServerContext* context, ::remote::HeaderNumberRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::HeaderNumberReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TxnLookup() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_TxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TxnLookup(::grpc::ServerContext* /*context*/, const ::remote::TxnLookupRequest* /*request*/, ::remote::TxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTxnLookup(::grpc::ServerContext* context, ::remote::TxnLookupRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::TxnLookupReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeInfo() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::remote::NodesInfoRequest* /*request*/, ::remote::NodesInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeInfo(::grpc::ServerContext* context, ::remote::NodesInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::NodesInfoReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Peers() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeers(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::remote::PeersReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddPeer() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::remote::AddPeerRequest* /*request*/, ::remote::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPeer(::grpc::ServerContext* context, ::remote::AddPeerRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::AddPeerReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PendingBlock() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_PendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingBlock(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PendingBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPendingBlock(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::remote::PendingBlockReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BorTxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BorTxnLookup() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_BorTxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorTxnLookup(::grpc::ServerContext* /*context*/, const ::remote::BorTxnLookupRequest* /*request*/, ::remote::BorTxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBorTxnLookup(::grpc::ServerContext* context, ::remote::BorTxnLookupRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::BorTxnLookupReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BorEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BorEvents() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_BorEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorEvents(::grpc::ServerContext* /*context*/, const ::remote::BorEventsRequest* /*request*/, ::remote::BorEventsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBorEvents(::grpc::ServerContext* context, ::remote::BorEventsRequest* request, ::grpc::ServerAsyncResponseWriter< ::remote::BorEventsReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Etherbase<WithAsyncMethod_NetVersion<WithAsyncMethod_NetPeerCount<WithAsyncMethod_Version<WithAsyncMethod_Syncing<WithAsyncMethod_ProtocolVersion<WithAsyncMethod_ClientVersion<WithAsyncMethod_Subscribe<WithAsyncMethod_SubscribeLogs<WithAsyncMethod_Block<WithAsyncMethod_CanonicalBodyForStorage<WithAsyncMethod_CanonicalHash<WithAsyncMethod_HeaderNumber<WithAsyncMethod_TxnLookup<WithAsyncMethod_NodeInfo<WithAsyncMethod_Peers<WithAsyncMethod_AddPeer<WithAsyncMethod_PendingBlock<WithAsyncMethod_BorTxnLookup<WithAsyncMethod_BorEvents<Service > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Etherbase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Etherbase() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::EtherbaseRequest, ::remote::EtherbaseReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response) { return this->Etherbase(context, request, response); }));}
    void SetMessageAllocatorFor_Etherbase(
        ::grpc::MessageAllocator< ::remote::EtherbaseRequest, ::remote::EtherbaseReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::EtherbaseRequest, ::remote::EtherbaseReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Etherbase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Etherbase(::grpc::ServerContext* /*context*/, const ::remote::EtherbaseRequest* /*request*/, ::remote::EtherbaseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Etherbase(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::EtherbaseRequest* /*request*/, ::remote::EtherbaseReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_NetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_NetVersion() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::NetVersionRequest, ::remote::NetVersionReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response) { return this->NetVersion(context, request, response); }));}
    void SetMessageAllocatorFor_NetVersion(
        ::grpc::MessageAllocator< ::remote::NetVersionRequest, ::remote::NetVersionReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::NetVersionRequest, ::remote::NetVersionReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_NetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetVersion(::grpc::ServerContext* /*context*/, const ::remote::NetVersionRequest* /*request*/, ::remote::NetVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::NetVersionRequest* /*request*/, ::remote::NetVersionReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_NetPeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_NetPeerCount() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::NetPeerCountRequest, ::remote::NetPeerCountReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response) { return this->NetPeerCount(context, request, response); }));}
    void SetMessageAllocatorFor_NetPeerCount(
        ::grpc::MessageAllocator< ::remote::NetPeerCountRequest, ::remote::NetPeerCountReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::NetPeerCountRequest, ::remote::NetPeerCountReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_NetPeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetPeerCount(::grpc::ServerContext* /*context*/, const ::remote::NetPeerCountRequest* /*request*/, ::remote::NetPeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NetPeerCount(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::NetPeerCountRequest* /*request*/, ::remote::NetPeerCountReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Version() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::types::VersionReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response) { return this->Version(context, request, response); }));}
    void SetMessageAllocatorFor_Version(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::types::VersionReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::types::VersionReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Version(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Syncing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Syncing() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::remote::SyncingReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response) { return this->Syncing(context, request, response); }));}
    void SetMessageAllocatorFor_Syncing(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::remote::SyncingReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::remote::SyncingReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Syncing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Syncing(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::SyncingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Syncing(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::SyncingReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ProtocolVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ProtocolVersion() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::ProtocolVersionRequest, ::remote::ProtocolVersionReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response) { return this->ProtocolVersion(context, request, response); }));}
    void SetMessageAllocatorFor_ProtocolVersion(
        ::grpc::MessageAllocator< ::remote::ProtocolVersionRequest, ::remote::ProtocolVersionReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::ProtocolVersionRequest, ::remote::ProtocolVersionReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ProtocolVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProtocolVersion(::grpc::ServerContext* /*context*/, const ::remote::ProtocolVersionRequest* /*request*/, ::remote::ProtocolVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProtocolVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::ProtocolVersionRequest* /*request*/, ::remote::ProtocolVersionReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ClientVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ClientVersion() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::ClientVersionRequest, ::remote::ClientVersionReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response) { return this->ClientVersion(context, request, response); }));}
    void SetMessageAllocatorFor_ClientVersion(
        ::grpc::MessageAllocator< ::remote::ClientVersionRequest, ::remote::ClientVersionReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::ClientVersionRequest, ::remote::ClientVersionReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ClientVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientVersion(::grpc::ServerContext* /*context*/, const ::remote::ClientVersionRequest* /*request*/, ::remote::ClientVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClientVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::ClientVersionRequest* /*request*/, ::remote::ClientVersionReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::remote::SubscribeRequest, ::remote::SubscribeReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::SubscribeRequest* request) { return this->Subscribe(context, request); }));
    }
    ~WithCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::remote::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::remote::SubscribeReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::remote::SubscribeReply>* Subscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::SubscribeRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeLogs() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackBidiHandler< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->SubscribeLogs(context); }));
    }
    ~WithCallbackMethod_SubscribeLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeLogs(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::remote::SubscribeLogsReply, ::remote::LogsFilterRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* SubscribeLogs(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Block() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::BlockRequest, ::remote::BlockReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response) { return this->Block(context, request, response); }));}
    void SetMessageAllocatorFor_Block(
        ::grpc::MessageAllocator< ::remote::BlockRequest, ::remote::BlockReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::BlockRequest, ::remote::BlockReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::remote::BlockRequest* /*request*/, ::remote::BlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Block(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::BlockRequest* /*request*/, ::remote::BlockReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CanonicalBodyForStorage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CanonicalBodyForStorage() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::CanonicalBodyForStorageRequest, ::remote::CanonicalBodyForStorageReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response) { return this->CanonicalBodyForStorage(context, request, response); }));}
    void SetMessageAllocatorFor_CanonicalBodyForStorage(
        ::grpc::MessageAllocator< ::remote::CanonicalBodyForStorageRequest, ::remote::CanonicalBodyForStorageReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::CanonicalBodyForStorageRequest, ::remote::CanonicalBodyForStorageReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CanonicalBodyForStorage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalBodyForStorage(::grpc::ServerContext* /*context*/, const ::remote::CanonicalBodyForStorageRequest* /*request*/, ::remote::CanonicalBodyForStorageReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CanonicalBodyForStorage(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::CanonicalBodyForStorageRequest* /*request*/, ::remote::CanonicalBodyForStorageReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CanonicalHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CanonicalHash() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::CanonicalHashRequest, ::remote::CanonicalHashReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response) { return this->CanonicalHash(context, request, response); }));}
    void SetMessageAllocatorFor_CanonicalHash(
        ::grpc::MessageAllocator< ::remote::CanonicalHashRequest, ::remote::CanonicalHashReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::CanonicalHashRequest, ::remote::CanonicalHashReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CanonicalHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalHash(::grpc::ServerContext* /*context*/, const ::remote::CanonicalHashRequest* /*request*/, ::remote::CanonicalHashReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CanonicalHash(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::CanonicalHashRequest* /*request*/, ::remote::CanonicalHashReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HeaderNumber : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HeaderNumber() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::HeaderNumberRequest, ::remote::HeaderNumberReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response) { return this->HeaderNumber(context, request, response); }));}
    void SetMessageAllocatorFor_HeaderNumber(
        ::grpc::MessageAllocator< ::remote::HeaderNumberRequest, ::remote::HeaderNumberReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::HeaderNumberRequest, ::remote::HeaderNumberReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HeaderNumber() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeaderNumber(::grpc::ServerContext* /*context*/, const ::remote::HeaderNumberRequest* /*request*/, ::remote::HeaderNumberReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HeaderNumber(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::HeaderNumberRequest* /*request*/, ::remote::HeaderNumberReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TxnLookup() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::TxnLookupRequest, ::remote::TxnLookupReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response) { return this->TxnLookup(context, request, response); }));}
    void SetMessageAllocatorFor_TxnLookup(
        ::grpc::MessageAllocator< ::remote::TxnLookupRequest, ::remote::TxnLookupReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::TxnLookupRequest, ::remote::TxnLookupReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TxnLookup(::grpc::ServerContext* /*context*/, const ::remote::TxnLookupRequest* /*request*/, ::remote::TxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TxnLookup(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::TxnLookupRequest* /*request*/, ::remote::TxnLookupReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_NodeInfo() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::NodesInfoRequest, ::remote::NodesInfoReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response) { return this->NodeInfo(context, request, response); }));}
    void SetMessageAllocatorFor_NodeInfo(
        ::grpc::MessageAllocator< ::remote::NodesInfoRequest, ::remote::NodesInfoReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::NodesInfoRequest, ::remote::NodesInfoReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::remote::NodesInfoRequest* /*request*/, ::remote::NodesInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NodeInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::NodesInfoRequest* /*request*/, ::remote::NodesInfoReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Peers() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::remote::PeersReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response) { return this->Peers(context, request, response); }));}
    void SetMessageAllocatorFor_Peers(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::remote::PeersReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::remote::PeersReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Peers(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PeersReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddPeer() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::AddPeerRequest, ::remote::AddPeerReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response) { return this->AddPeer(context, request, response); }));}
    void SetMessageAllocatorFor_AddPeer(
        ::grpc::MessageAllocator< ::remote::AddPeerRequest, ::remote::AddPeerReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::AddPeerRequest, ::remote::AddPeerReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::remote::AddPeerRequest* /*request*/, ::remote::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::AddPeerRequest* /*request*/, ::remote::AddPeerReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PendingBlock() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::remote::PendingBlockReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response) { return this->PendingBlock(context, request, response); }));}
    void SetMessageAllocatorFor_PendingBlock(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::remote::PendingBlockReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::remote::PendingBlockReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingBlock(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PendingBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PendingBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PendingBlockReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BorTxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BorTxnLookup() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::BorTxnLookupRequest, ::remote::BorTxnLookupReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response) { return this->BorTxnLookup(context, request, response); }));}
    void SetMessageAllocatorFor_BorTxnLookup(
        ::grpc::MessageAllocator< ::remote::BorTxnLookupRequest, ::remote::BorTxnLookupReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::BorTxnLookupRequest, ::remote::BorTxnLookupReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BorTxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorTxnLookup(::grpc::ServerContext* /*context*/, const ::remote::BorTxnLookupRequest* /*request*/, ::remote::BorTxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BorTxnLookup(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::BorTxnLookupRequest* /*request*/, ::remote::BorTxnLookupReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BorEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BorEvents() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::remote::BorEventsRequest, ::remote::BorEventsReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response) { return this->BorEvents(context, request, response); }));}
    void SetMessageAllocatorFor_BorEvents(
        ::grpc::MessageAllocator< ::remote::BorEventsRequest, ::remote::BorEventsReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::remote::BorEventsRequest, ::remote::BorEventsReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BorEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorEvents(::grpc::ServerContext* /*context*/, const ::remote::BorEventsRequest* /*request*/, ::remote::BorEventsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BorEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::remote::BorEventsRequest* /*request*/, ::remote::BorEventsReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Etherbase<WithCallbackMethod_NetVersion<WithCallbackMethod_NetPeerCount<WithCallbackMethod_Version<WithCallbackMethod_Syncing<WithCallbackMethod_ProtocolVersion<WithCallbackMethod_ClientVersion<WithCallbackMethod_Subscribe<WithCallbackMethod_SubscribeLogs<WithCallbackMethod_Block<WithCallbackMethod_CanonicalBodyForStorage<WithCallbackMethod_CanonicalHash<WithCallbackMethod_HeaderNumber<WithCallbackMethod_TxnLookup<WithCallbackMethod_NodeInfo<WithCallbackMethod_Peers<WithCallbackMethod_AddPeer<WithCallbackMethod_PendingBlock<WithCallbackMethod_BorTxnLookup<WithCallbackMethod_BorEvents<Service > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Etherbase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Etherbase() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Etherbase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Etherbase(::grpc::ServerContext* /*context*/, const ::remote::EtherbaseRequest* /*request*/, ::remote::EtherbaseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NetVersion() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_NetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetVersion(::grpc::ServerContext* /*context*/, const ::remote::NetVersionRequest* /*request*/, ::remote::NetVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NetPeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NetPeerCount() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_NetPeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetPeerCount(::grpc::ServerContext* /*context*/, const ::remote::NetPeerCountRequest* /*request*/, ::remote::NetPeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Version() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Syncing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Syncing() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Syncing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Syncing(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::SyncingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProtocolVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ProtocolVersion() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ProtocolVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProtocolVersion(::grpc::ServerContext* /*context*/, const ::remote::ProtocolVersionRequest* /*request*/, ::remote::ProtocolVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClientVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClientVersion() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ClientVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientVersion(::grpc::ServerContext* /*context*/, const ::remote::ClientVersionRequest* /*request*/, ::remote::ClientVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Subscribe() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::remote::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::remote::SubscribeReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeLogs() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SubscribeLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeLogs(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::remote::SubscribeLogsReply, ::remote::LogsFilterRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Block() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::remote::BlockRequest* /*request*/, ::remote::BlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CanonicalBodyForStorage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CanonicalBodyForStorage() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_CanonicalBodyForStorage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalBodyForStorage(::grpc::ServerContext* /*context*/, const ::remote::CanonicalBodyForStorageRequest* /*request*/, ::remote::CanonicalBodyForStorageReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CanonicalHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CanonicalHash() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_CanonicalHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalHash(::grpc::ServerContext* /*context*/, const ::remote::CanonicalHashRequest* /*request*/, ::remote::CanonicalHashReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HeaderNumber : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HeaderNumber() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_HeaderNumber() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeaderNumber(::grpc::ServerContext* /*context*/, const ::remote::HeaderNumberRequest* /*request*/, ::remote::HeaderNumberReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TxnLookup() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_TxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TxnLookup(::grpc::ServerContext* /*context*/, const ::remote::TxnLookupRequest* /*request*/, ::remote::TxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeInfo() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::remote::NodesInfoRequest* /*request*/, ::remote::NodesInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Peers() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddPeer() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::remote::AddPeerRequest* /*request*/, ::remote::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PendingBlock() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_PendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingBlock(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PendingBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BorTxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BorTxnLookup() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_BorTxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorTxnLookup(::grpc::ServerContext* /*context*/, const ::remote::BorTxnLookupRequest* /*request*/, ::remote::BorTxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BorEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BorEvents() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_BorEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorEvents(::grpc::ServerContext* /*context*/, const ::remote::BorEventsRequest* /*request*/, ::remote::BorEventsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Etherbase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Etherbase() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Etherbase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Etherbase(::grpc::ServerContext* /*context*/, const ::remote::EtherbaseRequest* /*request*/, ::remote::EtherbaseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEtherbase(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NetVersion() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_NetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetVersion(::grpc::ServerContext* /*context*/, const ::remote::NetVersionRequest* /*request*/, ::remote::NetVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NetPeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NetPeerCount() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_NetPeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetPeerCount(::grpc::ServerContext* /*context*/, const ::remote::NetPeerCountRequest* /*request*/, ::remote::NetPeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNetPeerCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Version() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Syncing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Syncing() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Syncing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Syncing(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::SyncingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSyncing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProtocolVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ProtocolVersion() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ProtocolVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProtocolVersion(::grpc::ServerContext* /*context*/, const ::remote::ProtocolVersionRequest* /*request*/, ::remote::ProtocolVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProtocolVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClientVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClientVersion() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ClientVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientVersion(::grpc::ServerContext* /*context*/, const ::remote::ClientVersionRequest* /*request*/, ::remote::ClientVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClientVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Subscribe() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::remote::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::remote::SubscribeReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeLogs() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SubscribeLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeLogs(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::remote::SubscribeLogsReply, ::remote::LogsFilterRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeLogs(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(8, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Block() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::remote::BlockRequest* /*request*/, ::remote::BlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CanonicalBodyForStorage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CanonicalBodyForStorage() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_CanonicalBodyForStorage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalBodyForStorage(::grpc::ServerContext* /*context*/, const ::remote::CanonicalBodyForStorageRequest* /*request*/, ::remote::CanonicalBodyForStorageReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCanonicalBodyForStorage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CanonicalHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CanonicalHash() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_CanonicalHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalHash(::grpc::ServerContext* /*context*/, const ::remote::CanonicalHashRequest* /*request*/, ::remote::CanonicalHashReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCanonicalHash(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HeaderNumber : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HeaderNumber() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_HeaderNumber() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeaderNumber(::grpc::ServerContext* /*context*/, const ::remote::HeaderNumberRequest* /*request*/, ::remote::HeaderNumberReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHeaderNumber(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TxnLookup() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_TxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TxnLookup(::grpc::ServerContext* /*context*/, const ::remote::TxnLookupRequest* /*request*/, ::remote::TxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTxnLookup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeInfo() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::remote::NodesInfoRequest* /*request*/, ::remote::NodesInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Peers() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddPeer() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::remote::AddPeerRequest* /*request*/, ::remote::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPeer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PendingBlock() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_PendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingBlock(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PendingBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPendingBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BorTxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BorTxnLookup() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_BorTxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorTxnLookup(::grpc::ServerContext* /*context*/, const ::remote::BorTxnLookupRequest* /*request*/, ::remote::BorTxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBorTxnLookup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BorEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BorEvents() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_BorEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorEvents(::grpc::ServerContext* /*context*/, const ::remote::BorEventsRequest* /*request*/, ::remote::BorEventsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBorEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Etherbase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Etherbase() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Etherbase(context, request, response); }));
    }
    ~WithRawCallbackMethod_Etherbase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Etherbase(::grpc::ServerContext* /*context*/, const ::remote::EtherbaseRequest* /*request*/, ::remote::EtherbaseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Etherbase(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_NetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_NetVersion() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NetVersion(context, request, response); }));
    }
    ~WithRawCallbackMethod_NetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetVersion(::grpc::ServerContext* /*context*/, const ::remote::NetVersionRequest* /*request*/, ::remote::NetVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_NetPeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_NetPeerCount() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NetPeerCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_NetPeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetPeerCount(::grpc::ServerContext* /*context*/, const ::remote::NetPeerCountRequest* /*request*/, ::remote::NetPeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NetPeerCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Version() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Version(context, request, response); }));
    }
    ~WithRawCallbackMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Version(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Syncing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Syncing() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Syncing(context, request, response); }));
    }
    ~WithRawCallbackMethod_Syncing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Syncing(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::SyncingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Syncing(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ProtocolVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ProtocolVersion() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ProtocolVersion(context, request, response); }));
    }
    ~WithRawCallbackMethod_ProtocolVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProtocolVersion(::grpc::ServerContext* /*context*/, const ::remote::ProtocolVersionRequest* /*request*/, ::remote::ProtocolVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProtocolVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ClientVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ClientVersion() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClientVersion(context, request, response); }));
    }
    ~WithRawCallbackMethod_ClientVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientVersion(::grpc::ServerContext* /*context*/, const ::remote::ClientVersionRequest* /*request*/, ::remote::ClientVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClientVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->Subscribe(context, request); }));
    }
    ~WithRawCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::remote::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::remote::SubscribeReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Subscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeLogs() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->SubscribeLogs(context); }));
    }
    ~WithRawCallbackMethod_SubscribeLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeLogs(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::remote::SubscribeLogsReply, ::remote::LogsFilterRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SubscribeLogs(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Block() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Block(context, request, response); }));
    }
    ~WithRawCallbackMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::remote::BlockRequest* /*request*/, ::remote::BlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Block(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CanonicalBodyForStorage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CanonicalBodyForStorage() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CanonicalBodyForStorage(context, request, response); }));
    }
    ~WithRawCallbackMethod_CanonicalBodyForStorage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalBodyForStorage(::grpc::ServerContext* /*context*/, const ::remote::CanonicalBodyForStorageRequest* /*request*/, ::remote::CanonicalBodyForStorageReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CanonicalBodyForStorage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CanonicalHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CanonicalHash() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CanonicalHash(context, request, response); }));
    }
    ~WithRawCallbackMethod_CanonicalHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CanonicalHash(::grpc::ServerContext* /*context*/, const ::remote::CanonicalHashRequest* /*request*/, ::remote::CanonicalHashReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CanonicalHash(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HeaderNumber : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HeaderNumber() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HeaderNumber(context, request, response); }));
    }
    ~WithRawCallbackMethod_HeaderNumber() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeaderNumber(::grpc::ServerContext* /*context*/, const ::remote::HeaderNumberRequest* /*request*/, ::remote::HeaderNumberReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HeaderNumber(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TxnLookup() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TxnLookup(context, request, response); }));
    }
    ~WithRawCallbackMethod_TxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TxnLookup(::grpc::ServerContext* /*context*/, const ::remote::TxnLookupRequest* /*request*/, ::remote::TxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TxnLookup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_NodeInfo() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::remote::NodesInfoRequest* /*request*/, ::remote::NodesInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NodeInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Peers() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Peers(context, request, response); }));
    }
    ~WithRawCallbackMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Peers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddPeer() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddPeer(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::remote::AddPeerRequest* /*request*/, ::remote::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PendingBlock() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PendingBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_PendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PendingBlock(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PendingBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PendingBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BorTxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BorTxnLookup() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BorTxnLookup(context, request, response); }));
    }
    ~WithRawCallbackMethod_BorTxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorTxnLookup(::grpc::ServerContext* /*context*/, const ::remote::BorTxnLookupRequest* /*request*/, ::remote::BorTxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BorTxnLookup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BorEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BorEvents() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BorEvents(context, request, response); }));
    }
    ~WithRawCallbackMethod_BorEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BorEvents(::grpc::ServerContext* /*context*/, const ::remote::BorEventsRequest* /*request*/, ::remote::BorEventsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BorEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Etherbase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Etherbase() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::EtherbaseRequest, ::remote::EtherbaseReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::EtherbaseRequest, ::remote::EtherbaseReply>* streamer) {
                       return this->StreamedEtherbase(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Etherbase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Etherbase(::grpc::ServerContext* /*context*/, const ::remote::EtherbaseRequest* /*request*/, ::remote::EtherbaseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEtherbase(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::EtherbaseRequest,::remote::EtherbaseReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NetVersion() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::NetVersionRequest, ::remote::NetVersionReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::NetVersionRequest, ::remote::NetVersionReply>* streamer) {
                       return this->StreamedNetVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NetVersion(::grpc::ServerContext* /*context*/, const ::remote::NetVersionRequest* /*request*/, ::remote::NetVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::NetVersionRequest,::remote::NetVersionReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NetPeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NetPeerCount() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::NetPeerCountRequest, ::remote::NetPeerCountReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::NetPeerCountRequest, ::remote::NetPeerCountReply>* streamer) {
                       return this->StreamedNetPeerCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NetPeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NetPeerCount(::grpc::ServerContext* /*context*/, const ::remote::NetPeerCountRequest* /*request*/, ::remote::NetPeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNetPeerCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::NetPeerCountRequest,::remote::NetPeerCountReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Version() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::types::VersionReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::types::VersionReply>* streamer) {
                       return this->StreamedVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::VersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::types::VersionReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Syncing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Syncing() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::remote::SyncingReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::remote::SyncingReply>* streamer) {
                       return this->StreamedSyncing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Syncing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Syncing(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::SyncingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSyncing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::remote::SyncingReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProtocolVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ProtocolVersion() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::ProtocolVersionRequest, ::remote::ProtocolVersionReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::ProtocolVersionRequest, ::remote::ProtocolVersionReply>* streamer) {
                       return this->StreamedProtocolVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ProtocolVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProtocolVersion(::grpc::ServerContext* /*context*/, const ::remote::ProtocolVersionRequest* /*request*/, ::remote::ProtocolVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProtocolVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::ProtocolVersionRequest,::remote::ProtocolVersionReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClientVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClientVersion() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::ClientVersionRequest, ::remote::ClientVersionReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::ClientVersionRequest, ::remote::ClientVersionReply>* streamer) {
                       return this->StreamedClientVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClientVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClientVersion(::grpc::ServerContext* /*context*/, const ::remote::ClientVersionRequest* /*request*/, ::remote::ClientVersionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClientVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::ClientVersionRequest,::remote::ClientVersionReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Block() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::BlockRequest, ::remote::BlockReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::BlockRequest, ::remote::BlockReply>* streamer) {
                       return this->StreamedBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::remote::BlockRequest* /*request*/, ::remote::BlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::BlockRequest,::remote::BlockReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CanonicalBodyForStorage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CanonicalBodyForStorage() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::CanonicalBodyForStorageRequest, ::remote::CanonicalBodyForStorageReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::CanonicalBodyForStorageRequest, ::remote::CanonicalBodyForStorageReply>* streamer) {
                       return this->StreamedCanonicalBodyForStorage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CanonicalBodyForStorage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CanonicalBodyForStorage(::grpc::ServerContext* /*context*/, const ::remote::CanonicalBodyForStorageRequest* /*request*/, ::remote::CanonicalBodyForStorageReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCanonicalBodyForStorage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::CanonicalBodyForStorageRequest,::remote::CanonicalBodyForStorageReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CanonicalHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CanonicalHash() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::CanonicalHashRequest, ::remote::CanonicalHashReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::CanonicalHashRequest, ::remote::CanonicalHashReply>* streamer) {
                       return this->StreamedCanonicalHash(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CanonicalHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CanonicalHash(::grpc::ServerContext* /*context*/, const ::remote::CanonicalHashRequest* /*request*/, ::remote::CanonicalHashReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCanonicalHash(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::CanonicalHashRequest,::remote::CanonicalHashReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HeaderNumber : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HeaderNumber() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::HeaderNumberRequest, ::remote::HeaderNumberReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::HeaderNumberRequest, ::remote::HeaderNumberReply>* streamer) {
                       return this->StreamedHeaderNumber(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HeaderNumber() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HeaderNumber(::grpc::ServerContext* /*context*/, const ::remote::HeaderNumberRequest* /*request*/, ::remote::HeaderNumberReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHeaderNumber(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::HeaderNumberRequest,::remote::HeaderNumberReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TxnLookup() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::TxnLookupRequest, ::remote::TxnLookupReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::TxnLookupRequest, ::remote::TxnLookupReply>* streamer) {
                       return this->StreamedTxnLookup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TxnLookup(::grpc::ServerContext* /*context*/, const ::remote::TxnLookupRequest* /*request*/, ::remote::TxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTxnLookup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::TxnLookupRequest,::remote::TxnLookupReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeInfo() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::NodesInfoRequest, ::remote::NodesInfoReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::NodesInfoRequest, ::remote::NodesInfoReply>* streamer) {
                       return this->StreamedNodeInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::remote::NodesInfoRequest* /*request*/, ::remote::NodesInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::NodesInfoRequest,::remote::NodesInfoReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Peers() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::remote::PeersReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::remote::PeersReply>* streamer) {
                       return this->StreamedPeers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPeers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::remote::PeersReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddPeer() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::AddPeerRequest, ::remote::AddPeerReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::AddPeerRequest, ::remote::AddPeerReply>* streamer) {
                       return this->StreamedAddPeer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::remote::AddPeerRequest* /*request*/, ::remote::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddPeer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::AddPeerRequest,::remote::AddPeerReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PendingBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PendingBlock() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::remote::PendingBlockReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::remote::PendingBlockReply>* streamer) {
                       return this->StreamedPendingBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PendingBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PendingBlock(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::remote::PendingBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPendingBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::remote::PendingBlockReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BorTxnLookup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BorTxnLookup() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::BorTxnLookupRequest, ::remote::BorTxnLookupReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::BorTxnLookupRequest, ::remote::BorTxnLookupReply>* streamer) {
                       return this->StreamedBorTxnLookup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BorTxnLookup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BorTxnLookup(::grpc::ServerContext* /*context*/, const ::remote::BorTxnLookupRequest* /*request*/, ::remote::BorTxnLookupReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBorTxnLookup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::BorTxnLookupRequest,::remote::BorTxnLookupReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BorEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BorEvents() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::remote::BorEventsRequest, ::remote::BorEventsReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::remote::BorEventsRequest, ::remote::BorEventsReply>* streamer) {
                       return this->StreamedBorEvents(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BorEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BorEvents(::grpc::ServerContext* /*context*/, const ::remote::BorEventsRequest* /*request*/, ::remote::BorEventsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBorEvents(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::remote::BorEventsRequest,::remote::BorEventsReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Etherbase<WithStreamedUnaryMethod_NetVersion<WithStreamedUnaryMethod_NetPeerCount<WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_Syncing<WithStreamedUnaryMethod_ProtocolVersion<WithStreamedUnaryMethod_ClientVersion<WithStreamedUnaryMethod_Block<WithStreamedUnaryMethod_CanonicalBodyForStorage<WithStreamedUnaryMethod_CanonicalHash<WithStreamedUnaryMethod_HeaderNumber<WithStreamedUnaryMethod_TxnLookup<WithStreamedUnaryMethod_NodeInfo<WithStreamedUnaryMethod_Peers<WithStreamedUnaryMethod_AddPeer<WithStreamedUnaryMethod_PendingBlock<WithStreamedUnaryMethod_BorTxnLookup<WithStreamedUnaryMethod_BorEvents<Service > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Subscribe() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::remote::SubscribeRequest, ::remote::SubscribeReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::remote::SubscribeRequest, ::remote::SubscribeReply>* streamer) {
                       return this->StreamedSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::remote::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::remote::SubscribeReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::remote::SubscribeRequest,::remote::SubscribeReply>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Subscribe<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Etherbase<WithStreamedUnaryMethod_NetVersion<WithStreamedUnaryMethod_NetPeerCount<WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_Syncing<WithStreamedUnaryMethod_ProtocolVersion<WithStreamedUnaryMethod_ClientVersion<WithSplitStreamingMethod_Subscribe<WithStreamedUnaryMethod_Block<WithStreamedUnaryMethod_CanonicalBodyForStorage<WithStreamedUnaryMethod_CanonicalHash<WithStreamedUnaryMethod_HeaderNumber<WithStreamedUnaryMethod_TxnLookup<WithStreamedUnaryMethod_NodeInfo<WithStreamedUnaryMethod_Peers<WithStreamedUnaryMethod_AddPeer<WithStreamedUnaryMethod_PendingBlock<WithStreamedUnaryMethod_BorTxnLookup<WithStreamedUnaryMethod_BorEvents<Service > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace remote


#endif  // GRPC_remote_2fethbackend_2eproto__INCLUDED
