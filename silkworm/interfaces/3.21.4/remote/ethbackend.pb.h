// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remote/ethbackend.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_remote_2fethbackend_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_remote_2fethbackend_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_remote_2fethbackend_2eproto;
namespace remote {
class BlockReply;
struct BlockReplyDefaultTypeInternal;
extern BlockReplyDefaultTypeInternal _BlockReply_default_instance_;
class BlockRequest;
struct BlockRequestDefaultTypeInternal;
extern BlockRequestDefaultTypeInternal _BlockRequest_default_instance_;
class ClientVersionReply;
struct ClientVersionReplyDefaultTypeInternal;
extern ClientVersionReplyDefaultTypeInternal _ClientVersionReply_default_instance_;
class ClientVersionRequest;
struct ClientVersionRequestDefaultTypeInternal;
extern ClientVersionRequestDefaultTypeInternal _ClientVersionRequest_default_instance_;
class EngineForkChoiceState;
struct EngineForkChoiceStateDefaultTypeInternal;
extern EngineForkChoiceStateDefaultTypeInternal _EngineForkChoiceState_default_instance_;
class EngineForkChoiceUpdatedRequest;
struct EngineForkChoiceUpdatedRequestDefaultTypeInternal;
extern EngineForkChoiceUpdatedRequestDefaultTypeInternal _EngineForkChoiceUpdatedRequest_default_instance_;
class EngineForkChoiceUpdatedResponse;
struct EngineForkChoiceUpdatedResponseDefaultTypeInternal;
extern EngineForkChoiceUpdatedResponseDefaultTypeInternal _EngineForkChoiceUpdatedResponse_default_instance_;
class EngineGetPayloadBodiesByHashV1Request;
struct EngineGetPayloadBodiesByHashV1RequestDefaultTypeInternal;
extern EngineGetPayloadBodiesByHashV1RequestDefaultTypeInternal _EngineGetPayloadBodiesByHashV1Request_default_instance_;
class EngineGetPayloadBodiesByRangeV1Request;
struct EngineGetPayloadBodiesByRangeV1RequestDefaultTypeInternal;
extern EngineGetPayloadBodiesByRangeV1RequestDefaultTypeInternal _EngineGetPayloadBodiesByRangeV1Request_default_instance_;
class EngineGetPayloadBodiesV1Response;
struct EngineGetPayloadBodiesV1ResponseDefaultTypeInternal;
extern EngineGetPayloadBodiesV1ResponseDefaultTypeInternal _EngineGetPayloadBodiesV1Response_default_instance_;
class EngineGetPayloadRequest;
struct EngineGetPayloadRequestDefaultTypeInternal;
extern EngineGetPayloadRequestDefaultTypeInternal _EngineGetPayloadRequest_default_instance_;
class EngineGetPayloadResponse;
struct EngineGetPayloadResponseDefaultTypeInternal;
extern EngineGetPayloadResponseDefaultTypeInternal _EngineGetPayloadResponse_default_instance_;
class EnginePayloadAttributes;
struct EnginePayloadAttributesDefaultTypeInternal;
extern EnginePayloadAttributesDefaultTypeInternal _EnginePayloadAttributes_default_instance_;
class EnginePayloadStatus;
struct EnginePayloadStatusDefaultTypeInternal;
extern EnginePayloadStatusDefaultTypeInternal _EnginePayloadStatus_default_instance_;
class EtherbaseReply;
struct EtherbaseReplyDefaultTypeInternal;
extern EtherbaseReplyDefaultTypeInternal _EtherbaseReply_default_instance_;
class EtherbaseRequest;
struct EtherbaseRequestDefaultTypeInternal;
extern EtherbaseRequestDefaultTypeInternal _EtherbaseRequest_default_instance_;
class LogsFilterRequest;
struct LogsFilterRequestDefaultTypeInternal;
extern LogsFilterRequestDefaultTypeInternal _LogsFilterRequest_default_instance_;
class NetPeerCountReply;
struct NetPeerCountReplyDefaultTypeInternal;
extern NetPeerCountReplyDefaultTypeInternal _NetPeerCountReply_default_instance_;
class NetPeerCountRequest;
struct NetPeerCountRequestDefaultTypeInternal;
extern NetPeerCountRequestDefaultTypeInternal _NetPeerCountRequest_default_instance_;
class NetVersionReply;
struct NetVersionReplyDefaultTypeInternal;
extern NetVersionReplyDefaultTypeInternal _NetVersionReply_default_instance_;
class NetVersionRequest;
struct NetVersionRequestDefaultTypeInternal;
extern NetVersionRequestDefaultTypeInternal _NetVersionRequest_default_instance_;
class NodesInfoReply;
struct NodesInfoReplyDefaultTypeInternal;
extern NodesInfoReplyDefaultTypeInternal _NodesInfoReply_default_instance_;
class NodesInfoRequest;
struct NodesInfoRequestDefaultTypeInternal;
extern NodesInfoRequestDefaultTypeInternal _NodesInfoRequest_default_instance_;
class PeersReply;
struct PeersReplyDefaultTypeInternal;
extern PeersReplyDefaultTypeInternal _PeersReply_default_instance_;
class PendingBlockReply;
struct PendingBlockReplyDefaultTypeInternal;
extern PendingBlockReplyDefaultTypeInternal _PendingBlockReply_default_instance_;
class ProtocolVersionReply;
struct ProtocolVersionReplyDefaultTypeInternal;
extern ProtocolVersionReplyDefaultTypeInternal _ProtocolVersionReply_default_instance_;
class ProtocolVersionRequest;
struct ProtocolVersionRequestDefaultTypeInternal;
extern ProtocolVersionRequestDefaultTypeInternal _ProtocolVersionRequest_default_instance_;
class SubscribeLogsReply;
struct SubscribeLogsReplyDefaultTypeInternal;
extern SubscribeLogsReplyDefaultTypeInternal _SubscribeLogsReply_default_instance_;
class SubscribeReply;
struct SubscribeReplyDefaultTypeInternal;
extern SubscribeReplyDefaultTypeInternal _SubscribeReply_default_instance_;
class SubscribeRequest;
struct SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
class TxnLookupReply;
struct TxnLookupReplyDefaultTypeInternal;
extern TxnLookupReplyDefaultTypeInternal _TxnLookupReply_default_instance_;
class TxnLookupRequest;
struct TxnLookupRequestDefaultTypeInternal;
extern TxnLookupRequestDefaultTypeInternal _TxnLookupRequest_default_instance_;
}  // namespace remote
PROTOBUF_NAMESPACE_OPEN
template<> ::remote::BlockReply* Arena::CreateMaybeMessage<::remote::BlockReply>(Arena*);
template<> ::remote::BlockRequest* Arena::CreateMaybeMessage<::remote::BlockRequest>(Arena*);
template<> ::remote::ClientVersionReply* Arena::CreateMaybeMessage<::remote::ClientVersionReply>(Arena*);
template<> ::remote::ClientVersionRequest* Arena::CreateMaybeMessage<::remote::ClientVersionRequest>(Arena*);
template<> ::remote::EngineForkChoiceState* Arena::CreateMaybeMessage<::remote::EngineForkChoiceState>(Arena*);
template<> ::remote::EngineForkChoiceUpdatedRequest* Arena::CreateMaybeMessage<::remote::EngineForkChoiceUpdatedRequest>(Arena*);
template<> ::remote::EngineForkChoiceUpdatedResponse* Arena::CreateMaybeMessage<::remote::EngineForkChoiceUpdatedResponse>(Arena*);
template<> ::remote::EngineGetPayloadBodiesByHashV1Request* Arena::CreateMaybeMessage<::remote::EngineGetPayloadBodiesByHashV1Request>(Arena*);
template<> ::remote::EngineGetPayloadBodiesByRangeV1Request* Arena::CreateMaybeMessage<::remote::EngineGetPayloadBodiesByRangeV1Request>(Arena*);
template<> ::remote::EngineGetPayloadBodiesV1Response* Arena::CreateMaybeMessage<::remote::EngineGetPayloadBodiesV1Response>(Arena*);
template<> ::remote::EngineGetPayloadRequest* Arena::CreateMaybeMessage<::remote::EngineGetPayloadRequest>(Arena*);
template<> ::remote::EngineGetPayloadResponse* Arena::CreateMaybeMessage<::remote::EngineGetPayloadResponse>(Arena*);
template<> ::remote::EnginePayloadAttributes* Arena::CreateMaybeMessage<::remote::EnginePayloadAttributes>(Arena*);
template<> ::remote::EnginePayloadStatus* Arena::CreateMaybeMessage<::remote::EnginePayloadStatus>(Arena*);
template<> ::remote::EtherbaseReply* Arena::CreateMaybeMessage<::remote::EtherbaseReply>(Arena*);
template<> ::remote::EtherbaseRequest* Arena::CreateMaybeMessage<::remote::EtherbaseRequest>(Arena*);
template<> ::remote::LogsFilterRequest* Arena::CreateMaybeMessage<::remote::LogsFilterRequest>(Arena*);
template<> ::remote::NetPeerCountReply* Arena::CreateMaybeMessage<::remote::NetPeerCountReply>(Arena*);
template<> ::remote::NetPeerCountRequest* Arena::CreateMaybeMessage<::remote::NetPeerCountRequest>(Arena*);
template<> ::remote::NetVersionReply* Arena::CreateMaybeMessage<::remote::NetVersionReply>(Arena*);
template<> ::remote::NetVersionRequest* Arena::CreateMaybeMessage<::remote::NetVersionRequest>(Arena*);
template<> ::remote::NodesInfoReply* Arena::CreateMaybeMessage<::remote::NodesInfoReply>(Arena*);
template<> ::remote::NodesInfoRequest* Arena::CreateMaybeMessage<::remote::NodesInfoRequest>(Arena*);
template<> ::remote::PeersReply* Arena::CreateMaybeMessage<::remote::PeersReply>(Arena*);
template<> ::remote::PendingBlockReply* Arena::CreateMaybeMessage<::remote::PendingBlockReply>(Arena*);
template<> ::remote::ProtocolVersionReply* Arena::CreateMaybeMessage<::remote::ProtocolVersionReply>(Arena*);
template<> ::remote::ProtocolVersionRequest* Arena::CreateMaybeMessage<::remote::ProtocolVersionRequest>(Arena*);
template<> ::remote::SubscribeLogsReply* Arena::CreateMaybeMessage<::remote::SubscribeLogsReply>(Arena*);
template<> ::remote::SubscribeReply* Arena::CreateMaybeMessage<::remote::SubscribeReply>(Arena*);
template<> ::remote::SubscribeRequest* Arena::CreateMaybeMessage<::remote::SubscribeRequest>(Arena*);
template<> ::remote::TxnLookupReply* Arena::CreateMaybeMessage<::remote::TxnLookupReply>(Arena*);
template<> ::remote::TxnLookupRequest* Arena::CreateMaybeMessage<::remote::TxnLookupRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace remote {

enum Event : int {
  HEADER = 0,
  PENDING_LOGS = 1,
  PENDING_BLOCK = 2,
  NEW_SNAPSHOT = 3,
  Event_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Event_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Event_IsValid(int value);
constexpr Event Event_MIN = HEADER;
constexpr Event Event_MAX = NEW_SNAPSHOT;
constexpr int Event_ARRAYSIZE = Event_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Event_descriptor();
template<typename T>
inline const std::string& Event_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Event>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Event_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Event_descriptor(), enum_t_value);
}
inline bool Event_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Event* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Event>(
    Event_descriptor(), name, value);
}
enum EngineStatus : int {
  VALID = 0,
  INVALID = 1,
  SYNCING = 2,
  ACCEPTED = 3,
  INVALID_BLOCK_HASH = 4,
  EngineStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EngineStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EngineStatus_IsValid(int value);
constexpr EngineStatus EngineStatus_MIN = VALID;
constexpr EngineStatus EngineStatus_MAX = INVALID_BLOCK_HASH;
constexpr int EngineStatus_ARRAYSIZE = EngineStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EngineStatus_descriptor();
template<typename T>
inline const std::string& EngineStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EngineStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EngineStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EngineStatus_descriptor(), enum_t_value);
}
inline bool EngineStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EngineStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EngineStatus>(
    EngineStatus_descriptor(), name, value);
}
// ===================================================================

class EtherbaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.EtherbaseRequest) */ {
 public:
  inline EtherbaseRequest() : EtherbaseRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EtherbaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EtherbaseRequest(const EtherbaseRequest& from);
  EtherbaseRequest(EtherbaseRequest&& from) noexcept
    : EtherbaseRequest() {
    *this = ::std::move(from);
  }

  inline EtherbaseRequest& operator=(const EtherbaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EtherbaseRequest& operator=(EtherbaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EtherbaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EtherbaseRequest* internal_default_instance() {
    return reinterpret_cast<const EtherbaseRequest*>(
               &_EtherbaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EtherbaseRequest& a, EtherbaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EtherbaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EtherbaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EtherbaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EtherbaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EtherbaseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EtherbaseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EtherbaseRequest";
  }
  protected:
  explicit EtherbaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.EtherbaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EtherbaseReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EtherbaseReply) */ {
 public:
  inline EtherbaseReply() : EtherbaseReply(nullptr) {}
  ~EtherbaseReply() override;
  explicit PROTOBUF_CONSTEXPR EtherbaseReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EtherbaseReply(const EtherbaseReply& from);
  EtherbaseReply(EtherbaseReply&& from) noexcept
    : EtherbaseReply() {
    *this = ::std::move(from);
  }

  inline EtherbaseReply& operator=(const EtherbaseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline EtherbaseReply& operator=(EtherbaseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EtherbaseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const EtherbaseReply* internal_default_instance() {
    return reinterpret_cast<const EtherbaseReply*>(
               &_EtherbaseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EtherbaseReply& a, EtherbaseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(EtherbaseReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EtherbaseReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EtherbaseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EtherbaseReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EtherbaseReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EtherbaseReply& from) {
    EtherbaseReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EtherbaseReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EtherbaseReply";
  }
  protected:
  explicit EtherbaseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // .types.H160 address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::types::H160& address() const;
  PROTOBUF_NODISCARD ::types::H160* release_address();
  ::types::H160* mutable_address();
  void set_allocated_address(::types::H160* address);
  private:
  const ::types::H160& _internal_address() const;
  ::types::H160* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::types::H160* address);
  ::types::H160* unsafe_arena_release_address();

  // @@protoc_insertion_point(class_scope:remote.EtherbaseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H160* address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetVersionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.NetVersionRequest) */ {
 public:
  inline NetVersionRequest() : NetVersionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NetVersionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetVersionRequest(const NetVersionRequest& from);
  NetVersionRequest(NetVersionRequest&& from) noexcept
    : NetVersionRequest() {
    *this = ::std::move(from);
  }

  inline NetVersionRequest& operator=(const NetVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetVersionRequest& operator=(NetVersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetVersionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetVersionRequest* internal_default_instance() {
    return reinterpret_cast<const NetVersionRequest*>(
               &_NetVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NetVersionRequest& a, NetVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NetVersionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetVersionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NetVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NetVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetVersionRequest";
  }
  protected:
  explicit NetVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.NetVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetVersionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NetVersionReply) */ {
 public:
  inline NetVersionReply() : NetVersionReply(nullptr) {}
  ~NetVersionReply() override;
  explicit PROTOBUF_CONSTEXPR NetVersionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetVersionReply(const NetVersionReply& from);
  NetVersionReply(NetVersionReply&& from) noexcept
    : NetVersionReply() {
    *this = ::std::move(from);
  }

  inline NetVersionReply& operator=(const NetVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetVersionReply& operator=(NetVersionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetVersionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetVersionReply* internal_default_instance() {
    return reinterpret_cast<const NetVersionReply*>(
               &_NetVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NetVersionReply& a, NetVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NetVersionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetVersionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetVersionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetVersionReply& from) {
    NetVersionReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetVersionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetVersionReply";
  }
  protected:
  explicit NetVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.NetVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetPeerCountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.NetPeerCountRequest) */ {
 public:
  inline NetPeerCountRequest() : NetPeerCountRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NetPeerCountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetPeerCountRequest(const NetPeerCountRequest& from);
  NetPeerCountRequest(NetPeerCountRequest&& from) noexcept
    : NetPeerCountRequest() {
    *this = ::std::move(from);
  }

  inline NetPeerCountRequest& operator=(const NetPeerCountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetPeerCountRequest& operator=(NetPeerCountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetPeerCountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetPeerCountRequest* internal_default_instance() {
    return reinterpret_cast<const NetPeerCountRequest*>(
               &_NetPeerCountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NetPeerCountRequest& a, NetPeerCountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NetPeerCountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetPeerCountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetPeerCountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetPeerCountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NetPeerCountRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NetPeerCountRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetPeerCountRequest";
  }
  protected:
  explicit NetPeerCountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.NetPeerCountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetPeerCountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NetPeerCountReply) */ {
 public:
  inline NetPeerCountReply() : NetPeerCountReply(nullptr) {}
  ~NetPeerCountReply() override;
  explicit PROTOBUF_CONSTEXPR NetPeerCountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetPeerCountReply(const NetPeerCountReply& from);
  NetPeerCountReply(NetPeerCountReply&& from) noexcept
    : NetPeerCountReply() {
    *this = ::std::move(from);
  }

  inline NetPeerCountReply& operator=(const NetPeerCountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetPeerCountReply& operator=(NetPeerCountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetPeerCountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetPeerCountReply* internal_default_instance() {
    return reinterpret_cast<const NetPeerCountReply*>(
               &_NetPeerCountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NetPeerCountReply& a, NetPeerCountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NetPeerCountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetPeerCountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetPeerCountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetPeerCountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetPeerCountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetPeerCountReply& from) {
    NetPeerCountReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetPeerCountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetPeerCountReply";
  }
  protected:
  explicit NetPeerCountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // uint64 count = 1;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.NetPeerCountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EngineGetPayloadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EngineGetPayloadRequest) */ {
 public:
  inline EngineGetPayloadRequest() : EngineGetPayloadRequest(nullptr) {}
  ~EngineGetPayloadRequest() override;
  explicit PROTOBUF_CONSTEXPR EngineGetPayloadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineGetPayloadRequest(const EngineGetPayloadRequest& from);
  EngineGetPayloadRequest(EngineGetPayloadRequest&& from) noexcept
    : EngineGetPayloadRequest() {
    *this = ::std::move(from);
  }

  inline EngineGetPayloadRequest& operator=(const EngineGetPayloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineGetPayloadRequest& operator=(EngineGetPayloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineGetPayloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineGetPayloadRequest* internal_default_instance() {
    return reinterpret_cast<const EngineGetPayloadRequest*>(
               &_EngineGetPayloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EngineGetPayloadRequest& a, EngineGetPayloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineGetPayloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineGetPayloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineGetPayloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineGetPayloadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineGetPayloadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EngineGetPayloadRequest& from) {
    EngineGetPayloadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineGetPayloadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EngineGetPayloadRequest";
  }
  protected:
  explicit EngineGetPayloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadIdFieldNumber = 1,
  };
  // uint64 payload_id = 1;
  void clear_payload_id();
  uint64_t payload_id() const;
  void set_payload_id(uint64_t value);
  private:
  uint64_t _internal_payload_id() const;
  void _internal_set_payload_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.EngineGetPayloadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t payload_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EnginePayloadStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EnginePayloadStatus) */ {
 public:
  inline EnginePayloadStatus() : EnginePayloadStatus(nullptr) {}
  ~EnginePayloadStatus() override;
  explicit PROTOBUF_CONSTEXPR EnginePayloadStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnginePayloadStatus(const EnginePayloadStatus& from);
  EnginePayloadStatus(EnginePayloadStatus&& from) noexcept
    : EnginePayloadStatus() {
    *this = ::std::move(from);
  }

  inline EnginePayloadStatus& operator=(const EnginePayloadStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnginePayloadStatus& operator=(EnginePayloadStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnginePayloadStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnginePayloadStatus* internal_default_instance() {
    return reinterpret_cast<const EnginePayloadStatus*>(
               &_EnginePayloadStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EnginePayloadStatus& a, EnginePayloadStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(EnginePayloadStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnginePayloadStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnginePayloadStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnginePayloadStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnginePayloadStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnginePayloadStatus& from) {
    EnginePayloadStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnginePayloadStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EnginePayloadStatus";
  }
  protected:
  explicit EnginePayloadStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidationErrorFieldNumber = 3,
    kLatestValidHashFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string validation_error = 3;
  void clear_validation_error();
  const std::string& validation_error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_validation_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_validation_error();
  PROTOBUF_NODISCARD std::string* release_validation_error();
  void set_allocated_validation_error(std::string* validation_error);
  private:
  const std::string& _internal_validation_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validation_error(const std::string& value);
  std::string* _internal_mutable_validation_error();
  public:

  // .types.H256 latest_valid_hash = 2;
  bool has_latest_valid_hash() const;
  private:
  bool _internal_has_latest_valid_hash() const;
  public:
  void clear_latest_valid_hash();
  const ::types::H256& latest_valid_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_latest_valid_hash();
  ::types::H256* mutable_latest_valid_hash();
  void set_allocated_latest_valid_hash(::types::H256* latest_valid_hash);
  private:
  const ::types::H256& _internal_latest_valid_hash() const;
  ::types::H256* _internal_mutable_latest_valid_hash();
  public:
  void unsafe_arena_set_allocated_latest_valid_hash(
      ::types::H256* latest_valid_hash);
  ::types::H256* unsafe_arena_release_latest_valid_hash();

  // .remote.EngineStatus status = 1;
  void clear_status();
  ::remote::EngineStatus status() const;
  void set_status(::remote::EngineStatus value);
  private:
  ::remote::EngineStatus _internal_status() const;
  void _internal_set_status(::remote::EngineStatus value);
  public:

  // @@protoc_insertion_point(class_scope:remote.EnginePayloadStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validation_error_;
    ::types::H256* latest_valid_hash_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EnginePayloadAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EnginePayloadAttributes) */ {
 public:
  inline EnginePayloadAttributes() : EnginePayloadAttributes(nullptr) {}
  ~EnginePayloadAttributes() override;
  explicit PROTOBUF_CONSTEXPR EnginePayloadAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnginePayloadAttributes(const EnginePayloadAttributes& from);
  EnginePayloadAttributes(EnginePayloadAttributes&& from) noexcept
    : EnginePayloadAttributes() {
    *this = ::std::move(from);
  }

  inline EnginePayloadAttributes& operator=(const EnginePayloadAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnginePayloadAttributes& operator=(EnginePayloadAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnginePayloadAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnginePayloadAttributes* internal_default_instance() {
    return reinterpret_cast<const EnginePayloadAttributes*>(
               &_EnginePayloadAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EnginePayloadAttributes& a, EnginePayloadAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(EnginePayloadAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnginePayloadAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnginePayloadAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnginePayloadAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnginePayloadAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnginePayloadAttributes& from) {
    EnginePayloadAttributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnginePayloadAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EnginePayloadAttributes";
  }
  protected:
  explicit EnginePayloadAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWithdrawalsFieldNumber = 5,
    kPrevRandaoFieldNumber = 3,
    kSuggestedFeeRecipientFieldNumber = 4,
    kTimestampFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // repeated .types.Withdrawal withdrawals = 5;
  int withdrawals_size() const;
  private:
  int _internal_withdrawals_size() const;
  public:
  void clear_withdrawals();
  ::types::Withdrawal* mutable_withdrawals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >*
      mutable_withdrawals();
  private:
  const ::types::Withdrawal& _internal_withdrawals(int index) const;
  ::types::Withdrawal* _internal_add_withdrawals();
  public:
  const ::types::Withdrawal& withdrawals(int index) const;
  ::types::Withdrawal* add_withdrawals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >&
      withdrawals() const;

  // .types.H256 prev_randao = 3;
  bool has_prev_randao() const;
  private:
  bool _internal_has_prev_randao() const;
  public:
  void clear_prev_randao();
  const ::types::H256& prev_randao() const;
  PROTOBUF_NODISCARD ::types::H256* release_prev_randao();
  ::types::H256* mutable_prev_randao();
  void set_allocated_prev_randao(::types::H256* prev_randao);
  private:
  const ::types::H256& _internal_prev_randao() const;
  ::types::H256* _internal_mutable_prev_randao();
  public:
  void unsafe_arena_set_allocated_prev_randao(
      ::types::H256* prev_randao);
  ::types::H256* unsafe_arena_release_prev_randao();

  // .types.H160 suggested_fee_recipient = 4;
  bool has_suggested_fee_recipient() const;
  private:
  bool _internal_has_suggested_fee_recipient() const;
  public:
  void clear_suggested_fee_recipient();
  const ::types::H160& suggested_fee_recipient() const;
  PROTOBUF_NODISCARD ::types::H160* release_suggested_fee_recipient();
  ::types::H160* mutable_suggested_fee_recipient();
  void set_allocated_suggested_fee_recipient(::types::H160* suggested_fee_recipient);
  private:
  const ::types::H160& _internal_suggested_fee_recipient() const;
  ::types::H160* _internal_mutable_suggested_fee_recipient();
  public:
  void unsafe_arena_set_allocated_suggested_fee_recipient(
      ::types::H160* suggested_fee_recipient);
  ::types::H160* unsafe_arena_release_suggested_fee_recipient();

  // uint64 timestamp = 2;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 version = 1;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.EnginePayloadAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal > withdrawals_;
    ::types::H256* prev_randao_;
    ::types::H160* suggested_fee_recipient_;
    uint64_t timestamp_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EngineForkChoiceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EngineForkChoiceState) */ {
 public:
  inline EngineForkChoiceState() : EngineForkChoiceState(nullptr) {}
  ~EngineForkChoiceState() override;
  explicit PROTOBUF_CONSTEXPR EngineForkChoiceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineForkChoiceState(const EngineForkChoiceState& from);
  EngineForkChoiceState(EngineForkChoiceState&& from) noexcept
    : EngineForkChoiceState() {
    *this = ::std::move(from);
  }

  inline EngineForkChoiceState& operator=(const EngineForkChoiceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineForkChoiceState& operator=(EngineForkChoiceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineForkChoiceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineForkChoiceState* internal_default_instance() {
    return reinterpret_cast<const EngineForkChoiceState*>(
               &_EngineForkChoiceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EngineForkChoiceState& a, EngineForkChoiceState& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineForkChoiceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineForkChoiceState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineForkChoiceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineForkChoiceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineForkChoiceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EngineForkChoiceState& from) {
    EngineForkChoiceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineForkChoiceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EngineForkChoiceState";
  }
  protected:
  explicit EngineForkChoiceState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadBlockHashFieldNumber = 1,
    kSafeBlockHashFieldNumber = 2,
    kFinalizedBlockHashFieldNumber = 3,
  };
  // .types.H256 head_block_hash = 1;
  bool has_head_block_hash() const;
  private:
  bool _internal_has_head_block_hash() const;
  public:
  void clear_head_block_hash();
  const ::types::H256& head_block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_head_block_hash();
  ::types::H256* mutable_head_block_hash();
  void set_allocated_head_block_hash(::types::H256* head_block_hash);
  private:
  const ::types::H256& _internal_head_block_hash() const;
  ::types::H256* _internal_mutable_head_block_hash();
  public:
  void unsafe_arena_set_allocated_head_block_hash(
      ::types::H256* head_block_hash);
  ::types::H256* unsafe_arena_release_head_block_hash();

  // .types.H256 safe_block_hash = 2;
  bool has_safe_block_hash() const;
  private:
  bool _internal_has_safe_block_hash() const;
  public:
  void clear_safe_block_hash();
  const ::types::H256& safe_block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_safe_block_hash();
  ::types::H256* mutable_safe_block_hash();
  void set_allocated_safe_block_hash(::types::H256* safe_block_hash);
  private:
  const ::types::H256& _internal_safe_block_hash() const;
  ::types::H256* _internal_mutable_safe_block_hash();
  public:
  void unsafe_arena_set_allocated_safe_block_hash(
      ::types::H256* safe_block_hash);
  ::types::H256* unsafe_arena_release_safe_block_hash();

  // .types.H256 finalized_block_hash = 3;
  bool has_finalized_block_hash() const;
  private:
  bool _internal_has_finalized_block_hash() const;
  public:
  void clear_finalized_block_hash();
  const ::types::H256& finalized_block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_finalized_block_hash();
  ::types::H256* mutable_finalized_block_hash();
  void set_allocated_finalized_block_hash(::types::H256* finalized_block_hash);
  private:
  const ::types::H256& _internal_finalized_block_hash() const;
  ::types::H256* _internal_mutable_finalized_block_hash();
  public:
  void unsafe_arena_set_allocated_finalized_block_hash(
      ::types::H256* finalized_block_hash);
  ::types::H256* unsafe_arena_release_finalized_block_hash();

  // @@protoc_insertion_point(class_scope:remote.EngineForkChoiceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H256* head_block_hash_;
    ::types::H256* safe_block_hash_;
    ::types::H256* finalized_block_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EngineForkChoiceUpdatedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EngineForkChoiceUpdatedRequest) */ {
 public:
  inline EngineForkChoiceUpdatedRequest() : EngineForkChoiceUpdatedRequest(nullptr) {}
  ~EngineForkChoiceUpdatedRequest() override;
  explicit PROTOBUF_CONSTEXPR EngineForkChoiceUpdatedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineForkChoiceUpdatedRequest(const EngineForkChoiceUpdatedRequest& from);
  EngineForkChoiceUpdatedRequest(EngineForkChoiceUpdatedRequest&& from) noexcept
    : EngineForkChoiceUpdatedRequest() {
    *this = ::std::move(from);
  }

  inline EngineForkChoiceUpdatedRequest& operator=(const EngineForkChoiceUpdatedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineForkChoiceUpdatedRequest& operator=(EngineForkChoiceUpdatedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineForkChoiceUpdatedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineForkChoiceUpdatedRequest* internal_default_instance() {
    return reinterpret_cast<const EngineForkChoiceUpdatedRequest*>(
               &_EngineForkChoiceUpdatedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EngineForkChoiceUpdatedRequest& a, EngineForkChoiceUpdatedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineForkChoiceUpdatedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineForkChoiceUpdatedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineForkChoiceUpdatedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineForkChoiceUpdatedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineForkChoiceUpdatedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EngineForkChoiceUpdatedRequest& from) {
    EngineForkChoiceUpdatedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineForkChoiceUpdatedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EngineForkChoiceUpdatedRequest";
  }
  protected:
  explicit EngineForkChoiceUpdatedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForkchoiceStateFieldNumber = 1,
    kPayloadAttributesFieldNumber = 2,
  };
  // .remote.EngineForkChoiceState forkchoice_state = 1;
  bool has_forkchoice_state() const;
  private:
  bool _internal_has_forkchoice_state() const;
  public:
  void clear_forkchoice_state();
  const ::remote::EngineForkChoiceState& forkchoice_state() const;
  PROTOBUF_NODISCARD ::remote::EngineForkChoiceState* release_forkchoice_state();
  ::remote::EngineForkChoiceState* mutable_forkchoice_state();
  void set_allocated_forkchoice_state(::remote::EngineForkChoiceState* forkchoice_state);
  private:
  const ::remote::EngineForkChoiceState& _internal_forkchoice_state() const;
  ::remote::EngineForkChoiceState* _internal_mutable_forkchoice_state();
  public:
  void unsafe_arena_set_allocated_forkchoice_state(
      ::remote::EngineForkChoiceState* forkchoice_state);
  ::remote::EngineForkChoiceState* unsafe_arena_release_forkchoice_state();

  // .remote.EnginePayloadAttributes payload_attributes = 2;
  bool has_payload_attributes() const;
  private:
  bool _internal_has_payload_attributes() const;
  public:
  void clear_payload_attributes();
  const ::remote::EnginePayloadAttributes& payload_attributes() const;
  PROTOBUF_NODISCARD ::remote::EnginePayloadAttributes* release_payload_attributes();
  ::remote::EnginePayloadAttributes* mutable_payload_attributes();
  void set_allocated_payload_attributes(::remote::EnginePayloadAttributes* payload_attributes);
  private:
  const ::remote::EnginePayloadAttributes& _internal_payload_attributes() const;
  ::remote::EnginePayloadAttributes* _internal_mutable_payload_attributes();
  public:
  void unsafe_arena_set_allocated_payload_attributes(
      ::remote::EnginePayloadAttributes* payload_attributes);
  ::remote::EnginePayloadAttributes* unsafe_arena_release_payload_attributes();

  // @@protoc_insertion_point(class_scope:remote.EngineForkChoiceUpdatedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::remote::EngineForkChoiceState* forkchoice_state_;
    ::remote::EnginePayloadAttributes* payload_attributes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EngineForkChoiceUpdatedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EngineForkChoiceUpdatedResponse) */ {
 public:
  inline EngineForkChoiceUpdatedResponse() : EngineForkChoiceUpdatedResponse(nullptr) {}
  ~EngineForkChoiceUpdatedResponse() override;
  explicit PROTOBUF_CONSTEXPR EngineForkChoiceUpdatedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineForkChoiceUpdatedResponse(const EngineForkChoiceUpdatedResponse& from);
  EngineForkChoiceUpdatedResponse(EngineForkChoiceUpdatedResponse&& from) noexcept
    : EngineForkChoiceUpdatedResponse() {
    *this = ::std::move(from);
  }

  inline EngineForkChoiceUpdatedResponse& operator=(const EngineForkChoiceUpdatedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineForkChoiceUpdatedResponse& operator=(EngineForkChoiceUpdatedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineForkChoiceUpdatedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineForkChoiceUpdatedResponse* internal_default_instance() {
    return reinterpret_cast<const EngineForkChoiceUpdatedResponse*>(
               &_EngineForkChoiceUpdatedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EngineForkChoiceUpdatedResponse& a, EngineForkChoiceUpdatedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineForkChoiceUpdatedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineForkChoiceUpdatedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineForkChoiceUpdatedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineForkChoiceUpdatedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineForkChoiceUpdatedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EngineForkChoiceUpdatedResponse& from) {
    EngineForkChoiceUpdatedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineForkChoiceUpdatedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EngineForkChoiceUpdatedResponse";
  }
  protected:
  explicit EngineForkChoiceUpdatedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadStatusFieldNumber = 1,
    kPayloadIdFieldNumber = 2,
  };
  // .remote.EnginePayloadStatus payload_status = 1;
  bool has_payload_status() const;
  private:
  bool _internal_has_payload_status() const;
  public:
  void clear_payload_status();
  const ::remote::EnginePayloadStatus& payload_status() const;
  PROTOBUF_NODISCARD ::remote::EnginePayloadStatus* release_payload_status();
  ::remote::EnginePayloadStatus* mutable_payload_status();
  void set_allocated_payload_status(::remote::EnginePayloadStatus* payload_status);
  private:
  const ::remote::EnginePayloadStatus& _internal_payload_status() const;
  ::remote::EnginePayloadStatus* _internal_mutable_payload_status();
  public:
  void unsafe_arena_set_allocated_payload_status(
      ::remote::EnginePayloadStatus* payload_status);
  ::remote::EnginePayloadStatus* unsafe_arena_release_payload_status();

  // uint64 payload_id = 2;
  void clear_payload_id();
  uint64_t payload_id() const;
  void set_payload_id(uint64_t value);
  private:
  uint64_t _internal_payload_id() const;
  void _internal_set_payload_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.EngineForkChoiceUpdatedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::remote::EnginePayloadStatus* payload_status_;
    uint64_t payload_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EngineGetPayloadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EngineGetPayloadResponse) */ {
 public:
  inline EngineGetPayloadResponse() : EngineGetPayloadResponse(nullptr) {}
  ~EngineGetPayloadResponse() override;
  explicit PROTOBUF_CONSTEXPR EngineGetPayloadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineGetPayloadResponse(const EngineGetPayloadResponse& from);
  EngineGetPayloadResponse(EngineGetPayloadResponse&& from) noexcept
    : EngineGetPayloadResponse() {
    *this = ::std::move(from);
  }

  inline EngineGetPayloadResponse& operator=(const EngineGetPayloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineGetPayloadResponse& operator=(EngineGetPayloadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineGetPayloadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineGetPayloadResponse* internal_default_instance() {
    return reinterpret_cast<const EngineGetPayloadResponse*>(
               &_EngineGetPayloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EngineGetPayloadResponse& a, EngineGetPayloadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineGetPayloadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineGetPayloadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineGetPayloadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineGetPayloadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineGetPayloadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EngineGetPayloadResponse& from) {
    EngineGetPayloadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineGetPayloadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EngineGetPayloadResponse";
  }
  protected:
  explicit EngineGetPayloadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionPayloadFieldNumber = 1,
    kBlockValueFieldNumber = 2,
    kBlobsBundleFieldNumber = 3,
  };
  // .types.ExecutionPayload execution_payload = 1;
  bool has_execution_payload() const;
  private:
  bool _internal_has_execution_payload() const;
  public:
  void clear_execution_payload();
  const ::types::ExecutionPayload& execution_payload() const;
  PROTOBUF_NODISCARD ::types::ExecutionPayload* release_execution_payload();
  ::types::ExecutionPayload* mutable_execution_payload();
  void set_allocated_execution_payload(::types::ExecutionPayload* execution_payload);
  private:
  const ::types::ExecutionPayload& _internal_execution_payload() const;
  ::types::ExecutionPayload* _internal_mutable_execution_payload();
  public:
  void unsafe_arena_set_allocated_execution_payload(
      ::types::ExecutionPayload* execution_payload);
  ::types::ExecutionPayload* unsafe_arena_release_execution_payload();

  // .types.H256 block_value = 2;
  bool has_block_value() const;
  private:
  bool _internal_has_block_value() const;
  public:
  void clear_block_value();
  const ::types::H256& block_value() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_value();
  ::types::H256* mutable_block_value();
  void set_allocated_block_value(::types::H256* block_value);
  private:
  const ::types::H256& _internal_block_value() const;
  ::types::H256* _internal_mutable_block_value();
  public:
  void unsafe_arena_set_allocated_block_value(
      ::types::H256* block_value);
  ::types::H256* unsafe_arena_release_block_value();

  // .types.BlobsBundleV1 blobs_bundle = 3;
  bool has_blobs_bundle() const;
  private:
  bool _internal_has_blobs_bundle() const;
  public:
  void clear_blobs_bundle();
  const ::types::BlobsBundleV1& blobs_bundle() const;
  PROTOBUF_NODISCARD ::types::BlobsBundleV1* release_blobs_bundle();
  ::types::BlobsBundleV1* mutable_blobs_bundle();
  void set_allocated_blobs_bundle(::types::BlobsBundleV1* blobs_bundle);
  private:
  const ::types::BlobsBundleV1& _internal_blobs_bundle() const;
  ::types::BlobsBundleV1* _internal_mutable_blobs_bundle();
  public:
  void unsafe_arena_set_allocated_blobs_bundle(
      ::types::BlobsBundleV1* blobs_bundle);
  ::types::BlobsBundleV1* unsafe_arena_release_blobs_bundle();

  // @@protoc_insertion_point(class_scope:remote.EngineGetPayloadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::ExecutionPayload* execution_payload_;
    ::types::H256* block_value_;
    ::types::BlobsBundleV1* blobs_bundle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ProtocolVersionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.ProtocolVersionRequest) */ {
 public:
  inline ProtocolVersionRequest() : ProtocolVersionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ProtocolVersionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolVersionRequest(const ProtocolVersionRequest& from);
  ProtocolVersionRequest(ProtocolVersionRequest&& from) noexcept
    : ProtocolVersionRequest() {
    *this = ::std::move(from);
  }

  inline ProtocolVersionRequest& operator=(const ProtocolVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolVersionRequest& operator=(ProtocolVersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolVersionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolVersionRequest* internal_default_instance() {
    return reinterpret_cast<const ProtocolVersionRequest*>(
               &_ProtocolVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProtocolVersionRequest& a, ProtocolVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolVersionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtocolVersionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ProtocolVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ProtocolVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ProtocolVersionRequest";
  }
  protected:
  explicit ProtocolVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.ProtocolVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ProtocolVersionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.ProtocolVersionReply) */ {
 public:
  inline ProtocolVersionReply() : ProtocolVersionReply(nullptr) {}
  ~ProtocolVersionReply() override;
  explicit PROTOBUF_CONSTEXPR ProtocolVersionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolVersionReply(const ProtocolVersionReply& from);
  ProtocolVersionReply(ProtocolVersionReply&& from) noexcept
    : ProtocolVersionReply() {
    *this = ::std::move(from);
  }

  inline ProtocolVersionReply& operator=(const ProtocolVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolVersionReply& operator=(ProtocolVersionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolVersionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolVersionReply* internal_default_instance() {
    return reinterpret_cast<const ProtocolVersionReply*>(
               &_ProtocolVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ProtocolVersionReply& a, ProtocolVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolVersionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtocolVersionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtocolVersionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtocolVersionReply& from) {
    ProtocolVersionReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolVersionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ProtocolVersionReply";
  }
  protected:
  explicit ProtocolVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.ProtocolVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientVersionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.ClientVersionRequest) */ {
 public:
  inline ClientVersionRequest() : ClientVersionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ClientVersionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientVersionRequest(const ClientVersionRequest& from);
  ClientVersionRequest(ClientVersionRequest&& from) noexcept
    : ClientVersionRequest() {
    *this = ::std::move(from);
  }

  inline ClientVersionRequest& operator=(const ClientVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientVersionRequest& operator=(ClientVersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientVersionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientVersionRequest* internal_default_instance() {
    return reinterpret_cast<const ClientVersionRequest*>(
               &_ClientVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ClientVersionRequest& a, ClientVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientVersionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientVersionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClientVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClientVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ClientVersionRequest";
  }
  protected:
  explicit ClientVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.ClientVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientVersionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.ClientVersionReply) */ {
 public:
  inline ClientVersionReply() : ClientVersionReply(nullptr) {}
  ~ClientVersionReply() override;
  explicit PROTOBUF_CONSTEXPR ClientVersionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientVersionReply(const ClientVersionReply& from);
  ClientVersionReply(ClientVersionReply&& from) noexcept
    : ClientVersionReply() {
    *this = ::std::move(from);
  }

  inline ClientVersionReply& operator=(const ClientVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientVersionReply& operator=(ClientVersionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientVersionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientVersionReply* internal_default_instance() {
    return reinterpret_cast<const ClientVersionReply*>(
               &_ClientVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ClientVersionReply& a, ClientVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientVersionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientVersionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientVersionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientVersionReply& from) {
    ClientVersionReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientVersionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ClientVersionReply";
  }
  protected:
  explicit ClientVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 1,
  };
  // string node_name = 1;
  void clear_node_name();
  const std::string& node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // @@protoc_insertion_point(class_scope:remote.ClientVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {}
  ~SubscribeRequest() override;
  explicit PROTOBUF_CONSTEXPR SubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeRequest& from) {
    SubscribeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .remote.Event type = 1;
  void clear_type();
  ::remote::Event type() const;
  void set_type(::remote::Event value);
  private:
  ::remote::Event _internal_type() const;
  void _internal_set_type(::remote::Event value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubscribeReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubscribeReply) */ {
 public:
  inline SubscribeReply() : SubscribeReply(nullptr) {}
  ~SubscribeReply() override;
  explicit PROTOBUF_CONSTEXPR SubscribeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeReply(const SubscribeReply& from);
  SubscribeReply(SubscribeReply&& from) noexcept
    : SubscribeReply() {
    *this = ::std::move(from);
  }

  inline SubscribeReply& operator=(const SubscribeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeReply& operator=(SubscribeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeReply* internal_default_instance() {
    return reinterpret_cast<const SubscribeReply*>(
               &_SubscribeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SubscribeReply& a, SubscribeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeReply& from) {
    SubscribeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubscribeReply";
  }
  protected:
  explicit SubscribeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .remote.Event type = 1;
  void clear_type();
  ::remote::Event type() const;
  void set_type(::remote::Event value);
  private:
  ::remote::Event _internal_type() const;
  void _internal_set_type(::remote::Event value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubscribeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class LogsFilterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.LogsFilterRequest) */ {
 public:
  inline LogsFilterRequest() : LogsFilterRequest(nullptr) {}
  ~LogsFilterRequest() override;
  explicit PROTOBUF_CONSTEXPR LogsFilterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogsFilterRequest(const LogsFilterRequest& from);
  LogsFilterRequest(LogsFilterRequest&& from) noexcept
    : LogsFilterRequest() {
    *this = ::std::move(from);
  }

  inline LogsFilterRequest& operator=(const LogsFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogsFilterRequest& operator=(LogsFilterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogsFilterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogsFilterRequest* internal_default_instance() {
    return reinterpret_cast<const LogsFilterRequest*>(
               &_LogsFilterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LogsFilterRequest& a, LogsFilterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogsFilterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogsFilterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogsFilterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogsFilterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogsFilterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogsFilterRequest& from) {
    LogsFilterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogsFilterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.LogsFilterRequest";
  }
  protected:
  explicit LogsFilterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 2,
    kTopicsFieldNumber = 4,
    kAllAddressesFieldNumber = 1,
    kAllTopicsFieldNumber = 3,
  };
  // repeated .types.H160 addresses = 2;
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  ::types::H160* mutable_addresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H160 >*
      mutable_addresses();
  private:
  const ::types::H160& _internal_addresses(int index) const;
  ::types::H160* _internal_add_addresses();
  public:
  const ::types::H160& addresses(int index) const;
  ::types::H160* add_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H160 >&
      addresses() const;

  // repeated .types.H256 topics = 4;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  ::types::H256* mutable_topics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >*
      mutable_topics();
  private:
  const ::types::H256& _internal_topics(int index) const;
  ::types::H256* _internal_add_topics();
  public:
  const ::types::H256& topics(int index) const;
  ::types::H256* add_topics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >&
      topics() const;

  // bool all_addresses = 1;
  void clear_all_addresses();
  bool all_addresses() const;
  void set_all_addresses(bool value);
  private:
  bool _internal_all_addresses() const;
  void _internal_set_all_addresses(bool value);
  public:

  // bool all_topics = 3;
  void clear_all_topics();
  bool all_topics() const;
  void set_all_topics(bool value);
  private:
  bool _internal_all_topics() const;
  void _internal_set_all_topics(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.LogsFilterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H160 > addresses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 > topics_;
    bool all_addresses_;
    bool all_topics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubscribeLogsReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubscribeLogsReply) */ {
 public:
  inline SubscribeLogsReply() : SubscribeLogsReply(nullptr) {}
  ~SubscribeLogsReply() override;
  explicit PROTOBUF_CONSTEXPR SubscribeLogsReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeLogsReply(const SubscribeLogsReply& from);
  SubscribeLogsReply(SubscribeLogsReply&& from) noexcept
    : SubscribeLogsReply() {
    *this = ::std::move(from);
  }

  inline SubscribeLogsReply& operator=(const SubscribeLogsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeLogsReply& operator=(SubscribeLogsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeLogsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeLogsReply* internal_default_instance() {
    return reinterpret_cast<const SubscribeLogsReply*>(
               &_SubscribeLogsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SubscribeLogsReply& a, SubscribeLogsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeLogsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeLogsReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeLogsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeLogsReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeLogsReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeLogsReply& from) {
    SubscribeLogsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeLogsReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubscribeLogsReply";
  }
  protected:
  explicit SubscribeLogsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 6,
    kDataFieldNumber = 4,
    kAddressFieldNumber = 1,
    kBlockHashFieldNumber = 2,
    kTransactionHashFieldNumber = 7,
    kBlockNumberFieldNumber = 3,
    kLogIndexFieldNumber = 5,
    kTransactionIndexFieldNumber = 8,
    kRemovedFieldNumber = 9,
  };
  // repeated .types.H256 topics = 6;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  ::types::H256* mutable_topics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >*
      mutable_topics();
  private:
  const ::types::H256& _internal_topics(int index) const;
  ::types::H256* _internal_add_topics();
  public:
  const ::types::H256& topics(int index) const;
  ::types::H256* add_topics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >&
      topics() const;

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .types.H160 address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::types::H160& address() const;
  PROTOBUF_NODISCARD ::types::H160* release_address();
  ::types::H160* mutable_address();
  void set_allocated_address(::types::H160* address);
  private:
  const ::types::H160& _internal_address() const;
  ::types::H160* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::types::H160* address);
  ::types::H160* unsafe_arena_release_address();

  // .types.H256 block_hash = 2;
  bool has_block_hash() const;
  private:
  bool _internal_has_block_hash() const;
  public:
  void clear_block_hash();
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* block_hash);
  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();
  public:
  void unsafe_arena_set_allocated_block_hash(
      ::types::H256* block_hash);
  ::types::H256* unsafe_arena_release_block_hash();

  // .types.H256 transaction_hash = 7;
  bool has_transaction_hash() const;
  private:
  bool _internal_has_transaction_hash() const;
  public:
  void clear_transaction_hash();
  const ::types::H256& transaction_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_transaction_hash();
  ::types::H256* mutable_transaction_hash();
  void set_allocated_transaction_hash(::types::H256* transaction_hash);
  private:
  const ::types::H256& _internal_transaction_hash() const;
  ::types::H256* _internal_mutable_transaction_hash();
  public:
  void unsafe_arena_set_allocated_transaction_hash(
      ::types::H256* transaction_hash);
  ::types::H256* unsafe_arena_release_transaction_hash();

  // uint64 block_number = 3;
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // uint64 log_index = 5;
  void clear_log_index();
  uint64_t log_index() const;
  void set_log_index(uint64_t value);
  private:
  uint64_t _internal_log_index() const;
  void _internal_set_log_index(uint64_t value);
  public:

  // uint64 transaction_index = 8;
  void clear_transaction_index();
  uint64_t transaction_index() const;
  void set_transaction_index(uint64_t value);
  private:
  uint64_t _internal_transaction_index() const;
  void _internal_set_transaction_index(uint64_t value);
  public:

  // bool removed = 9;
  void clear_removed();
  bool removed() const;
  void set_removed(bool value);
  private:
  bool _internal_removed() const;
  void _internal_set_removed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubscribeLogsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 > topics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::types::H160* address_;
    ::types::H256* block_hash_;
    ::types::H256* transaction_hash_;
    uint64_t block_number_;
    uint64_t log_index_;
    uint64_t transaction_index_;
    bool removed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class BlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.BlockRequest) */ {
 public:
  inline BlockRequest() : BlockRequest(nullptr) {}
  ~BlockRequest() override;
  explicit PROTOBUF_CONSTEXPR BlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRequest(const BlockRequest& from);
  BlockRequest(BlockRequest&& from) noexcept
    : BlockRequest() {
    *this = ::std::move(from);
  }

  inline BlockRequest& operator=(const BlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRequest& operator=(BlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRequest* internal_default_instance() {
    return reinterpret_cast<const BlockRequest*>(
               &_BlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BlockRequest& a, BlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockRequest& from) {
    BlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.BlockRequest";
  }
  protected:
  explicit BlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHashFieldNumber = 3,
    kBlockHeightFieldNumber = 2,
  };
  // .types.H256 block_hash = 3;
  bool has_block_hash() const;
  private:
  bool _internal_has_block_hash() const;
  public:
  void clear_block_hash();
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* block_hash);
  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();
  public:
  void unsafe_arena_set_allocated_block_hash(
      ::types::H256* block_hash);
  ::types::H256* unsafe_arena_release_block_hash();

  // uint64 block_height = 2;
  void clear_block_height();
  uint64_t block_height() const;
  void set_block_height(uint64_t value);
  private:
  uint64_t _internal_block_height() const;
  void _internal_set_block_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.BlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H256* block_hash_;
    uint64_t block_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class BlockReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.BlockReply) */ {
 public:
  inline BlockReply() : BlockReply(nullptr) {}
  ~BlockReply() override;
  explicit PROTOBUF_CONSTEXPR BlockReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockReply(const BlockReply& from);
  BlockReply(BlockReply&& from) noexcept
    : BlockReply() {
    *this = ::std::move(from);
  }

  inline BlockReply& operator=(const BlockReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockReply& operator=(BlockReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockReply* internal_default_instance() {
    return reinterpret_cast<const BlockReply*>(
               &_BlockReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BlockReply& a, BlockReply& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockReply& from) {
    BlockReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.BlockReply";
  }
  protected:
  explicit BlockReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockRlpFieldNumber = 1,
    kSendersFieldNumber = 2,
  };
  // bytes block_rlp = 1;
  void clear_block_rlp();
  const std::string& block_rlp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_rlp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_rlp();
  PROTOBUF_NODISCARD std::string* release_block_rlp();
  void set_allocated_block_rlp(std::string* block_rlp);
  private:
  const std::string& _internal_block_rlp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_rlp(const std::string& value);
  std::string* _internal_mutable_block_rlp();
  public:

  // bytes senders = 2;
  void clear_senders();
  const std::string& senders() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senders(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senders();
  PROTOBUF_NODISCARD std::string* release_senders();
  void set_allocated_senders(std::string* senders);
  private:
  const std::string& _internal_senders() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senders(const std::string& value);
  std::string* _internal_mutable_senders();
  public:

  // @@protoc_insertion_point(class_scope:remote.BlockReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_rlp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class TxnLookupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.TxnLookupRequest) */ {
 public:
  inline TxnLookupRequest() : TxnLookupRequest(nullptr) {}
  ~TxnLookupRequest() override;
  explicit PROTOBUF_CONSTEXPR TxnLookupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxnLookupRequest(const TxnLookupRequest& from);
  TxnLookupRequest(TxnLookupRequest&& from) noexcept
    : TxnLookupRequest() {
    *this = ::std::move(from);
  }

  inline TxnLookupRequest& operator=(const TxnLookupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnLookupRequest& operator=(TxnLookupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnLookupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnLookupRequest* internal_default_instance() {
    return reinterpret_cast<const TxnLookupRequest*>(
               &_TxnLookupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TxnLookupRequest& a, TxnLookupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnLookupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnLookupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnLookupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnLookupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxnLookupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxnLookupRequest& from) {
    TxnLookupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxnLookupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.TxnLookupRequest";
  }
  protected:
  explicit TxnLookupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnHashFieldNumber = 1,
  };
  // .types.H256 txn_hash = 1;
  bool has_txn_hash() const;
  private:
  bool _internal_has_txn_hash() const;
  public:
  void clear_txn_hash();
  const ::types::H256& txn_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_txn_hash();
  ::types::H256* mutable_txn_hash();
  void set_allocated_txn_hash(::types::H256* txn_hash);
  private:
  const ::types::H256& _internal_txn_hash() const;
  ::types::H256* _internal_mutable_txn_hash();
  public:
  void unsafe_arena_set_allocated_txn_hash(
      ::types::H256* txn_hash);
  ::types::H256* unsafe_arena_release_txn_hash();

  // @@protoc_insertion_point(class_scope:remote.TxnLookupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H256* txn_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class TxnLookupReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.TxnLookupReply) */ {
 public:
  inline TxnLookupReply() : TxnLookupReply(nullptr) {}
  ~TxnLookupReply() override;
  explicit PROTOBUF_CONSTEXPR TxnLookupReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxnLookupReply(const TxnLookupReply& from);
  TxnLookupReply(TxnLookupReply&& from) noexcept
    : TxnLookupReply() {
    *this = ::std::move(from);
  }

  inline TxnLookupReply& operator=(const TxnLookupReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnLookupReply& operator=(TxnLookupReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnLookupReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnLookupReply* internal_default_instance() {
    return reinterpret_cast<const TxnLookupReply*>(
               &_TxnLookupReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TxnLookupReply& a, TxnLookupReply& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnLookupReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnLookupReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnLookupReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnLookupReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxnLookupReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxnLookupReply& from) {
    TxnLookupReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxnLookupReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.TxnLookupReply";
  }
  protected:
  explicit TxnLookupReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockNumberFieldNumber = 1,
  };
  // uint64 block_number = 1;
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.TxnLookupReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t block_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NodesInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NodesInfoRequest) */ {
 public:
  inline NodesInfoRequest() : NodesInfoRequest(nullptr) {}
  ~NodesInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR NodesInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodesInfoRequest(const NodesInfoRequest& from);
  NodesInfoRequest(NodesInfoRequest&& from) noexcept
    : NodesInfoRequest() {
    *this = ::std::move(from);
  }

  inline NodesInfoRequest& operator=(const NodesInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodesInfoRequest& operator=(NodesInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodesInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodesInfoRequest* internal_default_instance() {
    return reinterpret_cast<const NodesInfoRequest*>(
               &_NodesInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(NodesInfoRequest& a, NodesInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodesInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodesInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodesInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodesInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodesInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodesInfoRequest& from) {
    NodesInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodesInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NodesInfoRequest";
  }
  protected:
  explicit NodesInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitFieldNumber = 1,
  };
  // uint32 limit = 1;
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.NodesInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NodesInfoReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NodesInfoReply) */ {
 public:
  inline NodesInfoReply() : NodesInfoReply(nullptr) {}
  ~NodesInfoReply() override;
  explicit PROTOBUF_CONSTEXPR NodesInfoReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodesInfoReply(const NodesInfoReply& from);
  NodesInfoReply(NodesInfoReply&& from) noexcept
    : NodesInfoReply() {
    *this = ::std::move(from);
  }

  inline NodesInfoReply& operator=(const NodesInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodesInfoReply& operator=(NodesInfoReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodesInfoReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodesInfoReply* internal_default_instance() {
    return reinterpret_cast<const NodesInfoReply*>(
               &_NodesInfoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(NodesInfoReply& a, NodesInfoReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NodesInfoReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodesInfoReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodesInfoReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodesInfoReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodesInfoReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodesInfoReply& from) {
    NodesInfoReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodesInfoReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NodesInfoReply";
  }
  protected:
  explicit NodesInfoReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesInfoFieldNumber = 1,
  };
  // repeated .types.NodeInfoReply nodes_info = 1;
  int nodes_info_size() const;
  private:
  int _internal_nodes_info_size() const;
  public:
  void clear_nodes_info();
  ::types::NodeInfoReply* mutable_nodes_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply >*
      mutable_nodes_info();
  private:
  const ::types::NodeInfoReply& _internal_nodes_info(int index) const;
  ::types::NodeInfoReply* _internal_add_nodes_info();
  public:
  const ::types::NodeInfoReply& nodes_info(int index) const;
  ::types::NodeInfoReply* add_nodes_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply >&
      nodes_info() const;

  // @@protoc_insertion_point(class_scope:remote.NodesInfoReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply > nodes_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class PeersReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.PeersReply) */ {
 public:
  inline PeersReply() : PeersReply(nullptr) {}
  ~PeersReply() override;
  explicit PROTOBUF_CONSTEXPR PeersReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeersReply(const PeersReply& from);
  PeersReply(PeersReply&& from) noexcept
    : PeersReply() {
    *this = ::std::move(from);
  }

  inline PeersReply& operator=(const PeersReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeersReply& operator=(PeersReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeersReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeersReply* internal_default_instance() {
    return reinterpret_cast<const PeersReply*>(
               &_PeersReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PeersReply& a, PeersReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PeersReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeersReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeersReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeersReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeersReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeersReply& from) {
    PeersReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeersReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.PeersReply";
  }
  protected:
  explicit PeersReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
  };
  // repeated .types.PeerInfo peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::types::PeerInfo* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo >*
      mutable_peers();
  private:
  const ::types::PeerInfo& _internal_peers(int index) const;
  ::types::PeerInfo* _internal_add_peers();
  public:
  const ::types::PeerInfo& peers(int index) const;
  ::types::PeerInfo* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo >&
      peers() const;

  // @@protoc_insertion_point(class_scope:remote.PeersReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo > peers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class PendingBlockReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.PendingBlockReply) */ {
 public:
  inline PendingBlockReply() : PendingBlockReply(nullptr) {}
  ~PendingBlockReply() override;
  explicit PROTOBUF_CONSTEXPR PendingBlockReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PendingBlockReply(const PendingBlockReply& from);
  PendingBlockReply(PendingBlockReply&& from) noexcept
    : PendingBlockReply() {
    *this = ::std::move(from);
  }

  inline PendingBlockReply& operator=(const PendingBlockReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PendingBlockReply& operator=(PendingBlockReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PendingBlockReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PendingBlockReply* internal_default_instance() {
    return reinterpret_cast<const PendingBlockReply*>(
               &_PendingBlockReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PendingBlockReply& a, PendingBlockReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PendingBlockReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PendingBlockReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PendingBlockReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PendingBlockReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PendingBlockReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PendingBlockReply& from) {
    PendingBlockReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PendingBlockReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.PendingBlockReply";
  }
  protected:
  explicit PendingBlockReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockRlpFieldNumber = 1,
  };
  // bytes block_rlp = 1;
  void clear_block_rlp();
  const std::string& block_rlp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_rlp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_rlp();
  PROTOBUF_NODISCARD std::string* release_block_rlp();
  void set_allocated_block_rlp(std::string* block_rlp);
  private:
  const std::string& _internal_block_rlp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_rlp(const std::string& value);
  std::string* _internal_mutable_block_rlp();
  public:

  // @@protoc_insertion_point(class_scope:remote.PendingBlockReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_rlp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EngineGetPayloadBodiesByHashV1Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EngineGetPayloadBodiesByHashV1Request) */ {
 public:
  inline EngineGetPayloadBodiesByHashV1Request() : EngineGetPayloadBodiesByHashV1Request(nullptr) {}
  ~EngineGetPayloadBodiesByHashV1Request() override;
  explicit PROTOBUF_CONSTEXPR EngineGetPayloadBodiesByHashV1Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineGetPayloadBodiesByHashV1Request(const EngineGetPayloadBodiesByHashV1Request& from);
  EngineGetPayloadBodiesByHashV1Request(EngineGetPayloadBodiesByHashV1Request&& from) noexcept
    : EngineGetPayloadBodiesByHashV1Request() {
    *this = ::std::move(from);
  }

  inline EngineGetPayloadBodiesByHashV1Request& operator=(const EngineGetPayloadBodiesByHashV1Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineGetPayloadBodiesByHashV1Request& operator=(EngineGetPayloadBodiesByHashV1Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineGetPayloadBodiesByHashV1Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineGetPayloadBodiesByHashV1Request* internal_default_instance() {
    return reinterpret_cast<const EngineGetPayloadBodiesByHashV1Request*>(
               &_EngineGetPayloadBodiesByHashV1Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(EngineGetPayloadBodiesByHashV1Request& a, EngineGetPayloadBodiesByHashV1Request& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineGetPayloadBodiesByHashV1Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineGetPayloadBodiesByHashV1Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineGetPayloadBodiesByHashV1Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineGetPayloadBodiesByHashV1Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineGetPayloadBodiesByHashV1Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EngineGetPayloadBodiesByHashV1Request& from) {
    EngineGetPayloadBodiesByHashV1Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineGetPayloadBodiesByHashV1Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EngineGetPayloadBodiesByHashV1Request";
  }
  protected:
  explicit EngineGetPayloadBodiesByHashV1Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 1,
  };
  // repeated .types.H256 hashes = 1;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;
  public:
  void clear_hashes();
  ::types::H256* mutable_hashes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >*
      mutable_hashes();
  private:
  const ::types::H256& _internal_hashes(int index) const;
  ::types::H256* _internal_add_hashes();
  public:
  const ::types::H256& hashes(int index) const;
  ::types::H256* add_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >&
      hashes() const;

  // @@protoc_insertion_point(class_scope:remote.EngineGetPayloadBodiesByHashV1Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 > hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EngineGetPayloadBodiesByRangeV1Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EngineGetPayloadBodiesByRangeV1Request) */ {
 public:
  inline EngineGetPayloadBodiesByRangeV1Request() : EngineGetPayloadBodiesByRangeV1Request(nullptr) {}
  ~EngineGetPayloadBodiesByRangeV1Request() override;
  explicit PROTOBUF_CONSTEXPR EngineGetPayloadBodiesByRangeV1Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineGetPayloadBodiesByRangeV1Request(const EngineGetPayloadBodiesByRangeV1Request& from);
  EngineGetPayloadBodiesByRangeV1Request(EngineGetPayloadBodiesByRangeV1Request&& from) noexcept
    : EngineGetPayloadBodiesByRangeV1Request() {
    *this = ::std::move(from);
  }

  inline EngineGetPayloadBodiesByRangeV1Request& operator=(const EngineGetPayloadBodiesByRangeV1Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineGetPayloadBodiesByRangeV1Request& operator=(EngineGetPayloadBodiesByRangeV1Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineGetPayloadBodiesByRangeV1Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineGetPayloadBodiesByRangeV1Request* internal_default_instance() {
    return reinterpret_cast<const EngineGetPayloadBodiesByRangeV1Request*>(
               &_EngineGetPayloadBodiesByRangeV1Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(EngineGetPayloadBodiesByRangeV1Request& a, EngineGetPayloadBodiesByRangeV1Request& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineGetPayloadBodiesByRangeV1Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineGetPayloadBodiesByRangeV1Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineGetPayloadBodiesByRangeV1Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineGetPayloadBodiesByRangeV1Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineGetPayloadBodiesByRangeV1Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EngineGetPayloadBodiesByRangeV1Request& from) {
    EngineGetPayloadBodiesByRangeV1Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineGetPayloadBodiesByRangeV1Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EngineGetPayloadBodiesByRangeV1Request";
  }
  protected:
  explicit EngineGetPayloadBodiesByRangeV1Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // uint64 start = 1;
  void clear_start();
  uint64_t start() const;
  void set_start(uint64_t value);
  private:
  uint64_t _internal_start() const;
  void _internal_set_start(uint64_t value);
  public:

  // uint64 count = 2;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.EngineGetPayloadBodiesByRangeV1Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t start_;
    uint64_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EngineGetPayloadBodiesV1Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EngineGetPayloadBodiesV1Response) */ {
 public:
  inline EngineGetPayloadBodiesV1Response() : EngineGetPayloadBodiesV1Response(nullptr) {}
  ~EngineGetPayloadBodiesV1Response() override;
  explicit PROTOBUF_CONSTEXPR EngineGetPayloadBodiesV1Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineGetPayloadBodiesV1Response(const EngineGetPayloadBodiesV1Response& from);
  EngineGetPayloadBodiesV1Response(EngineGetPayloadBodiesV1Response&& from) noexcept
    : EngineGetPayloadBodiesV1Response() {
    *this = ::std::move(from);
  }

  inline EngineGetPayloadBodiesV1Response& operator=(const EngineGetPayloadBodiesV1Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineGetPayloadBodiesV1Response& operator=(EngineGetPayloadBodiesV1Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineGetPayloadBodiesV1Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineGetPayloadBodiesV1Response* internal_default_instance() {
    return reinterpret_cast<const EngineGetPayloadBodiesV1Response*>(
               &_EngineGetPayloadBodiesV1Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(EngineGetPayloadBodiesV1Response& a, EngineGetPayloadBodiesV1Response& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineGetPayloadBodiesV1Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineGetPayloadBodiesV1Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineGetPayloadBodiesV1Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineGetPayloadBodiesV1Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineGetPayloadBodiesV1Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EngineGetPayloadBodiesV1Response& from) {
    EngineGetPayloadBodiesV1Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineGetPayloadBodiesV1Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EngineGetPayloadBodiesV1Response";
  }
  protected:
  explicit EngineGetPayloadBodiesV1Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodiesFieldNumber = 1,
  };
  // repeated .types.ExecutionPayloadBodyV1 bodies = 1;
  int bodies_size() const;
  private:
  int _internal_bodies_size() const;
  public:
  void clear_bodies();
  ::types::ExecutionPayloadBodyV1* mutable_bodies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::ExecutionPayloadBodyV1 >*
      mutable_bodies();
  private:
  const ::types::ExecutionPayloadBodyV1& _internal_bodies(int index) const;
  ::types::ExecutionPayloadBodyV1* _internal_add_bodies();
  public:
  const ::types::ExecutionPayloadBodyV1& bodies(int index) const;
  ::types::ExecutionPayloadBodyV1* add_bodies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::ExecutionPayloadBodyV1 >&
      bodies() const;

  // @@protoc_insertion_point(class_scope:remote.EngineGetPayloadBodiesV1Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::ExecutionPayloadBodyV1 > bodies_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EtherbaseRequest

// -------------------------------------------------------------------

// EtherbaseReply

// .types.H160 address = 1;
inline bool EtherbaseReply::_internal_has_address() const {
  return this != internal_default_instance() && _impl_.address_ != nullptr;
}
inline bool EtherbaseReply::has_address() const {
  return _internal_has_address();
}
inline const ::types::H160& EtherbaseReply::_internal_address() const {
  const ::types::H160* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& EtherbaseReply::address() const {
  // @@protoc_insertion_point(field_get:remote.EtherbaseReply.address)
  return _internal_address();
}
inline void EtherbaseReply::unsafe_arena_set_allocated_address(
    ::types::H160* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EtherbaseReply.address)
}
inline ::types::H160* EtherbaseReply::release_address() {
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* EtherbaseReply::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:remote.EtherbaseReply.address)
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::types::H160* EtherbaseReply::_internal_mutable_address() {
  
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    _impl_.address_ = p;
  }
  return _impl_.address_;
}
inline ::types::H160* EtherbaseReply::mutable_address() {
  ::types::H160* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:remote.EtherbaseReply.address)
  return _msg;
}
inline void EtherbaseReply::set_allocated_address(::types::H160* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address));
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.address_ = address;
  // @@protoc_insertion_point(field_set_allocated:remote.EtherbaseReply.address)
}

// -------------------------------------------------------------------

// NetVersionRequest

// -------------------------------------------------------------------

// NetVersionReply

// uint64 id = 1;
inline void NetVersionReply::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t NetVersionReply::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t NetVersionReply::id() const {
  // @@protoc_insertion_point(field_get:remote.NetVersionReply.id)
  return _internal_id();
}
inline void NetVersionReply::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void NetVersionReply::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.NetVersionReply.id)
}

// -------------------------------------------------------------------

// NetPeerCountRequest

// -------------------------------------------------------------------

// NetPeerCountReply

// uint64 count = 1;
inline void NetPeerCountReply::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t NetPeerCountReply::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t NetPeerCountReply::count() const {
  // @@protoc_insertion_point(field_get:remote.NetPeerCountReply.count)
  return _internal_count();
}
inline void NetPeerCountReply::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void NetPeerCountReply::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:remote.NetPeerCountReply.count)
}

// -------------------------------------------------------------------

// EngineGetPayloadRequest

// uint64 payload_id = 1;
inline void EngineGetPayloadRequest::clear_payload_id() {
  _impl_.payload_id_ = uint64_t{0u};
}
inline uint64_t EngineGetPayloadRequest::_internal_payload_id() const {
  return _impl_.payload_id_;
}
inline uint64_t EngineGetPayloadRequest::payload_id() const {
  // @@protoc_insertion_point(field_get:remote.EngineGetPayloadRequest.payload_id)
  return _internal_payload_id();
}
inline void EngineGetPayloadRequest::_internal_set_payload_id(uint64_t value) {
  
  _impl_.payload_id_ = value;
}
inline void EngineGetPayloadRequest::set_payload_id(uint64_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:remote.EngineGetPayloadRequest.payload_id)
}

// -------------------------------------------------------------------

// EnginePayloadStatus

// .remote.EngineStatus status = 1;
inline void EnginePayloadStatus::clear_status() {
  _impl_.status_ = 0;
}
inline ::remote::EngineStatus EnginePayloadStatus::_internal_status() const {
  return static_cast< ::remote::EngineStatus >(_impl_.status_);
}
inline ::remote::EngineStatus EnginePayloadStatus::status() const {
  // @@protoc_insertion_point(field_get:remote.EnginePayloadStatus.status)
  return _internal_status();
}
inline void EnginePayloadStatus::_internal_set_status(::remote::EngineStatus value) {
  
  _impl_.status_ = value;
}
inline void EnginePayloadStatus::set_status(::remote::EngineStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:remote.EnginePayloadStatus.status)
}

// .types.H256 latest_valid_hash = 2;
inline bool EnginePayloadStatus::_internal_has_latest_valid_hash() const {
  return this != internal_default_instance() && _impl_.latest_valid_hash_ != nullptr;
}
inline bool EnginePayloadStatus::has_latest_valid_hash() const {
  return _internal_has_latest_valid_hash();
}
inline const ::types::H256& EnginePayloadStatus::_internal_latest_valid_hash() const {
  const ::types::H256* p = _impl_.latest_valid_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& EnginePayloadStatus::latest_valid_hash() const {
  // @@protoc_insertion_point(field_get:remote.EnginePayloadStatus.latest_valid_hash)
  return _internal_latest_valid_hash();
}
inline void EnginePayloadStatus::unsafe_arena_set_allocated_latest_valid_hash(
    ::types::H256* latest_valid_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_valid_hash_);
  }
  _impl_.latest_valid_hash_ = latest_valid_hash;
  if (latest_valid_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EnginePayloadStatus.latest_valid_hash)
}
inline ::types::H256* EnginePayloadStatus::release_latest_valid_hash() {
  
  ::types::H256* temp = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* EnginePayloadStatus::unsafe_arena_release_latest_valid_hash() {
  // @@protoc_insertion_point(field_release:remote.EnginePayloadStatus.latest_valid_hash)
  
  ::types::H256* temp = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
  return temp;
}
inline ::types::H256* EnginePayloadStatus::_internal_mutable_latest_valid_hash() {
  
  if (_impl_.latest_valid_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.latest_valid_hash_ = p;
  }
  return _impl_.latest_valid_hash_;
}
inline ::types::H256* EnginePayloadStatus::mutable_latest_valid_hash() {
  ::types::H256* _msg = _internal_mutable_latest_valid_hash();
  // @@protoc_insertion_point(field_mutable:remote.EnginePayloadStatus.latest_valid_hash)
  return _msg;
}
inline void EnginePayloadStatus::set_allocated_latest_valid_hash(::types::H256* latest_valid_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_valid_hash_);
  }
  if (latest_valid_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latest_valid_hash));
    if (message_arena != submessage_arena) {
      latest_valid_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest_valid_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.latest_valid_hash_ = latest_valid_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.EnginePayloadStatus.latest_valid_hash)
}

// string validation_error = 3;
inline void EnginePayloadStatus::clear_validation_error() {
  _impl_.validation_error_.ClearToEmpty();
}
inline const std::string& EnginePayloadStatus::validation_error() const {
  // @@protoc_insertion_point(field_get:remote.EnginePayloadStatus.validation_error)
  return _internal_validation_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnginePayloadStatus::set_validation_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.validation_error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.EnginePayloadStatus.validation_error)
}
inline std::string* EnginePayloadStatus::mutable_validation_error() {
  std::string* _s = _internal_mutable_validation_error();
  // @@protoc_insertion_point(field_mutable:remote.EnginePayloadStatus.validation_error)
  return _s;
}
inline const std::string& EnginePayloadStatus::_internal_validation_error() const {
  return _impl_.validation_error_.Get();
}
inline void EnginePayloadStatus::_internal_set_validation_error(const std::string& value) {
  
  _impl_.validation_error_.Set(value, GetArenaForAllocation());
}
inline std::string* EnginePayloadStatus::_internal_mutable_validation_error() {
  
  return _impl_.validation_error_.Mutable(GetArenaForAllocation());
}
inline std::string* EnginePayloadStatus::release_validation_error() {
  // @@protoc_insertion_point(field_release:remote.EnginePayloadStatus.validation_error)
  return _impl_.validation_error_.Release();
}
inline void EnginePayloadStatus::set_allocated_validation_error(std::string* validation_error) {
  if (validation_error != nullptr) {
    
  } else {
    
  }
  _impl_.validation_error_.SetAllocated(validation_error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.validation_error_.IsDefault()) {
    _impl_.validation_error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.EnginePayloadStatus.validation_error)
}

// -------------------------------------------------------------------

// EnginePayloadAttributes

// uint32 version = 1;
inline void EnginePayloadAttributes::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t EnginePayloadAttributes::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t EnginePayloadAttributes::version() const {
  // @@protoc_insertion_point(field_get:remote.EnginePayloadAttributes.version)
  return _internal_version();
}
inline void EnginePayloadAttributes::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void EnginePayloadAttributes::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:remote.EnginePayloadAttributes.version)
}

// uint64 timestamp = 2;
inline void EnginePayloadAttributes::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t EnginePayloadAttributes::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t EnginePayloadAttributes::timestamp() const {
  // @@protoc_insertion_point(field_get:remote.EnginePayloadAttributes.timestamp)
  return _internal_timestamp();
}
inline void EnginePayloadAttributes::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void EnginePayloadAttributes::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:remote.EnginePayloadAttributes.timestamp)
}

// .types.H256 prev_randao = 3;
inline bool EnginePayloadAttributes::_internal_has_prev_randao() const {
  return this != internal_default_instance() && _impl_.prev_randao_ != nullptr;
}
inline bool EnginePayloadAttributes::has_prev_randao() const {
  return _internal_has_prev_randao();
}
inline const ::types::H256& EnginePayloadAttributes::_internal_prev_randao() const {
  const ::types::H256* p = _impl_.prev_randao_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& EnginePayloadAttributes::prev_randao() const {
  // @@protoc_insertion_point(field_get:remote.EnginePayloadAttributes.prev_randao)
  return _internal_prev_randao();
}
inline void EnginePayloadAttributes::unsafe_arena_set_allocated_prev_randao(
    ::types::H256* prev_randao) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_randao_);
  }
  _impl_.prev_randao_ = prev_randao;
  if (prev_randao) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EnginePayloadAttributes.prev_randao)
}
inline ::types::H256* EnginePayloadAttributes::release_prev_randao() {
  
  ::types::H256* temp = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* EnginePayloadAttributes::unsafe_arena_release_prev_randao() {
  // @@protoc_insertion_point(field_release:remote.EnginePayloadAttributes.prev_randao)
  
  ::types::H256* temp = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
  return temp;
}
inline ::types::H256* EnginePayloadAttributes::_internal_mutable_prev_randao() {
  
  if (_impl_.prev_randao_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.prev_randao_ = p;
  }
  return _impl_.prev_randao_;
}
inline ::types::H256* EnginePayloadAttributes::mutable_prev_randao() {
  ::types::H256* _msg = _internal_mutable_prev_randao();
  // @@protoc_insertion_point(field_mutable:remote.EnginePayloadAttributes.prev_randao)
  return _msg;
}
inline void EnginePayloadAttributes::set_allocated_prev_randao(::types::H256* prev_randao) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_randao_);
  }
  if (prev_randao) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_randao));
    if (message_arena != submessage_arena) {
      prev_randao = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_randao, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prev_randao_ = prev_randao;
  // @@protoc_insertion_point(field_set_allocated:remote.EnginePayloadAttributes.prev_randao)
}

// .types.H160 suggested_fee_recipient = 4;
inline bool EnginePayloadAttributes::_internal_has_suggested_fee_recipient() const {
  return this != internal_default_instance() && _impl_.suggested_fee_recipient_ != nullptr;
}
inline bool EnginePayloadAttributes::has_suggested_fee_recipient() const {
  return _internal_has_suggested_fee_recipient();
}
inline const ::types::H160& EnginePayloadAttributes::_internal_suggested_fee_recipient() const {
  const ::types::H160* p = _impl_.suggested_fee_recipient_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& EnginePayloadAttributes::suggested_fee_recipient() const {
  // @@protoc_insertion_point(field_get:remote.EnginePayloadAttributes.suggested_fee_recipient)
  return _internal_suggested_fee_recipient();
}
inline void EnginePayloadAttributes::unsafe_arena_set_allocated_suggested_fee_recipient(
    ::types::H160* suggested_fee_recipient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.suggested_fee_recipient_);
  }
  _impl_.suggested_fee_recipient_ = suggested_fee_recipient;
  if (suggested_fee_recipient) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EnginePayloadAttributes.suggested_fee_recipient)
}
inline ::types::H160* EnginePayloadAttributes::release_suggested_fee_recipient() {
  
  ::types::H160* temp = _impl_.suggested_fee_recipient_;
  _impl_.suggested_fee_recipient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* EnginePayloadAttributes::unsafe_arena_release_suggested_fee_recipient() {
  // @@protoc_insertion_point(field_release:remote.EnginePayloadAttributes.suggested_fee_recipient)
  
  ::types::H160* temp = _impl_.suggested_fee_recipient_;
  _impl_.suggested_fee_recipient_ = nullptr;
  return temp;
}
inline ::types::H160* EnginePayloadAttributes::_internal_mutable_suggested_fee_recipient() {
  
  if (_impl_.suggested_fee_recipient_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    _impl_.suggested_fee_recipient_ = p;
  }
  return _impl_.suggested_fee_recipient_;
}
inline ::types::H160* EnginePayloadAttributes::mutable_suggested_fee_recipient() {
  ::types::H160* _msg = _internal_mutable_suggested_fee_recipient();
  // @@protoc_insertion_point(field_mutable:remote.EnginePayloadAttributes.suggested_fee_recipient)
  return _msg;
}
inline void EnginePayloadAttributes::set_allocated_suggested_fee_recipient(::types::H160* suggested_fee_recipient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.suggested_fee_recipient_);
  }
  if (suggested_fee_recipient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suggested_fee_recipient));
    if (message_arena != submessage_arena) {
      suggested_fee_recipient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suggested_fee_recipient, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.suggested_fee_recipient_ = suggested_fee_recipient;
  // @@protoc_insertion_point(field_set_allocated:remote.EnginePayloadAttributes.suggested_fee_recipient)
}

// repeated .types.Withdrawal withdrawals = 5;
inline int EnginePayloadAttributes::_internal_withdrawals_size() const {
  return _impl_.withdrawals_.size();
}
inline int EnginePayloadAttributes::withdrawals_size() const {
  return _internal_withdrawals_size();
}
inline ::types::Withdrawal* EnginePayloadAttributes::mutable_withdrawals(int index) {
  // @@protoc_insertion_point(field_mutable:remote.EnginePayloadAttributes.withdrawals)
  return _impl_.withdrawals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >*
EnginePayloadAttributes::mutable_withdrawals() {
  // @@protoc_insertion_point(field_mutable_list:remote.EnginePayloadAttributes.withdrawals)
  return &_impl_.withdrawals_;
}
inline const ::types::Withdrawal& EnginePayloadAttributes::_internal_withdrawals(int index) const {
  return _impl_.withdrawals_.Get(index);
}
inline const ::types::Withdrawal& EnginePayloadAttributes::withdrawals(int index) const {
  // @@protoc_insertion_point(field_get:remote.EnginePayloadAttributes.withdrawals)
  return _internal_withdrawals(index);
}
inline ::types::Withdrawal* EnginePayloadAttributes::_internal_add_withdrawals() {
  return _impl_.withdrawals_.Add();
}
inline ::types::Withdrawal* EnginePayloadAttributes::add_withdrawals() {
  ::types::Withdrawal* _add = _internal_add_withdrawals();
  // @@protoc_insertion_point(field_add:remote.EnginePayloadAttributes.withdrawals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >&
EnginePayloadAttributes::withdrawals() const {
  // @@protoc_insertion_point(field_list:remote.EnginePayloadAttributes.withdrawals)
  return _impl_.withdrawals_;
}

// -------------------------------------------------------------------

// EngineForkChoiceState

// .types.H256 head_block_hash = 1;
inline bool EngineForkChoiceState::_internal_has_head_block_hash() const {
  return this != internal_default_instance() && _impl_.head_block_hash_ != nullptr;
}
inline bool EngineForkChoiceState::has_head_block_hash() const {
  return _internal_has_head_block_hash();
}
inline const ::types::H256& EngineForkChoiceState::_internal_head_block_hash() const {
  const ::types::H256* p = _impl_.head_block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& EngineForkChoiceState::head_block_hash() const {
  // @@protoc_insertion_point(field_get:remote.EngineForkChoiceState.head_block_hash)
  return _internal_head_block_hash();
}
inline void EngineForkChoiceState::unsafe_arena_set_allocated_head_block_hash(
    ::types::H256* head_block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_block_hash_);
  }
  _impl_.head_block_hash_ = head_block_hash;
  if (head_block_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineForkChoiceState.head_block_hash)
}
inline ::types::H256* EngineForkChoiceState::release_head_block_hash() {
  
  ::types::H256* temp = _impl_.head_block_hash_;
  _impl_.head_block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* EngineForkChoiceState::unsafe_arena_release_head_block_hash() {
  // @@protoc_insertion_point(field_release:remote.EngineForkChoiceState.head_block_hash)
  
  ::types::H256* temp = _impl_.head_block_hash_;
  _impl_.head_block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* EngineForkChoiceState::_internal_mutable_head_block_hash() {
  
  if (_impl_.head_block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.head_block_hash_ = p;
  }
  return _impl_.head_block_hash_;
}
inline ::types::H256* EngineForkChoiceState::mutable_head_block_hash() {
  ::types::H256* _msg = _internal_mutable_head_block_hash();
  // @@protoc_insertion_point(field_mutable:remote.EngineForkChoiceState.head_block_hash)
  return _msg;
}
inline void EngineForkChoiceState::set_allocated_head_block_hash(::types::H256* head_block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_block_hash_);
  }
  if (head_block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_block_hash));
    if (message_arena != submessage_arena) {
      head_block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head_block_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_block_hash_ = head_block_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineForkChoiceState.head_block_hash)
}

// .types.H256 safe_block_hash = 2;
inline bool EngineForkChoiceState::_internal_has_safe_block_hash() const {
  return this != internal_default_instance() && _impl_.safe_block_hash_ != nullptr;
}
inline bool EngineForkChoiceState::has_safe_block_hash() const {
  return _internal_has_safe_block_hash();
}
inline const ::types::H256& EngineForkChoiceState::_internal_safe_block_hash() const {
  const ::types::H256* p = _impl_.safe_block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& EngineForkChoiceState::safe_block_hash() const {
  // @@protoc_insertion_point(field_get:remote.EngineForkChoiceState.safe_block_hash)
  return _internal_safe_block_hash();
}
inline void EngineForkChoiceState::unsafe_arena_set_allocated_safe_block_hash(
    ::types::H256* safe_block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.safe_block_hash_);
  }
  _impl_.safe_block_hash_ = safe_block_hash;
  if (safe_block_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineForkChoiceState.safe_block_hash)
}
inline ::types::H256* EngineForkChoiceState::release_safe_block_hash() {
  
  ::types::H256* temp = _impl_.safe_block_hash_;
  _impl_.safe_block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* EngineForkChoiceState::unsafe_arena_release_safe_block_hash() {
  // @@protoc_insertion_point(field_release:remote.EngineForkChoiceState.safe_block_hash)
  
  ::types::H256* temp = _impl_.safe_block_hash_;
  _impl_.safe_block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* EngineForkChoiceState::_internal_mutable_safe_block_hash() {
  
  if (_impl_.safe_block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.safe_block_hash_ = p;
  }
  return _impl_.safe_block_hash_;
}
inline ::types::H256* EngineForkChoiceState::mutable_safe_block_hash() {
  ::types::H256* _msg = _internal_mutable_safe_block_hash();
  // @@protoc_insertion_point(field_mutable:remote.EngineForkChoiceState.safe_block_hash)
  return _msg;
}
inline void EngineForkChoiceState::set_allocated_safe_block_hash(::types::H256* safe_block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.safe_block_hash_);
  }
  if (safe_block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(safe_block_hash));
    if (message_arena != submessage_arena) {
      safe_block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, safe_block_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.safe_block_hash_ = safe_block_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineForkChoiceState.safe_block_hash)
}

// .types.H256 finalized_block_hash = 3;
inline bool EngineForkChoiceState::_internal_has_finalized_block_hash() const {
  return this != internal_default_instance() && _impl_.finalized_block_hash_ != nullptr;
}
inline bool EngineForkChoiceState::has_finalized_block_hash() const {
  return _internal_has_finalized_block_hash();
}
inline const ::types::H256& EngineForkChoiceState::_internal_finalized_block_hash() const {
  const ::types::H256* p = _impl_.finalized_block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& EngineForkChoiceState::finalized_block_hash() const {
  // @@protoc_insertion_point(field_get:remote.EngineForkChoiceState.finalized_block_hash)
  return _internal_finalized_block_hash();
}
inline void EngineForkChoiceState::unsafe_arena_set_allocated_finalized_block_hash(
    ::types::H256* finalized_block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.finalized_block_hash_);
  }
  _impl_.finalized_block_hash_ = finalized_block_hash;
  if (finalized_block_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineForkChoiceState.finalized_block_hash)
}
inline ::types::H256* EngineForkChoiceState::release_finalized_block_hash() {
  
  ::types::H256* temp = _impl_.finalized_block_hash_;
  _impl_.finalized_block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* EngineForkChoiceState::unsafe_arena_release_finalized_block_hash() {
  // @@protoc_insertion_point(field_release:remote.EngineForkChoiceState.finalized_block_hash)
  
  ::types::H256* temp = _impl_.finalized_block_hash_;
  _impl_.finalized_block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* EngineForkChoiceState::_internal_mutable_finalized_block_hash() {
  
  if (_impl_.finalized_block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.finalized_block_hash_ = p;
  }
  return _impl_.finalized_block_hash_;
}
inline ::types::H256* EngineForkChoiceState::mutable_finalized_block_hash() {
  ::types::H256* _msg = _internal_mutable_finalized_block_hash();
  // @@protoc_insertion_point(field_mutable:remote.EngineForkChoiceState.finalized_block_hash)
  return _msg;
}
inline void EngineForkChoiceState::set_allocated_finalized_block_hash(::types::H256* finalized_block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.finalized_block_hash_);
  }
  if (finalized_block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(finalized_block_hash));
    if (message_arena != submessage_arena) {
      finalized_block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finalized_block_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.finalized_block_hash_ = finalized_block_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineForkChoiceState.finalized_block_hash)
}

// -------------------------------------------------------------------

// EngineForkChoiceUpdatedRequest

// .remote.EngineForkChoiceState forkchoice_state = 1;
inline bool EngineForkChoiceUpdatedRequest::_internal_has_forkchoice_state() const {
  return this != internal_default_instance() && _impl_.forkchoice_state_ != nullptr;
}
inline bool EngineForkChoiceUpdatedRequest::has_forkchoice_state() const {
  return _internal_has_forkchoice_state();
}
inline void EngineForkChoiceUpdatedRequest::clear_forkchoice_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.forkchoice_state_ != nullptr) {
    delete _impl_.forkchoice_state_;
  }
  _impl_.forkchoice_state_ = nullptr;
}
inline const ::remote::EngineForkChoiceState& EngineForkChoiceUpdatedRequest::_internal_forkchoice_state() const {
  const ::remote::EngineForkChoiceState* p = _impl_.forkchoice_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::remote::EngineForkChoiceState&>(
      ::remote::_EngineForkChoiceState_default_instance_);
}
inline const ::remote::EngineForkChoiceState& EngineForkChoiceUpdatedRequest::forkchoice_state() const {
  // @@protoc_insertion_point(field_get:remote.EngineForkChoiceUpdatedRequest.forkchoice_state)
  return _internal_forkchoice_state();
}
inline void EngineForkChoiceUpdatedRequest::unsafe_arena_set_allocated_forkchoice_state(
    ::remote::EngineForkChoiceState* forkchoice_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.forkchoice_state_);
  }
  _impl_.forkchoice_state_ = forkchoice_state;
  if (forkchoice_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineForkChoiceUpdatedRequest.forkchoice_state)
}
inline ::remote::EngineForkChoiceState* EngineForkChoiceUpdatedRequest::release_forkchoice_state() {
  
  ::remote::EngineForkChoiceState* temp = _impl_.forkchoice_state_;
  _impl_.forkchoice_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::remote::EngineForkChoiceState* EngineForkChoiceUpdatedRequest::unsafe_arena_release_forkchoice_state() {
  // @@protoc_insertion_point(field_release:remote.EngineForkChoiceUpdatedRequest.forkchoice_state)
  
  ::remote::EngineForkChoiceState* temp = _impl_.forkchoice_state_;
  _impl_.forkchoice_state_ = nullptr;
  return temp;
}
inline ::remote::EngineForkChoiceState* EngineForkChoiceUpdatedRequest::_internal_mutable_forkchoice_state() {
  
  if (_impl_.forkchoice_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::remote::EngineForkChoiceState>(GetArenaForAllocation());
    _impl_.forkchoice_state_ = p;
  }
  return _impl_.forkchoice_state_;
}
inline ::remote::EngineForkChoiceState* EngineForkChoiceUpdatedRequest::mutable_forkchoice_state() {
  ::remote::EngineForkChoiceState* _msg = _internal_mutable_forkchoice_state();
  // @@protoc_insertion_point(field_mutable:remote.EngineForkChoiceUpdatedRequest.forkchoice_state)
  return _msg;
}
inline void EngineForkChoiceUpdatedRequest::set_allocated_forkchoice_state(::remote::EngineForkChoiceState* forkchoice_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.forkchoice_state_;
  }
  if (forkchoice_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forkchoice_state);
    if (message_arena != submessage_arena) {
      forkchoice_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forkchoice_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.forkchoice_state_ = forkchoice_state;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineForkChoiceUpdatedRequest.forkchoice_state)
}

// .remote.EnginePayloadAttributes payload_attributes = 2;
inline bool EngineForkChoiceUpdatedRequest::_internal_has_payload_attributes() const {
  return this != internal_default_instance() && _impl_.payload_attributes_ != nullptr;
}
inline bool EngineForkChoiceUpdatedRequest::has_payload_attributes() const {
  return _internal_has_payload_attributes();
}
inline void EngineForkChoiceUpdatedRequest::clear_payload_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_attributes_ != nullptr) {
    delete _impl_.payload_attributes_;
  }
  _impl_.payload_attributes_ = nullptr;
}
inline const ::remote::EnginePayloadAttributes& EngineForkChoiceUpdatedRequest::_internal_payload_attributes() const {
  const ::remote::EnginePayloadAttributes* p = _impl_.payload_attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::remote::EnginePayloadAttributes&>(
      ::remote::_EnginePayloadAttributes_default_instance_);
}
inline const ::remote::EnginePayloadAttributes& EngineForkChoiceUpdatedRequest::payload_attributes() const {
  // @@protoc_insertion_point(field_get:remote.EngineForkChoiceUpdatedRequest.payload_attributes)
  return _internal_payload_attributes();
}
inline void EngineForkChoiceUpdatedRequest::unsafe_arena_set_allocated_payload_attributes(
    ::remote::EnginePayloadAttributes* payload_attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_attributes_);
  }
  _impl_.payload_attributes_ = payload_attributes;
  if (payload_attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineForkChoiceUpdatedRequest.payload_attributes)
}
inline ::remote::EnginePayloadAttributes* EngineForkChoiceUpdatedRequest::release_payload_attributes() {
  
  ::remote::EnginePayloadAttributes* temp = _impl_.payload_attributes_;
  _impl_.payload_attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::remote::EnginePayloadAttributes* EngineForkChoiceUpdatedRequest::unsafe_arena_release_payload_attributes() {
  // @@protoc_insertion_point(field_release:remote.EngineForkChoiceUpdatedRequest.payload_attributes)
  
  ::remote::EnginePayloadAttributes* temp = _impl_.payload_attributes_;
  _impl_.payload_attributes_ = nullptr;
  return temp;
}
inline ::remote::EnginePayloadAttributes* EngineForkChoiceUpdatedRequest::_internal_mutable_payload_attributes() {
  
  if (_impl_.payload_attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::remote::EnginePayloadAttributes>(GetArenaForAllocation());
    _impl_.payload_attributes_ = p;
  }
  return _impl_.payload_attributes_;
}
inline ::remote::EnginePayloadAttributes* EngineForkChoiceUpdatedRequest::mutable_payload_attributes() {
  ::remote::EnginePayloadAttributes* _msg = _internal_mutable_payload_attributes();
  // @@protoc_insertion_point(field_mutable:remote.EngineForkChoiceUpdatedRequest.payload_attributes)
  return _msg;
}
inline void EngineForkChoiceUpdatedRequest::set_allocated_payload_attributes(::remote::EnginePayloadAttributes* payload_attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_attributes_;
  }
  if (payload_attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload_attributes);
    if (message_arena != submessage_arena) {
      payload_attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_attributes_ = payload_attributes;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineForkChoiceUpdatedRequest.payload_attributes)
}

// -------------------------------------------------------------------

// EngineForkChoiceUpdatedResponse

// .remote.EnginePayloadStatus payload_status = 1;
inline bool EngineForkChoiceUpdatedResponse::_internal_has_payload_status() const {
  return this != internal_default_instance() && _impl_.payload_status_ != nullptr;
}
inline bool EngineForkChoiceUpdatedResponse::has_payload_status() const {
  return _internal_has_payload_status();
}
inline void EngineForkChoiceUpdatedResponse::clear_payload_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_status_ != nullptr) {
    delete _impl_.payload_status_;
  }
  _impl_.payload_status_ = nullptr;
}
inline const ::remote::EnginePayloadStatus& EngineForkChoiceUpdatedResponse::_internal_payload_status() const {
  const ::remote::EnginePayloadStatus* p = _impl_.payload_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::remote::EnginePayloadStatus&>(
      ::remote::_EnginePayloadStatus_default_instance_);
}
inline const ::remote::EnginePayloadStatus& EngineForkChoiceUpdatedResponse::payload_status() const {
  // @@protoc_insertion_point(field_get:remote.EngineForkChoiceUpdatedResponse.payload_status)
  return _internal_payload_status();
}
inline void EngineForkChoiceUpdatedResponse::unsafe_arena_set_allocated_payload_status(
    ::remote::EnginePayloadStatus* payload_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_status_);
  }
  _impl_.payload_status_ = payload_status;
  if (payload_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineForkChoiceUpdatedResponse.payload_status)
}
inline ::remote::EnginePayloadStatus* EngineForkChoiceUpdatedResponse::release_payload_status() {
  
  ::remote::EnginePayloadStatus* temp = _impl_.payload_status_;
  _impl_.payload_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::remote::EnginePayloadStatus* EngineForkChoiceUpdatedResponse::unsafe_arena_release_payload_status() {
  // @@protoc_insertion_point(field_release:remote.EngineForkChoiceUpdatedResponse.payload_status)
  
  ::remote::EnginePayloadStatus* temp = _impl_.payload_status_;
  _impl_.payload_status_ = nullptr;
  return temp;
}
inline ::remote::EnginePayloadStatus* EngineForkChoiceUpdatedResponse::_internal_mutable_payload_status() {
  
  if (_impl_.payload_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::remote::EnginePayloadStatus>(GetArenaForAllocation());
    _impl_.payload_status_ = p;
  }
  return _impl_.payload_status_;
}
inline ::remote::EnginePayloadStatus* EngineForkChoiceUpdatedResponse::mutable_payload_status() {
  ::remote::EnginePayloadStatus* _msg = _internal_mutable_payload_status();
  // @@protoc_insertion_point(field_mutable:remote.EngineForkChoiceUpdatedResponse.payload_status)
  return _msg;
}
inline void EngineForkChoiceUpdatedResponse::set_allocated_payload_status(::remote::EnginePayloadStatus* payload_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_status_;
  }
  if (payload_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload_status);
    if (message_arena != submessage_arena) {
      payload_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_status_ = payload_status;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineForkChoiceUpdatedResponse.payload_status)
}

// uint64 payload_id = 2;
inline void EngineForkChoiceUpdatedResponse::clear_payload_id() {
  _impl_.payload_id_ = uint64_t{0u};
}
inline uint64_t EngineForkChoiceUpdatedResponse::_internal_payload_id() const {
  return _impl_.payload_id_;
}
inline uint64_t EngineForkChoiceUpdatedResponse::payload_id() const {
  // @@protoc_insertion_point(field_get:remote.EngineForkChoiceUpdatedResponse.payload_id)
  return _internal_payload_id();
}
inline void EngineForkChoiceUpdatedResponse::_internal_set_payload_id(uint64_t value) {
  
  _impl_.payload_id_ = value;
}
inline void EngineForkChoiceUpdatedResponse::set_payload_id(uint64_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:remote.EngineForkChoiceUpdatedResponse.payload_id)
}

// -------------------------------------------------------------------

// EngineGetPayloadResponse

// .types.ExecutionPayload execution_payload = 1;
inline bool EngineGetPayloadResponse::_internal_has_execution_payload() const {
  return this != internal_default_instance() && _impl_.execution_payload_ != nullptr;
}
inline bool EngineGetPayloadResponse::has_execution_payload() const {
  return _internal_has_execution_payload();
}
inline const ::types::ExecutionPayload& EngineGetPayloadResponse::_internal_execution_payload() const {
  const ::types::ExecutionPayload* p = _impl_.execution_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::ExecutionPayload&>(
      ::types::_ExecutionPayload_default_instance_);
}
inline const ::types::ExecutionPayload& EngineGetPayloadResponse::execution_payload() const {
  // @@protoc_insertion_point(field_get:remote.EngineGetPayloadResponse.execution_payload)
  return _internal_execution_payload();
}
inline void EngineGetPayloadResponse::unsafe_arena_set_allocated_execution_payload(
    ::types::ExecutionPayload* execution_payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.execution_payload_);
  }
  _impl_.execution_payload_ = execution_payload;
  if (execution_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineGetPayloadResponse.execution_payload)
}
inline ::types::ExecutionPayload* EngineGetPayloadResponse::release_execution_payload() {
  
  ::types::ExecutionPayload* temp = _impl_.execution_payload_;
  _impl_.execution_payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::ExecutionPayload* EngineGetPayloadResponse::unsafe_arena_release_execution_payload() {
  // @@protoc_insertion_point(field_release:remote.EngineGetPayloadResponse.execution_payload)
  
  ::types::ExecutionPayload* temp = _impl_.execution_payload_;
  _impl_.execution_payload_ = nullptr;
  return temp;
}
inline ::types::ExecutionPayload* EngineGetPayloadResponse::_internal_mutable_execution_payload() {
  
  if (_impl_.execution_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::ExecutionPayload>(GetArenaForAllocation());
    _impl_.execution_payload_ = p;
  }
  return _impl_.execution_payload_;
}
inline ::types::ExecutionPayload* EngineGetPayloadResponse::mutable_execution_payload() {
  ::types::ExecutionPayload* _msg = _internal_mutable_execution_payload();
  // @@protoc_insertion_point(field_mutable:remote.EngineGetPayloadResponse.execution_payload)
  return _msg;
}
inline void EngineGetPayloadResponse::set_allocated_execution_payload(::types::ExecutionPayload* execution_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.execution_payload_);
  }
  if (execution_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_payload));
    if (message_arena != submessage_arena) {
      execution_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.execution_payload_ = execution_payload;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineGetPayloadResponse.execution_payload)
}

// .types.H256 block_value = 2;
inline bool EngineGetPayloadResponse::_internal_has_block_value() const {
  return this != internal_default_instance() && _impl_.block_value_ != nullptr;
}
inline bool EngineGetPayloadResponse::has_block_value() const {
  return _internal_has_block_value();
}
inline const ::types::H256& EngineGetPayloadResponse::_internal_block_value() const {
  const ::types::H256* p = _impl_.block_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& EngineGetPayloadResponse::block_value() const {
  // @@protoc_insertion_point(field_get:remote.EngineGetPayloadResponse.block_value)
  return _internal_block_value();
}
inline void EngineGetPayloadResponse::unsafe_arena_set_allocated_block_value(
    ::types::H256* block_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_value_);
  }
  _impl_.block_value_ = block_value;
  if (block_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineGetPayloadResponse.block_value)
}
inline ::types::H256* EngineGetPayloadResponse::release_block_value() {
  
  ::types::H256* temp = _impl_.block_value_;
  _impl_.block_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* EngineGetPayloadResponse::unsafe_arena_release_block_value() {
  // @@protoc_insertion_point(field_release:remote.EngineGetPayloadResponse.block_value)
  
  ::types::H256* temp = _impl_.block_value_;
  _impl_.block_value_ = nullptr;
  return temp;
}
inline ::types::H256* EngineGetPayloadResponse::_internal_mutable_block_value() {
  
  if (_impl_.block_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.block_value_ = p;
  }
  return _impl_.block_value_;
}
inline ::types::H256* EngineGetPayloadResponse::mutable_block_value() {
  ::types::H256* _msg = _internal_mutable_block_value();
  // @@protoc_insertion_point(field_mutable:remote.EngineGetPayloadResponse.block_value)
  return _msg;
}
inline void EngineGetPayloadResponse::set_allocated_block_value(::types::H256* block_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_value_);
  }
  if (block_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_value));
    if (message_arena != submessage_arena) {
      block_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_value_ = block_value;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineGetPayloadResponse.block_value)
}

// .types.BlobsBundleV1 blobs_bundle = 3;
inline bool EngineGetPayloadResponse::_internal_has_blobs_bundle() const {
  return this != internal_default_instance() && _impl_.blobs_bundle_ != nullptr;
}
inline bool EngineGetPayloadResponse::has_blobs_bundle() const {
  return _internal_has_blobs_bundle();
}
inline const ::types::BlobsBundleV1& EngineGetPayloadResponse::_internal_blobs_bundle() const {
  const ::types::BlobsBundleV1* p = _impl_.blobs_bundle_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::BlobsBundleV1&>(
      ::types::_BlobsBundleV1_default_instance_);
}
inline const ::types::BlobsBundleV1& EngineGetPayloadResponse::blobs_bundle() const {
  // @@protoc_insertion_point(field_get:remote.EngineGetPayloadResponse.blobs_bundle)
  return _internal_blobs_bundle();
}
inline void EngineGetPayloadResponse::unsafe_arena_set_allocated_blobs_bundle(
    ::types::BlobsBundleV1* blobs_bundle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blobs_bundle_);
  }
  _impl_.blobs_bundle_ = blobs_bundle;
  if (blobs_bundle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EngineGetPayloadResponse.blobs_bundle)
}
inline ::types::BlobsBundleV1* EngineGetPayloadResponse::release_blobs_bundle() {
  
  ::types::BlobsBundleV1* temp = _impl_.blobs_bundle_;
  _impl_.blobs_bundle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::BlobsBundleV1* EngineGetPayloadResponse::unsafe_arena_release_blobs_bundle() {
  // @@protoc_insertion_point(field_release:remote.EngineGetPayloadResponse.blobs_bundle)
  
  ::types::BlobsBundleV1* temp = _impl_.blobs_bundle_;
  _impl_.blobs_bundle_ = nullptr;
  return temp;
}
inline ::types::BlobsBundleV1* EngineGetPayloadResponse::_internal_mutable_blobs_bundle() {
  
  if (_impl_.blobs_bundle_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::BlobsBundleV1>(GetArenaForAllocation());
    _impl_.blobs_bundle_ = p;
  }
  return _impl_.blobs_bundle_;
}
inline ::types::BlobsBundleV1* EngineGetPayloadResponse::mutable_blobs_bundle() {
  ::types::BlobsBundleV1* _msg = _internal_mutable_blobs_bundle();
  // @@protoc_insertion_point(field_mutable:remote.EngineGetPayloadResponse.blobs_bundle)
  return _msg;
}
inline void EngineGetPayloadResponse::set_allocated_blobs_bundle(::types::BlobsBundleV1* blobs_bundle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blobs_bundle_);
  }
  if (blobs_bundle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blobs_bundle));
    if (message_arena != submessage_arena) {
      blobs_bundle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blobs_bundle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blobs_bundle_ = blobs_bundle;
  // @@protoc_insertion_point(field_set_allocated:remote.EngineGetPayloadResponse.blobs_bundle)
}

// -------------------------------------------------------------------

// ProtocolVersionRequest

// -------------------------------------------------------------------

// ProtocolVersionReply

// uint64 id = 1;
inline void ProtocolVersionReply::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t ProtocolVersionReply::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t ProtocolVersionReply::id() const {
  // @@protoc_insertion_point(field_get:remote.ProtocolVersionReply.id)
  return _internal_id();
}
inline void ProtocolVersionReply::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void ProtocolVersionReply::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.ProtocolVersionReply.id)
}

// -------------------------------------------------------------------

// ClientVersionRequest

// -------------------------------------------------------------------

// ClientVersionReply

// string node_name = 1;
inline void ClientVersionReply::clear_node_name() {
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& ClientVersionReply::node_name() const {
  // @@protoc_insertion_point(field_get:remote.ClientVersionReply.node_name)
  return _internal_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientVersionReply::set_node_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.ClientVersionReply.node_name)
}
inline std::string* ClientVersionReply::mutable_node_name() {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:remote.ClientVersionReply.node_name)
  return _s;
}
inline const std::string& ClientVersionReply::_internal_node_name() const {
  return _impl_.node_name_.Get();
}
inline void ClientVersionReply::_internal_set_node_name(const std::string& value) {
  
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientVersionReply::_internal_mutable_node_name() {
  
  return _impl_.node_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientVersionReply::release_node_name() {
  // @@protoc_insertion_point(field_release:remote.ClientVersionReply.node_name)
  return _impl_.node_name_.Release();
}
inline void ClientVersionReply::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    
  } else {
    
  }
  _impl_.node_name_.SetAllocated(node_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_name_.IsDefault()) {
    _impl_.node_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.ClientVersionReply.node_name)
}

// -------------------------------------------------------------------

// SubscribeRequest

// .remote.Event type = 1;
inline void SubscribeRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::remote::Event SubscribeRequest::_internal_type() const {
  return static_cast< ::remote::Event >(_impl_.type_);
}
inline ::remote::Event SubscribeRequest::type() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeRequest.type)
  return _internal_type();
}
inline void SubscribeRequest::_internal_set_type(::remote::Event value) {
  
  _impl_.type_ = value;
}
inline void SubscribeRequest::set_type(::remote::Event value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeRequest.type)
}

// -------------------------------------------------------------------

// SubscribeReply

// .remote.Event type = 1;
inline void SubscribeReply::clear_type() {
  _impl_.type_ = 0;
}
inline ::remote::Event SubscribeReply::_internal_type() const {
  return static_cast< ::remote::Event >(_impl_.type_);
}
inline ::remote::Event SubscribeReply::type() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeReply.type)
  return _internal_type();
}
inline void SubscribeReply::_internal_set_type(::remote::Event value) {
  
  _impl_.type_ = value;
}
inline void SubscribeReply::set_type(::remote::Event value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeReply.type)
}

// bytes data = 2;
inline void SubscribeReply::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SubscribeReply::data() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeReply.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeReply::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.SubscribeReply.data)
}
inline std::string* SubscribeReply::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:remote.SubscribeReply.data)
  return _s;
}
inline const std::string& SubscribeReply::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SubscribeReply::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeReply::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeReply::release_data() {
  // @@protoc_insertion_point(field_release:remote.SubscribeReply.data)
  return _impl_.data_.Release();
}
inline void SubscribeReply::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.SubscribeReply.data)
}

// -------------------------------------------------------------------

// LogsFilterRequest

// bool all_addresses = 1;
inline void LogsFilterRequest::clear_all_addresses() {
  _impl_.all_addresses_ = false;
}
inline bool LogsFilterRequest::_internal_all_addresses() const {
  return _impl_.all_addresses_;
}
inline bool LogsFilterRequest::all_addresses() const {
  // @@protoc_insertion_point(field_get:remote.LogsFilterRequest.all_addresses)
  return _internal_all_addresses();
}
inline void LogsFilterRequest::_internal_set_all_addresses(bool value) {
  
  _impl_.all_addresses_ = value;
}
inline void LogsFilterRequest::set_all_addresses(bool value) {
  _internal_set_all_addresses(value);
  // @@protoc_insertion_point(field_set:remote.LogsFilterRequest.all_addresses)
}

// repeated .types.H160 addresses = 2;
inline int LogsFilterRequest::_internal_addresses_size() const {
  return _impl_.addresses_.size();
}
inline int LogsFilterRequest::addresses_size() const {
  return _internal_addresses_size();
}
inline ::types::H160* LogsFilterRequest::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:remote.LogsFilterRequest.addresses)
  return _impl_.addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H160 >*
LogsFilterRequest::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:remote.LogsFilterRequest.addresses)
  return &_impl_.addresses_;
}
inline const ::types::H160& LogsFilterRequest::_internal_addresses(int index) const {
  return _impl_.addresses_.Get(index);
}
inline const ::types::H160& LogsFilterRequest::addresses(int index) const {
  // @@protoc_insertion_point(field_get:remote.LogsFilterRequest.addresses)
  return _internal_addresses(index);
}
inline ::types::H160* LogsFilterRequest::_internal_add_addresses() {
  return _impl_.addresses_.Add();
}
inline ::types::H160* LogsFilterRequest::add_addresses() {
  ::types::H160* _add = _internal_add_addresses();
  // @@protoc_insertion_point(field_add:remote.LogsFilterRequest.addresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H160 >&
LogsFilterRequest::addresses() const {
  // @@protoc_insertion_point(field_list:remote.LogsFilterRequest.addresses)
  return _impl_.addresses_;
}

// bool all_topics = 3;
inline void LogsFilterRequest::clear_all_topics() {
  _impl_.all_topics_ = false;
}
inline bool LogsFilterRequest::_internal_all_topics() const {
  return _impl_.all_topics_;
}
inline bool LogsFilterRequest::all_topics() const {
  // @@protoc_insertion_point(field_get:remote.LogsFilterRequest.all_topics)
  return _internal_all_topics();
}
inline void LogsFilterRequest::_internal_set_all_topics(bool value) {
  
  _impl_.all_topics_ = value;
}
inline void LogsFilterRequest::set_all_topics(bool value) {
  _internal_set_all_topics(value);
  // @@protoc_insertion_point(field_set:remote.LogsFilterRequest.all_topics)
}

// repeated .types.H256 topics = 4;
inline int LogsFilterRequest::_internal_topics_size() const {
  return _impl_.topics_.size();
}
inline int LogsFilterRequest::topics_size() const {
  return _internal_topics_size();
}
inline ::types::H256* LogsFilterRequest::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:remote.LogsFilterRequest.topics)
  return _impl_.topics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >*
LogsFilterRequest::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:remote.LogsFilterRequest.topics)
  return &_impl_.topics_;
}
inline const ::types::H256& LogsFilterRequest::_internal_topics(int index) const {
  return _impl_.topics_.Get(index);
}
inline const ::types::H256& LogsFilterRequest::topics(int index) const {
  // @@protoc_insertion_point(field_get:remote.LogsFilterRequest.topics)
  return _internal_topics(index);
}
inline ::types::H256* LogsFilterRequest::_internal_add_topics() {
  return _impl_.topics_.Add();
}
inline ::types::H256* LogsFilterRequest::add_topics() {
  ::types::H256* _add = _internal_add_topics();
  // @@protoc_insertion_point(field_add:remote.LogsFilterRequest.topics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >&
LogsFilterRequest::topics() const {
  // @@protoc_insertion_point(field_list:remote.LogsFilterRequest.topics)
  return _impl_.topics_;
}

// -------------------------------------------------------------------

// SubscribeLogsReply

// .types.H160 address = 1;
inline bool SubscribeLogsReply::_internal_has_address() const {
  return this != internal_default_instance() && _impl_.address_ != nullptr;
}
inline bool SubscribeLogsReply::has_address() const {
  return _internal_has_address();
}
inline const ::types::H160& SubscribeLogsReply::_internal_address() const {
  const ::types::H160* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& SubscribeLogsReply::address() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.address)
  return _internal_address();
}
inline void SubscribeLogsReply::unsafe_arena_set_allocated_address(
    ::types::H160* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.SubscribeLogsReply.address)
}
inline ::types::H160* SubscribeLogsReply::release_address() {
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* SubscribeLogsReply::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:remote.SubscribeLogsReply.address)
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::types::H160* SubscribeLogsReply::_internal_mutable_address() {
  
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    _impl_.address_ = p;
  }
  return _impl_.address_;
}
inline ::types::H160* SubscribeLogsReply::mutable_address() {
  ::types::H160* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:remote.SubscribeLogsReply.address)
  return _msg;
}
inline void SubscribeLogsReply::set_allocated_address(::types::H160* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address));
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.address_ = address;
  // @@protoc_insertion_point(field_set_allocated:remote.SubscribeLogsReply.address)
}

// .types.H256 block_hash = 2;
inline bool SubscribeLogsReply::_internal_has_block_hash() const {
  return this != internal_default_instance() && _impl_.block_hash_ != nullptr;
}
inline bool SubscribeLogsReply::has_block_hash() const {
  return _internal_has_block_hash();
}
inline const ::types::H256& SubscribeLogsReply::_internal_block_hash() const {
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& SubscribeLogsReply::block_hash() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.block_hash)
  return _internal_block_hash();
}
inline void SubscribeLogsReply::unsafe_arena_set_allocated_block_hash(
    ::types::H256* block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = block_hash;
  if (block_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.SubscribeLogsReply.block_hash)
}
inline ::types::H256* SubscribeLogsReply::release_block_hash() {
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* SubscribeLogsReply::unsafe_arena_release_block_hash() {
  // @@protoc_insertion_point(field_release:remote.SubscribeLogsReply.block_hash)
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* SubscribeLogsReply::_internal_mutable_block_hash() {
  
  if (_impl_.block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.block_hash_ = p;
  }
  return _impl_.block_hash_;
}
inline ::types::H256* SubscribeLogsReply::mutable_block_hash() {
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:remote.SubscribeLogsReply.block_hash)
  return _msg;
}
inline void SubscribeLogsReply::set_allocated_block_hash(::types::H256* block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  if (block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_hash));
    if (message_arena != submessage_arena) {
      block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_hash_ = block_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.SubscribeLogsReply.block_hash)
}

// uint64 block_number = 3;
inline void SubscribeLogsReply::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
}
inline uint64_t SubscribeLogsReply::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t SubscribeLogsReply::block_number() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.block_number)
  return _internal_block_number();
}
inline void SubscribeLogsReply::_internal_set_block_number(uint64_t value) {
  
  _impl_.block_number_ = value;
}
inline void SubscribeLogsReply::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeLogsReply.block_number)
}

// bytes data = 4;
inline void SubscribeLogsReply::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SubscribeLogsReply::data() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeLogsReply::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.SubscribeLogsReply.data)
}
inline std::string* SubscribeLogsReply::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:remote.SubscribeLogsReply.data)
  return _s;
}
inline const std::string& SubscribeLogsReply::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SubscribeLogsReply::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeLogsReply::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeLogsReply::release_data() {
  // @@protoc_insertion_point(field_release:remote.SubscribeLogsReply.data)
  return _impl_.data_.Release();
}
inline void SubscribeLogsReply::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.SubscribeLogsReply.data)
}

// uint64 log_index = 5;
inline void SubscribeLogsReply::clear_log_index() {
  _impl_.log_index_ = uint64_t{0u};
}
inline uint64_t SubscribeLogsReply::_internal_log_index() const {
  return _impl_.log_index_;
}
inline uint64_t SubscribeLogsReply::log_index() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.log_index)
  return _internal_log_index();
}
inline void SubscribeLogsReply::_internal_set_log_index(uint64_t value) {
  
  _impl_.log_index_ = value;
}
inline void SubscribeLogsReply::set_log_index(uint64_t value) {
  _internal_set_log_index(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeLogsReply.log_index)
}

// repeated .types.H256 topics = 6;
inline int SubscribeLogsReply::_internal_topics_size() const {
  return _impl_.topics_.size();
}
inline int SubscribeLogsReply::topics_size() const {
  return _internal_topics_size();
}
inline ::types::H256* SubscribeLogsReply::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:remote.SubscribeLogsReply.topics)
  return _impl_.topics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >*
SubscribeLogsReply::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:remote.SubscribeLogsReply.topics)
  return &_impl_.topics_;
}
inline const ::types::H256& SubscribeLogsReply::_internal_topics(int index) const {
  return _impl_.topics_.Get(index);
}
inline const ::types::H256& SubscribeLogsReply::topics(int index) const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.topics)
  return _internal_topics(index);
}
inline ::types::H256* SubscribeLogsReply::_internal_add_topics() {
  return _impl_.topics_.Add();
}
inline ::types::H256* SubscribeLogsReply::add_topics() {
  ::types::H256* _add = _internal_add_topics();
  // @@protoc_insertion_point(field_add:remote.SubscribeLogsReply.topics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >&
SubscribeLogsReply::topics() const {
  // @@protoc_insertion_point(field_list:remote.SubscribeLogsReply.topics)
  return _impl_.topics_;
}

// .types.H256 transaction_hash = 7;
inline bool SubscribeLogsReply::_internal_has_transaction_hash() const {
  return this != internal_default_instance() && _impl_.transaction_hash_ != nullptr;
}
inline bool SubscribeLogsReply::has_transaction_hash() const {
  return _internal_has_transaction_hash();
}
inline const ::types::H256& SubscribeLogsReply::_internal_transaction_hash() const {
  const ::types::H256* p = _impl_.transaction_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& SubscribeLogsReply::transaction_hash() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.transaction_hash)
  return _internal_transaction_hash();
}
inline void SubscribeLogsReply::unsafe_arena_set_allocated_transaction_hash(
    ::types::H256* transaction_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_hash_);
  }
  _impl_.transaction_hash_ = transaction_hash;
  if (transaction_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.SubscribeLogsReply.transaction_hash)
}
inline ::types::H256* SubscribeLogsReply::release_transaction_hash() {
  
  ::types::H256* temp = _impl_.transaction_hash_;
  _impl_.transaction_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* SubscribeLogsReply::unsafe_arena_release_transaction_hash() {
  // @@protoc_insertion_point(field_release:remote.SubscribeLogsReply.transaction_hash)
  
  ::types::H256* temp = _impl_.transaction_hash_;
  _impl_.transaction_hash_ = nullptr;
  return temp;
}
inline ::types::H256* SubscribeLogsReply::_internal_mutable_transaction_hash() {
  
  if (_impl_.transaction_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.transaction_hash_ = p;
  }
  return _impl_.transaction_hash_;
}
inline ::types::H256* SubscribeLogsReply::mutable_transaction_hash() {
  ::types::H256* _msg = _internal_mutable_transaction_hash();
  // @@protoc_insertion_point(field_mutable:remote.SubscribeLogsReply.transaction_hash)
  return _msg;
}
inline void SubscribeLogsReply::set_allocated_transaction_hash(::types::H256* transaction_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_hash_);
  }
  if (transaction_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_hash));
    if (message_arena != submessage_arena) {
      transaction_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_hash_ = transaction_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.SubscribeLogsReply.transaction_hash)
}

// uint64 transaction_index = 8;
inline void SubscribeLogsReply::clear_transaction_index() {
  _impl_.transaction_index_ = uint64_t{0u};
}
inline uint64_t SubscribeLogsReply::_internal_transaction_index() const {
  return _impl_.transaction_index_;
}
inline uint64_t SubscribeLogsReply::transaction_index() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.transaction_index)
  return _internal_transaction_index();
}
inline void SubscribeLogsReply::_internal_set_transaction_index(uint64_t value) {
  
  _impl_.transaction_index_ = value;
}
inline void SubscribeLogsReply::set_transaction_index(uint64_t value) {
  _internal_set_transaction_index(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeLogsReply.transaction_index)
}

// bool removed = 9;
inline void SubscribeLogsReply::clear_removed() {
  _impl_.removed_ = false;
}
inline bool SubscribeLogsReply::_internal_removed() const {
  return _impl_.removed_;
}
inline bool SubscribeLogsReply::removed() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeLogsReply.removed)
  return _internal_removed();
}
inline void SubscribeLogsReply::_internal_set_removed(bool value) {
  
  _impl_.removed_ = value;
}
inline void SubscribeLogsReply::set_removed(bool value) {
  _internal_set_removed(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeLogsReply.removed)
}

// -------------------------------------------------------------------

// BlockRequest

// uint64 block_height = 2;
inline void BlockRequest::clear_block_height() {
  _impl_.block_height_ = uint64_t{0u};
}
inline uint64_t BlockRequest::_internal_block_height() const {
  return _impl_.block_height_;
}
inline uint64_t BlockRequest::block_height() const {
  // @@protoc_insertion_point(field_get:remote.BlockRequest.block_height)
  return _internal_block_height();
}
inline void BlockRequest::_internal_set_block_height(uint64_t value) {
  
  _impl_.block_height_ = value;
}
inline void BlockRequest::set_block_height(uint64_t value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:remote.BlockRequest.block_height)
}

// .types.H256 block_hash = 3;
inline bool BlockRequest::_internal_has_block_hash() const {
  return this != internal_default_instance() && _impl_.block_hash_ != nullptr;
}
inline bool BlockRequest::has_block_hash() const {
  return _internal_has_block_hash();
}
inline const ::types::H256& BlockRequest::_internal_block_hash() const {
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& BlockRequest::block_hash() const {
  // @@protoc_insertion_point(field_get:remote.BlockRequest.block_hash)
  return _internal_block_hash();
}
inline void BlockRequest::unsafe_arena_set_allocated_block_hash(
    ::types::H256* block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = block_hash;
  if (block_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.BlockRequest.block_hash)
}
inline ::types::H256* BlockRequest::release_block_hash() {
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* BlockRequest::unsafe_arena_release_block_hash() {
  // @@protoc_insertion_point(field_release:remote.BlockRequest.block_hash)
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* BlockRequest::_internal_mutable_block_hash() {
  
  if (_impl_.block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.block_hash_ = p;
  }
  return _impl_.block_hash_;
}
inline ::types::H256* BlockRequest::mutable_block_hash() {
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:remote.BlockRequest.block_hash)
  return _msg;
}
inline void BlockRequest::set_allocated_block_hash(::types::H256* block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  if (block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_hash));
    if (message_arena != submessage_arena) {
      block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_hash_ = block_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.BlockRequest.block_hash)
}

// -------------------------------------------------------------------

// BlockReply

// bytes block_rlp = 1;
inline void BlockReply::clear_block_rlp() {
  _impl_.block_rlp_.ClearToEmpty();
}
inline const std::string& BlockReply::block_rlp() const {
  // @@protoc_insertion_point(field_get:remote.BlockReply.block_rlp)
  return _internal_block_rlp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockReply::set_block_rlp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_rlp_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.BlockReply.block_rlp)
}
inline std::string* BlockReply::mutable_block_rlp() {
  std::string* _s = _internal_mutable_block_rlp();
  // @@protoc_insertion_point(field_mutable:remote.BlockReply.block_rlp)
  return _s;
}
inline const std::string& BlockReply::_internal_block_rlp() const {
  return _impl_.block_rlp_.Get();
}
inline void BlockReply::_internal_set_block_rlp(const std::string& value) {
  
  _impl_.block_rlp_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockReply::_internal_mutable_block_rlp() {
  
  return _impl_.block_rlp_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockReply::release_block_rlp() {
  // @@protoc_insertion_point(field_release:remote.BlockReply.block_rlp)
  return _impl_.block_rlp_.Release();
}
inline void BlockReply::set_allocated_block_rlp(std::string* block_rlp) {
  if (block_rlp != nullptr) {
    
  } else {
    
  }
  _impl_.block_rlp_.SetAllocated(block_rlp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_rlp_.IsDefault()) {
    _impl_.block_rlp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.BlockReply.block_rlp)
}

// bytes senders = 2;
inline void BlockReply::clear_senders() {
  _impl_.senders_.ClearToEmpty();
}
inline const std::string& BlockReply::senders() const {
  // @@protoc_insertion_point(field_get:remote.BlockReply.senders)
  return _internal_senders();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockReply::set_senders(ArgT0&& arg0, ArgT... args) {
 
 _impl_.senders_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.BlockReply.senders)
}
inline std::string* BlockReply::mutable_senders() {
  std::string* _s = _internal_mutable_senders();
  // @@protoc_insertion_point(field_mutable:remote.BlockReply.senders)
  return _s;
}
inline const std::string& BlockReply::_internal_senders() const {
  return _impl_.senders_.Get();
}
inline void BlockReply::_internal_set_senders(const std::string& value) {
  
  _impl_.senders_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockReply::_internal_mutable_senders() {
  
  return _impl_.senders_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockReply::release_senders() {
  // @@protoc_insertion_point(field_release:remote.BlockReply.senders)
  return _impl_.senders_.Release();
}
inline void BlockReply::set_allocated_senders(std::string* senders) {
  if (senders != nullptr) {
    
  } else {
    
  }
  _impl_.senders_.SetAllocated(senders, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.senders_.IsDefault()) {
    _impl_.senders_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.BlockReply.senders)
}

// -------------------------------------------------------------------

// TxnLookupRequest

// .types.H256 txn_hash = 1;
inline bool TxnLookupRequest::_internal_has_txn_hash() const {
  return this != internal_default_instance() && _impl_.txn_hash_ != nullptr;
}
inline bool TxnLookupRequest::has_txn_hash() const {
  return _internal_has_txn_hash();
}
inline const ::types::H256& TxnLookupRequest::_internal_txn_hash() const {
  const ::types::H256* p = _impl_.txn_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& TxnLookupRequest::txn_hash() const {
  // @@protoc_insertion_point(field_get:remote.TxnLookupRequest.txn_hash)
  return _internal_txn_hash();
}
inline void TxnLookupRequest::unsafe_arena_set_allocated_txn_hash(
    ::types::H256* txn_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.txn_hash_);
  }
  _impl_.txn_hash_ = txn_hash;
  if (txn_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.TxnLookupRequest.txn_hash)
}
inline ::types::H256* TxnLookupRequest::release_txn_hash() {
  
  ::types::H256* temp = _impl_.txn_hash_;
  _impl_.txn_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* TxnLookupRequest::unsafe_arena_release_txn_hash() {
  // @@protoc_insertion_point(field_release:remote.TxnLookupRequest.txn_hash)
  
  ::types::H256* temp = _impl_.txn_hash_;
  _impl_.txn_hash_ = nullptr;
  return temp;
}
inline ::types::H256* TxnLookupRequest::_internal_mutable_txn_hash() {
  
  if (_impl_.txn_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.txn_hash_ = p;
  }
  return _impl_.txn_hash_;
}
inline ::types::H256* TxnLookupRequest::mutable_txn_hash() {
  ::types::H256* _msg = _internal_mutable_txn_hash();
  // @@protoc_insertion_point(field_mutable:remote.TxnLookupRequest.txn_hash)
  return _msg;
}
inline void TxnLookupRequest::set_allocated_txn_hash(::types::H256* txn_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.txn_hash_);
  }
  if (txn_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_hash));
    if (message_arena != submessage_arena) {
      txn_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.txn_hash_ = txn_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.TxnLookupRequest.txn_hash)
}

// -------------------------------------------------------------------

// TxnLookupReply

// uint64 block_number = 1;
inline void TxnLookupReply::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
}
inline uint64_t TxnLookupReply::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t TxnLookupReply::block_number() const {
  // @@protoc_insertion_point(field_get:remote.TxnLookupReply.block_number)
  return _internal_block_number();
}
inline void TxnLookupReply::_internal_set_block_number(uint64_t value) {
  
  _impl_.block_number_ = value;
}
inline void TxnLookupReply::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:remote.TxnLookupReply.block_number)
}

// -------------------------------------------------------------------

// NodesInfoRequest

// uint32 limit = 1;
inline void NodesInfoRequest::clear_limit() {
  _impl_.limit_ = 0u;
}
inline uint32_t NodesInfoRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline uint32_t NodesInfoRequest::limit() const {
  // @@protoc_insertion_point(field_get:remote.NodesInfoRequest.limit)
  return _internal_limit();
}
inline void NodesInfoRequest::_internal_set_limit(uint32_t value) {
  
  _impl_.limit_ = value;
}
inline void NodesInfoRequest::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:remote.NodesInfoRequest.limit)
}

// -------------------------------------------------------------------

// NodesInfoReply

// repeated .types.NodeInfoReply nodes_info = 1;
inline int NodesInfoReply::_internal_nodes_info_size() const {
  return _impl_.nodes_info_.size();
}
inline int NodesInfoReply::nodes_info_size() const {
  return _internal_nodes_info_size();
}
inline ::types::NodeInfoReply* NodesInfoReply::mutable_nodes_info(int index) {
  // @@protoc_insertion_point(field_mutable:remote.NodesInfoReply.nodes_info)
  return _impl_.nodes_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply >*
NodesInfoReply::mutable_nodes_info() {
  // @@protoc_insertion_point(field_mutable_list:remote.NodesInfoReply.nodes_info)
  return &_impl_.nodes_info_;
}
inline const ::types::NodeInfoReply& NodesInfoReply::_internal_nodes_info(int index) const {
  return _impl_.nodes_info_.Get(index);
}
inline const ::types::NodeInfoReply& NodesInfoReply::nodes_info(int index) const {
  // @@protoc_insertion_point(field_get:remote.NodesInfoReply.nodes_info)
  return _internal_nodes_info(index);
}
inline ::types::NodeInfoReply* NodesInfoReply::_internal_add_nodes_info() {
  return _impl_.nodes_info_.Add();
}
inline ::types::NodeInfoReply* NodesInfoReply::add_nodes_info() {
  ::types::NodeInfoReply* _add = _internal_add_nodes_info();
  // @@protoc_insertion_point(field_add:remote.NodesInfoReply.nodes_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply >&
NodesInfoReply::nodes_info() const {
  // @@protoc_insertion_point(field_list:remote.NodesInfoReply.nodes_info)
  return _impl_.nodes_info_;
}

// -------------------------------------------------------------------

// PeersReply

// repeated .types.PeerInfo peers = 1;
inline int PeersReply::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int PeersReply::peers_size() const {
  return _internal_peers_size();
}
inline ::types::PeerInfo* PeersReply::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:remote.PeersReply.peers)
  return _impl_.peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo >*
PeersReply::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:remote.PeersReply.peers)
  return &_impl_.peers_;
}
inline const ::types::PeerInfo& PeersReply::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const ::types::PeerInfo& PeersReply::peers(int index) const {
  // @@protoc_insertion_point(field_get:remote.PeersReply.peers)
  return _internal_peers(index);
}
inline ::types::PeerInfo* PeersReply::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline ::types::PeerInfo* PeersReply::add_peers() {
  ::types::PeerInfo* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:remote.PeersReply.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo >&
PeersReply::peers() const {
  // @@protoc_insertion_point(field_list:remote.PeersReply.peers)
  return _impl_.peers_;
}

// -------------------------------------------------------------------

// PendingBlockReply

// bytes block_rlp = 1;
inline void PendingBlockReply::clear_block_rlp() {
  _impl_.block_rlp_.ClearToEmpty();
}
inline const std::string& PendingBlockReply::block_rlp() const {
  // @@protoc_insertion_point(field_get:remote.PendingBlockReply.block_rlp)
  return _internal_block_rlp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PendingBlockReply::set_block_rlp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_rlp_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.PendingBlockReply.block_rlp)
}
inline std::string* PendingBlockReply::mutable_block_rlp() {
  std::string* _s = _internal_mutable_block_rlp();
  // @@protoc_insertion_point(field_mutable:remote.PendingBlockReply.block_rlp)
  return _s;
}
inline const std::string& PendingBlockReply::_internal_block_rlp() const {
  return _impl_.block_rlp_.Get();
}
inline void PendingBlockReply::_internal_set_block_rlp(const std::string& value) {
  
  _impl_.block_rlp_.Set(value, GetArenaForAllocation());
}
inline std::string* PendingBlockReply::_internal_mutable_block_rlp() {
  
  return _impl_.block_rlp_.Mutable(GetArenaForAllocation());
}
inline std::string* PendingBlockReply::release_block_rlp() {
  // @@protoc_insertion_point(field_release:remote.PendingBlockReply.block_rlp)
  return _impl_.block_rlp_.Release();
}
inline void PendingBlockReply::set_allocated_block_rlp(std::string* block_rlp) {
  if (block_rlp != nullptr) {
    
  } else {
    
  }
  _impl_.block_rlp_.SetAllocated(block_rlp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_rlp_.IsDefault()) {
    _impl_.block_rlp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.PendingBlockReply.block_rlp)
}

// -------------------------------------------------------------------

// EngineGetPayloadBodiesByHashV1Request

// repeated .types.H256 hashes = 1;
inline int EngineGetPayloadBodiesByHashV1Request::_internal_hashes_size() const {
  return _impl_.hashes_.size();
}
inline int EngineGetPayloadBodiesByHashV1Request::hashes_size() const {
  return _internal_hashes_size();
}
inline ::types::H256* EngineGetPayloadBodiesByHashV1Request::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:remote.EngineGetPayloadBodiesByHashV1Request.hashes)
  return _impl_.hashes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >*
EngineGetPayloadBodiesByHashV1Request::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:remote.EngineGetPayloadBodiesByHashV1Request.hashes)
  return &_impl_.hashes_;
}
inline const ::types::H256& EngineGetPayloadBodiesByHashV1Request::_internal_hashes(int index) const {
  return _impl_.hashes_.Get(index);
}
inline const ::types::H256& EngineGetPayloadBodiesByHashV1Request::hashes(int index) const {
  // @@protoc_insertion_point(field_get:remote.EngineGetPayloadBodiesByHashV1Request.hashes)
  return _internal_hashes(index);
}
inline ::types::H256* EngineGetPayloadBodiesByHashV1Request::_internal_add_hashes() {
  return _impl_.hashes_.Add();
}
inline ::types::H256* EngineGetPayloadBodiesByHashV1Request::add_hashes() {
  ::types::H256* _add = _internal_add_hashes();
  // @@protoc_insertion_point(field_add:remote.EngineGetPayloadBodiesByHashV1Request.hashes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H256 >&
EngineGetPayloadBodiesByHashV1Request::hashes() const {
  // @@protoc_insertion_point(field_list:remote.EngineGetPayloadBodiesByHashV1Request.hashes)
  return _impl_.hashes_;
}

// -------------------------------------------------------------------

// EngineGetPayloadBodiesByRangeV1Request

// uint64 start = 1;
inline void EngineGetPayloadBodiesByRangeV1Request::clear_start() {
  _impl_.start_ = uint64_t{0u};
}
inline uint64_t EngineGetPayloadBodiesByRangeV1Request::_internal_start() const {
  return _impl_.start_;
}
inline uint64_t EngineGetPayloadBodiesByRangeV1Request::start() const {
  // @@protoc_insertion_point(field_get:remote.EngineGetPayloadBodiesByRangeV1Request.start)
  return _internal_start();
}
inline void EngineGetPayloadBodiesByRangeV1Request::_internal_set_start(uint64_t value) {
  
  _impl_.start_ = value;
}
inline void EngineGetPayloadBodiesByRangeV1Request::set_start(uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:remote.EngineGetPayloadBodiesByRangeV1Request.start)
}

// uint64 count = 2;
inline void EngineGetPayloadBodiesByRangeV1Request::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t EngineGetPayloadBodiesByRangeV1Request::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t EngineGetPayloadBodiesByRangeV1Request::count() const {
  // @@protoc_insertion_point(field_get:remote.EngineGetPayloadBodiesByRangeV1Request.count)
  return _internal_count();
}
inline void EngineGetPayloadBodiesByRangeV1Request::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void EngineGetPayloadBodiesByRangeV1Request::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:remote.EngineGetPayloadBodiesByRangeV1Request.count)
}

// -------------------------------------------------------------------

// EngineGetPayloadBodiesV1Response

// repeated .types.ExecutionPayloadBodyV1 bodies = 1;
inline int EngineGetPayloadBodiesV1Response::_internal_bodies_size() const {
  return _impl_.bodies_.size();
}
inline int EngineGetPayloadBodiesV1Response::bodies_size() const {
  return _internal_bodies_size();
}
inline ::types::ExecutionPayloadBodyV1* EngineGetPayloadBodiesV1Response::mutable_bodies(int index) {
  // @@protoc_insertion_point(field_mutable:remote.EngineGetPayloadBodiesV1Response.bodies)
  return _impl_.bodies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::ExecutionPayloadBodyV1 >*
EngineGetPayloadBodiesV1Response::mutable_bodies() {
  // @@protoc_insertion_point(field_mutable_list:remote.EngineGetPayloadBodiesV1Response.bodies)
  return &_impl_.bodies_;
}
inline const ::types::ExecutionPayloadBodyV1& EngineGetPayloadBodiesV1Response::_internal_bodies(int index) const {
  return _impl_.bodies_.Get(index);
}
inline const ::types::ExecutionPayloadBodyV1& EngineGetPayloadBodiesV1Response::bodies(int index) const {
  // @@protoc_insertion_point(field_get:remote.EngineGetPayloadBodiesV1Response.bodies)
  return _internal_bodies(index);
}
inline ::types::ExecutionPayloadBodyV1* EngineGetPayloadBodiesV1Response::_internal_add_bodies() {
  return _impl_.bodies_.Add();
}
inline ::types::ExecutionPayloadBodyV1* EngineGetPayloadBodiesV1Response::add_bodies() {
  ::types::ExecutionPayloadBodyV1* _add = _internal_add_bodies();
  // @@protoc_insertion_point(field_add:remote.EngineGetPayloadBodiesV1Response.bodies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::ExecutionPayloadBodyV1 >&
EngineGetPayloadBodiesV1Response::bodies() const {
  // @@protoc_insertion_point(field_list:remote.EngineGetPayloadBodiesV1Response.bodies)
  return _impl_.bodies_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace remote

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::remote::Event> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Event>() {
  return ::remote::Event_descriptor();
}
template <> struct is_proto_enum< ::remote::EngineStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::EngineStatus>() {
  return ::remote::EngineStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto
