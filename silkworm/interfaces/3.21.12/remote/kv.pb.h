// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remote/kv.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_remote_2fkv_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_remote_2fkv_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_remote_2fkv_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_remote_2fkv_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_remote_2fkv_2eproto;
namespace remote {
class AccountChange;
struct AccountChangeDefaultTypeInternal;
extern AccountChangeDefaultTypeInternal _AccountChange_default_instance_;
class Cursor;
struct CursorDefaultTypeInternal;
extern CursorDefaultTypeInternal _Cursor_default_instance_;
class GetLatestReply;
struct GetLatestReplyDefaultTypeInternal;
extern GetLatestReplyDefaultTypeInternal _GetLatestReply_default_instance_;
class GetLatestReq;
struct GetLatestReqDefaultTypeInternal;
extern GetLatestReqDefaultTypeInternal _GetLatestReq_default_instance_;
class HistoryRangeReq;
struct HistoryRangeReqDefaultTypeInternal;
extern HistoryRangeReqDefaultTypeInternal _HistoryRangeReq_default_instance_;
class HistorySeekReply;
struct HistorySeekReplyDefaultTypeInternal;
extern HistorySeekReplyDefaultTypeInternal _HistorySeekReply_default_instance_;
class HistorySeekReq;
struct HistorySeekReqDefaultTypeInternal;
extern HistorySeekReqDefaultTypeInternal _HistorySeekReq_default_instance_;
class IndexPagination;
struct IndexPaginationDefaultTypeInternal;
extern IndexPaginationDefaultTypeInternal _IndexPagination_default_instance_;
class IndexRangeReply;
struct IndexRangeReplyDefaultTypeInternal;
extern IndexRangeReplyDefaultTypeInternal _IndexRangeReply_default_instance_;
class IndexRangeReq;
struct IndexRangeReqDefaultTypeInternal;
extern IndexRangeReqDefaultTypeInternal _IndexRangeReq_default_instance_;
class Pair;
struct PairDefaultTypeInternal;
extern PairDefaultTypeInternal _Pair_default_instance_;
class Pairs;
struct PairsDefaultTypeInternal;
extern PairsDefaultTypeInternal _Pairs_default_instance_;
class PairsPagination;
struct PairsPaginationDefaultTypeInternal;
extern PairsPaginationDefaultTypeInternal _PairsPagination_default_instance_;
class RangeAsOfReq;
struct RangeAsOfReqDefaultTypeInternal;
extern RangeAsOfReqDefaultTypeInternal _RangeAsOfReq_default_instance_;
class RangeReq;
struct RangeReqDefaultTypeInternal;
extern RangeReqDefaultTypeInternal _RangeReq_default_instance_;
class SnapshotsReply;
struct SnapshotsReplyDefaultTypeInternal;
extern SnapshotsReplyDefaultTypeInternal _SnapshotsReply_default_instance_;
class SnapshotsRequest;
struct SnapshotsRequestDefaultTypeInternal;
extern SnapshotsRequestDefaultTypeInternal _SnapshotsRequest_default_instance_;
class StateChange;
struct StateChangeDefaultTypeInternal;
extern StateChangeDefaultTypeInternal _StateChange_default_instance_;
class StateChangeBatch;
struct StateChangeBatchDefaultTypeInternal;
extern StateChangeBatchDefaultTypeInternal _StateChangeBatch_default_instance_;
class StateChangeRequest;
struct StateChangeRequestDefaultTypeInternal;
extern StateChangeRequestDefaultTypeInternal _StateChangeRequest_default_instance_;
class StorageChange;
struct StorageChangeDefaultTypeInternal;
extern StorageChangeDefaultTypeInternal _StorageChange_default_instance_;
}  // namespace remote
PROTOBUF_NAMESPACE_OPEN
template<> ::remote::AccountChange* Arena::CreateMaybeMessage<::remote::AccountChange>(Arena*);
template<> ::remote::Cursor* Arena::CreateMaybeMessage<::remote::Cursor>(Arena*);
template<> ::remote::GetLatestReply* Arena::CreateMaybeMessage<::remote::GetLatestReply>(Arena*);
template<> ::remote::GetLatestReq* Arena::CreateMaybeMessage<::remote::GetLatestReq>(Arena*);
template<> ::remote::HistoryRangeReq* Arena::CreateMaybeMessage<::remote::HistoryRangeReq>(Arena*);
template<> ::remote::HistorySeekReply* Arena::CreateMaybeMessage<::remote::HistorySeekReply>(Arena*);
template<> ::remote::HistorySeekReq* Arena::CreateMaybeMessage<::remote::HistorySeekReq>(Arena*);
template<> ::remote::IndexPagination* Arena::CreateMaybeMessage<::remote::IndexPagination>(Arena*);
template<> ::remote::IndexRangeReply* Arena::CreateMaybeMessage<::remote::IndexRangeReply>(Arena*);
template<> ::remote::IndexRangeReq* Arena::CreateMaybeMessage<::remote::IndexRangeReq>(Arena*);
template<> ::remote::Pair* Arena::CreateMaybeMessage<::remote::Pair>(Arena*);
template<> ::remote::Pairs* Arena::CreateMaybeMessage<::remote::Pairs>(Arena*);
template<> ::remote::PairsPagination* Arena::CreateMaybeMessage<::remote::PairsPagination>(Arena*);
template<> ::remote::RangeAsOfReq* Arena::CreateMaybeMessage<::remote::RangeAsOfReq>(Arena*);
template<> ::remote::RangeReq* Arena::CreateMaybeMessage<::remote::RangeReq>(Arena*);
template<> ::remote::SnapshotsReply* Arena::CreateMaybeMessage<::remote::SnapshotsReply>(Arena*);
template<> ::remote::SnapshotsRequest* Arena::CreateMaybeMessage<::remote::SnapshotsRequest>(Arena*);
template<> ::remote::StateChange* Arena::CreateMaybeMessage<::remote::StateChange>(Arena*);
template<> ::remote::StateChangeBatch* Arena::CreateMaybeMessage<::remote::StateChangeBatch>(Arena*);
template<> ::remote::StateChangeRequest* Arena::CreateMaybeMessage<::remote::StateChangeRequest>(Arena*);
template<> ::remote::StorageChange* Arena::CreateMaybeMessage<::remote::StorageChange>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace remote {

enum Op : int {
  FIRST = 0,
  FIRST_DUP = 1,
  SEEK = 2,
  SEEK_BOTH = 3,
  CURRENT = 4,
  LAST = 6,
  LAST_DUP = 7,
  NEXT = 8,
  NEXT_DUP = 9,
  NEXT_NO_DUP = 11,
  PREV = 12,
  PREV_DUP = 13,
  PREV_NO_DUP = 14,
  SEEK_EXACT = 15,
  SEEK_BOTH_EXACT = 16,
  OPEN = 30,
  CLOSE = 31,
  OPEN_DUP_SORT = 32,
  Op_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Op_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Op_IsValid(int value);
constexpr Op Op_MIN = FIRST;
constexpr Op Op_MAX = OPEN_DUP_SORT;
constexpr int Op_ARRAYSIZE = Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Op_descriptor();
template<typename T>
inline const std::string& Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Op_descriptor(), enum_t_value);
}
inline bool Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Op>(
    Op_descriptor(), name, value);
}
enum Action : int {
  STORAGE = 0,
  UPSERT = 1,
  CODE = 2,
  UPSERT_CODE = 3,
  REMOVE = 4,
  Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Action_IsValid(int value);
constexpr Action Action_MIN = STORAGE;
constexpr Action Action_MAX = REMOVE;
constexpr int Action_ARRAYSIZE = Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor();
template<typename T>
inline const std::string& Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Action_descriptor(), enum_t_value);
}
inline bool Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
enum Direction : int {
  FORWARD = 0,
  UNWIND = 1,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = FORWARD;
constexpr Direction Direction_MAX = UNWIND;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
// ===================================================================

class Cursor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.Cursor) */ {
 public:
  inline Cursor() : Cursor(nullptr) {}
  ~Cursor() override;
  explicit PROTOBUF_CONSTEXPR Cursor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cursor(const Cursor& from);
  Cursor(Cursor&& from) noexcept
    : Cursor() {
    *this = ::std::move(from);
  }

  inline Cursor& operator=(const Cursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cursor& operator=(Cursor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cursor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cursor* internal_default_instance() {
    return reinterpret_cast<const Cursor*>(
               &_Cursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Cursor& a, Cursor& b) {
    a.Swap(&b);
  }
  inline void Swap(Cursor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cursor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cursor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cursor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cursor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cursor& from) {
    Cursor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cursor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.Cursor";
  }
  protected:
  explicit Cursor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketNameFieldNumber = 2,
    kKFieldNumber = 4,
    kVFieldNumber = 5,
    kOpFieldNumber = 1,
    kCursorFieldNumber = 3,
  };
  // string bucket_name = 2;
  void clear_bucket_name();
  const std::string& bucket_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket_name();
  PROTOBUF_NODISCARD std::string* release_bucket_name();
  void set_allocated_bucket_name(std::string* bucket_name);
  private:
  const std::string& _internal_bucket_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket_name(const std::string& value);
  std::string* _internal_mutable_bucket_name();
  public:

  // bytes k = 4;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // bytes v = 5;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // .remote.Op op = 1;
  void clear_op();
  ::remote::Op op() const;
  void set_op(::remote::Op value);
  private:
  ::remote::Op _internal_op() const;
  void _internal_set_op(::remote::Op value);
  public:

  // uint32 cursor = 3;
  void clear_cursor();
  uint32_t cursor() const;
  void set_cursor(uint32_t value);
  private:
  uint32_t _internal_cursor() const;
  void _internal_set_cursor(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.Cursor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
    int op_;
    uint32_t cursor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class Pair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.Pair) */ {
 public:
  inline Pair() : Pair(nullptr) {}
  ~Pair() override;
  explicit PROTOBUF_CONSTEXPR Pair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pair(const Pair& from);
  Pair(Pair&& from) noexcept
    : Pair() {
    *this = ::std::move(from);
  }

  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pair& operator=(Pair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pair& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pair* internal_default_instance() {
    return reinterpret_cast<const Pair*>(
               &_Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Pair& a, Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(Pair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pair& from) {
    Pair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.Pair";
  }
  protected:
  explicit Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKFieldNumber = 1,
    kVFieldNumber = 2,
    kViewIdFieldNumber = 4,
    kTxIdFieldNumber = 5,
    kCursorIdFieldNumber = 3,
  };
  // bytes k = 1;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // bytes v = 2;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // uint64 view_id = 4;
  void clear_view_id();
  uint64_t view_id() const;
  void set_view_id(uint64_t value);
  private:
  uint64_t _internal_view_id() const;
  void _internal_set_view_id(uint64_t value);
  public:

  // uint64 tx_id = 5;
  void clear_tx_id();
  uint64_t tx_id() const;
  void set_tx_id(uint64_t value);
  private:
  uint64_t _internal_tx_id() const;
  void _internal_set_tx_id(uint64_t value);
  public:

  // uint32 cursor_id = 3;
  void clear_cursor_id();
  uint32_t cursor_id() const;
  void set_cursor_id(uint32_t value);
  private:
  uint32_t _internal_cursor_id() const;
  void _internal_set_cursor_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.Pair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
    uint64_t view_id_;
    uint64_t tx_id_;
    uint32_t cursor_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class StorageChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.StorageChange) */ {
 public:
  inline StorageChange() : StorageChange(nullptr) {}
  ~StorageChange() override;
  explicit PROTOBUF_CONSTEXPR StorageChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageChange(const StorageChange& from);
  StorageChange(StorageChange&& from) noexcept
    : StorageChange() {
    *this = ::std::move(from);
  }

  inline StorageChange& operator=(const StorageChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageChange& operator=(StorageChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageChange* internal_default_instance() {
    return reinterpret_cast<const StorageChange*>(
               &_StorageChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StorageChange& a, StorageChange& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageChange& from) {
    StorageChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.StorageChange";
  }
  protected:
  explicit StorageChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kLocationFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .types.H256 location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::types::H256& location() const;
  PROTOBUF_NODISCARD ::types::H256* release_location();
  ::types::H256* mutable_location();
  void set_allocated_location(::types::H256* location);
  private:
  const ::types::H256& _internal_location() const;
  ::types::H256* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::types::H256* location);
  ::types::H256* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:remote.StorageChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::types::H256* location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class AccountChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.AccountChange) */ {
 public:
  inline AccountChange() : AccountChange(nullptr) {}
  ~AccountChange() override;
  explicit PROTOBUF_CONSTEXPR AccountChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountChange(const AccountChange& from);
  AccountChange(AccountChange&& from) noexcept
    : AccountChange() {
    *this = ::std::move(from);
  }

  inline AccountChange& operator=(const AccountChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountChange& operator=(AccountChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountChange* internal_default_instance() {
    return reinterpret_cast<const AccountChange*>(
               &_AccountChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccountChange& a, AccountChange& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountChange& from) {
    AccountChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.AccountChange";
  }
  protected:
  explicit AccountChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageChangesFieldNumber = 6,
    kDataFieldNumber = 4,
    kCodeFieldNumber = 5,
    kAddressFieldNumber = 1,
    kIncarnationFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // repeated .remote.StorageChange storage_changes = 6;
  int storage_changes_size() const;
  private:
  int _internal_storage_changes_size() const;
  public:
  void clear_storage_changes();
  ::remote::StorageChange* mutable_storage_changes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange >*
      mutable_storage_changes();
  private:
  const ::remote::StorageChange& _internal_storage_changes(int index) const;
  ::remote::StorageChange* _internal_add_storage_changes();
  public:
  const ::remote::StorageChange& storage_changes(int index) const;
  ::remote::StorageChange* add_storage_changes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange >&
      storage_changes() const;

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes code = 5;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // .types.H160 address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::types::H160& address() const;
  PROTOBUF_NODISCARD ::types::H160* release_address();
  ::types::H160* mutable_address();
  void set_allocated_address(::types::H160* address);
  private:
  const ::types::H160& _internal_address() const;
  ::types::H160* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::types::H160* address);
  ::types::H160* unsafe_arena_release_address();

  // uint64 incarnation = 2;
  void clear_incarnation();
  uint64_t incarnation() const;
  void set_incarnation(uint64_t value);
  private:
  uint64_t _internal_incarnation() const;
  void _internal_set_incarnation(uint64_t value);
  public:

  // .remote.Action action = 3;
  void clear_action();
  ::remote::Action action() const;
  void set_action(::remote::Action value);
  private:
  ::remote::Action _internal_action() const;
  void _internal_set_action(::remote::Action value);
  public:

  // @@protoc_insertion_point(class_scope:remote.AccountChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange > storage_changes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::types::H160* address_;
    uint64_t incarnation_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class StateChangeBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.StateChangeBatch) */ {
 public:
  inline StateChangeBatch() : StateChangeBatch(nullptr) {}
  ~StateChangeBatch() override;
  explicit PROTOBUF_CONSTEXPR StateChangeBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateChangeBatch(const StateChangeBatch& from);
  StateChangeBatch(StateChangeBatch&& from) noexcept
    : StateChangeBatch() {
    *this = ::std::move(from);
  }

  inline StateChangeBatch& operator=(const StateChangeBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateChangeBatch& operator=(StateChangeBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateChangeBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateChangeBatch* internal_default_instance() {
    return reinterpret_cast<const StateChangeBatch*>(
               &_StateChangeBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StateChangeBatch& a, StateChangeBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(StateChangeBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateChangeBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateChangeBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateChangeBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateChangeBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateChangeBatch& from) {
    StateChangeBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateChangeBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.StateChangeBatch";
  }
  protected:
  explicit StateChangeBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeBatchFieldNumber = 2,
    kStateVersionIdFieldNumber = 1,
    kPendingBlockBaseFeeFieldNumber = 3,
    kBlockGasLimitFieldNumber = 4,
    kFinalizedBlockFieldNumber = 5,
    kPendingBlobFeePerGasFieldNumber = 6,
  };
  // repeated .remote.StateChange change_batch = 2;
  int change_batch_size() const;
  private:
  int _internal_change_batch_size() const;
  public:
  void clear_change_batch();
  ::remote::StateChange* mutable_change_batch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange >*
      mutable_change_batch();
  private:
  const ::remote::StateChange& _internal_change_batch(int index) const;
  ::remote::StateChange* _internal_add_change_batch();
  public:
  const ::remote::StateChange& change_batch(int index) const;
  ::remote::StateChange* add_change_batch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange >&
      change_batch() const;

  // uint64 state_version_id = 1;
  void clear_state_version_id();
  uint64_t state_version_id() const;
  void set_state_version_id(uint64_t value);
  private:
  uint64_t _internal_state_version_id() const;
  void _internal_set_state_version_id(uint64_t value);
  public:

  // uint64 pending_block_base_fee = 3;
  void clear_pending_block_base_fee();
  uint64_t pending_block_base_fee() const;
  void set_pending_block_base_fee(uint64_t value);
  private:
  uint64_t _internal_pending_block_base_fee() const;
  void _internal_set_pending_block_base_fee(uint64_t value);
  public:

  // uint64 block_gas_limit = 4;
  void clear_block_gas_limit();
  uint64_t block_gas_limit() const;
  void set_block_gas_limit(uint64_t value);
  private:
  uint64_t _internal_block_gas_limit() const;
  void _internal_set_block_gas_limit(uint64_t value);
  public:

  // uint64 finalized_block = 5;
  void clear_finalized_block();
  uint64_t finalized_block() const;
  void set_finalized_block(uint64_t value);
  private:
  uint64_t _internal_finalized_block() const;
  void _internal_set_finalized_block(uint64_t value);
  public:

  // uint64 pending_blob_fee_per_gas = 6;
  void clear_pending_blob_fee_per_gas();
  uint64_t pending_blob_fee_per_gas() const;
  void set_pending_blob_fee_per_gas(uint64_t value);
  private:
  uint64_t _internal_pending_blob_fee_per_gas() const;
  void _internal_set_pending_blob_fee_per_gas(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.StateChangeBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange > change_batch_;
    uint64_t state_version_id_;
    uint64_t pending_block_base_fee_;
    uint64_t block_gas_limit_;
    uint64_t finalized_block_;
    uint64_t pending_blob_fee_per_gas_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class StateChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.StateChange) */ {
 public:
  inline StateChange() : StateChange(nullptr) {}
  ~StateChange() override;
  explicit PROTOBUF_CONSTEXPR StateChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateChange(const StateChange& from);
  StateChange(StateChange&& from) noexcept
    : StateChange() {
    *this = ::std::move(from);
  }

  inline StateChange& operator=(const StateChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateChange& operator=(StateChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateChange* internal_default_instance() {
    return reinterpret_cast<const StateChange*>(
               &_StateChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StateChange& a, StateChange& b) {
    a.Swap(&b);
  }
  inline void Swap(StateChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateChange& from) {
    StateChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.StateChange";
  }
  protected:
  explicit StateChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 4,
    kTxsFieldNumber = 5,
    kBlockHashFieldNumber = 3,
    kBlockHeightFieldNumber = 2,
    kDirectionFieldNumber = 1,
  };
  // repeated .remote.AccountChange changes = 4;
  int changes_size() const;
  private:
  int _internal_changes_size() const;
  public:
  void clear_changes();
  ::remote::AccountChange* mutable_changes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange >*
      mutable_changes();
  private:
  const ::remote::AccountChange& _internal_changes(int index) const;
  ::remote::AccountChange* _internal_add_changes();
  public:
  const ::remote::AccountChange& changes(int index) const;
  ::remote::AccountChange* add_changes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange >&
      changes() const;

  // repeated bytes txs = 5;
  int txs_size() const;
  private:
  int _internal_txs_size() const;
  public:
  void clear_txs();
  const std::string& txs(int index) const;
  std::string* mutable_txs(int index);
  void set_txs(int index, const std::string& value);
  void set_txs(int index, std::string&& value);
  void set_txs(int index, const char* value);
  void set_txs(int index, const void* value, size_t size);
  std::string* add_txs();
  void add_txs(const std::string& value);
  void add_txs(std::string&& value);
  void add_txs(const char* value);
  void add_txs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txs();
  private:
  const std::string& _internal_txs(int index) const;
  std::string* _internal_add_txs();
  public:

  // .types.H256 block_hash = 3;
  bool has_block_hash() const;
  private:
  bool _internal_has_block_hash() const;
  public:
  void clear_block_hash();
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* block_hash);
  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();
  public:
  void unsafe_arena_set_allocated_block_hash(
      ::types::H256* block_hash);
  ::types::H256* unsafe_arena_release_block_hash();

  // uint64 block_height = 2;
  void clear_block_height();
  uint64_t block_height() const;
  void set_block_height(uint64_t value);
  private:
  uint64_t _internal_block_height() const;
  void _internal_set_block_height(uint64_t value);
  public:

  // .remote.Direction direction = 1;
  void clear_direction();
  ::remote::Direction direction() const;
  void set_direction(::remote::Direction value);
  private:
  ::remote::Direction _internal_direction() const;
  void _internal_set_direction(::remote::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:remote.StateChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange > changes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txs_;
    ::types::H256* block_hash_;
    uint64_t block_height_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class StateChangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.StateChangeRequest) */ {
 public:
  inline StateChangeRequest() : StateChangeRequest(nullptr) {}
  ~StateChangeRequest() override;
  explicit PROTOBUF_CONSTEXPR StateChangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateChangeRequest(const StateChangeRequest& from);
  StateChangeRequest(StateChangeRequest&& from) noexcept
    : StateChangeRequest() {
    *this = ::std::move(from);
  }

  inline StateChangeRequest& operator=(const StateChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateChangeRequest& operator=(StateChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateChangeRequest* internal_default_instance() {
    return reinterpret_cast<const StateChangeRequest*>(
               &_StateChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StateChangeRequest& a, StateChangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StateChangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateChangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateChangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateChangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateChangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateChangeRequest& from) {
    StateChangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateChangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.StateChangeRequest";
  }
  protected:
  explicit StateChangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWithStorageFieldNumber = 1,
    kWithTransactionsFieldNumber = 2,
  };
  // bool with_storage = 1;
  void clear_with_storage();
  bool with_storage() const;
  void set_with_storage(bool value);
  private:
  bool _internal_with_storage() const;
  void _internal_set_with_storage(bool value);
  public:

  // bool with_transactions = 2;
  void clear_with_transactions();
  bool with_transactions() const;
  void set_with_transactions(bool value);
  private:
  bool _internal_with_transactions() const;
  void _internal_set_with_transactions(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.StateChangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool with_storage_;
    bool with_transactions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class SnapshotsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.SnapshotsRequest) */ {
 public:
  inline SnapshotsRequest() : SnapshotsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SnapshotsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotsRequest(const SnapshotsRequest& from);
  SnapshotsRequest(SnapshotsRequest&& from) noexcept
    : SnapshotsRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotsRequest& operator=(const SnapshotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotsRequest& operator=(SnapshotsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotsRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotsRequest*>(
               &_SnapshotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SnapshotsRequest& a, SnapshotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SnapshotsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SnapshotsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SnapshotsRequest";
  }
  protected:
  explicit SnapshotsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.SnapshotsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class SnapshotsReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SnapshotsReply) */ {
 public:
  inline SnapshotsReply() : SnapshotsReply(nullptr) {}
  ~SnapshotsReply() override;
  explicit PROTOBUF_CONSTEXPR SnapshotsReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotsReply(const SnapshotsReply& from);
  SnapshotsReply(SnapshotsReply&& from) noexcept
    : SnapshotsReply() {
    *this = ::std::move(from);
  }

  inline SnapshotsReply& operator=(const SnapshotsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotsReply& operator=(SnapshotsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotsReply* internal_default_instance() {
    return reinterpret_cast<const SnapshotsReply*>(
               &_SnapshotsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SnapshotsReply& a, SnapshotsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotsReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotsReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotsReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotsReply& from) {
    SnapshotsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotsReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SnapshotsReply";
  }
  protected:
  explicit SnapshotsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFilesFieldNumber = 1,
    kHistoryFilesFieldNumber = 2,
  };
  // repeated string blocks_files = 1;
  int blocks_files_size() const;
  private:
  int _internal_blocks_files_size() const;
  public:
  void clear_blocks_files();
  const std::string& blocks_files(int index) const;
  std::string* mutable_blocks_files(int index);
  void set_blocks_files(int index, const std::string& value);
  void set_blocks_files(int index, std::string&& value);
  void set_blocks_files(int index, const char* value);
  void set_blocks_files(int index, const char* value, size_t size);
  std::string* add_blocks_files();
  void add_blocks_files(const std::string& value);
  void add_blocks_files(std::string&& value);
  void add_blocks_files(const char* value);
  void add_blocks_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blocks_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blocks_files();
  private:
  const std::string& _internal_blocks_files(int index) const;
  std::string* _internal_add_blocks_files();
  public:

  // repeated string history_files = 2;
  int history_files_size() const;
  private:
  int _internal_history_files_size() const;
  public:
  void clear_history_files();
  const std::string& history_files(int index) const;
  std::string* mutable_history_files(int index);
  void set_history_files(int index, const std::string& value);
  void set_history_files(int index, std::string&& value);
  void set_history_files(int index, const char* value);
  void set_history_files(int index, const char* value, size_t size);
  std::string* add_history_files();
  void add_history_files(const std::string& value);
  void add_history_files(std::string&& value);
  void add_history_files(const char* value);
  void add_history_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& history_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_history_files();
  private:
  const std::string& _internal_history_files(int index) const;
  std::string* _internal_add_history_files();
  public:

  // @@protoc_insertion_point(class_scope:remote.SnapshotsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blocks_files_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> history_files_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class RangeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.RangeReq) */ {
 public:
  inline RangeReq() : RangeReq(nullptr) {}
  ~RangeReq() override;
  explicit PROTOBUF_CONSTEXPR RangeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeReq(const RangeReq& from);
  RangeReq(RangeReq&& from) noexcept
    : RangeReq() {
    *this = ::std::move(from);
  }

  inline RangeReq& operator=(const RangeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeReq& operator=(RangeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeReq* internal_default_instance() {
    return reinterpret_cast<const RangeReq*>(
               &_RangeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RangeReq& a, RangeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeReq& from) {
    RangeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.RangeReq";
  }
  protected:
  explicit RangeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 2,
    kFromPrefixFieldNumber = 3,
    kToPrefixFieldNumber = 4,
    kPageTokenFieldNumber = 8,
    kTxIdFieldNumber = 1,
    kLimitFieldNumber = 6,
    kOrderAscendFieldNumber = 5,
    kPageSizeFieldNumber = 7,
  };
  // string table = 2;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // bytes from_prefix = 3;
  void clear_from_prefix();
  const std::string& from_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_prefix();
  PROTOBUF_NODISCARD std::string* release_from_prefix();
  void set_allocated_from_prefix(std::string* from_prefix);
  private:
  const std::string& _internal_from_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_prefix(const std::string& value);
  std::string* _internal_mutable_from_prefix();
  public:

  // bytes to_prefix = 4;
  void clear_to_prefix();
  const std::string& to_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_prefix();
  PROTOBUF_NODISCARD std::string* release_to_prefix();
  void set_allocated_to_prefix(std::string* to_prefix);
  private:
  const std::string& _internal_to_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_prefix(const std::string& value);
  std::string* _internal_mutable_to_prefix();
  public:

  // string page_token = 8;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // uint64 tx_id = 1;
  void clear_tx_id();
  uint64_t tx_id() const;
  void set_tx_id(uint64_t value);
  private:
  uint64_t _internal_tx_id() const;
  void _internal_set_tx_id(uint64_t value);
  public:

  // sint64 limit = 6;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // bool order_ascend = 5;
  void clear_order_ascend();
  bool order_ascend() const;
  void set_order_ascend(bool value);
  private:
  bool _internal_order_ascend() const;
  void _internal_set_order_ascend(bool value);
  public:

  // int32 page_size = 7;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.RangeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    uint64_t tx_id_;
    int64_t limit_;
    bool order_ascend_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class GetLatestReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.GetLatestReq) */ {
 public:
  inline GetLatestReq() : GetLatestReq(nullptr) {}
  ~GetLatestReq() override;
  explicit PROTOBUF_CONSTEXPR GetLatestReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestReq(const GetLatestReq& from);
  GetLatestReq(GetLatestReq&& from) noexcept
    : GetLatestReq() {
    *this = ::std::move(from);
  }

  inline GetLatestReq& operator=(const GetLatestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestReq& operator=(GetLatestReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestReq* internal_default_instance() {
    return reinterpret_cast<const GetLatestReq*>(
               &_GetLatestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetLatestReq& a, GetLatestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLatestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLatestReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLatestReq& from) {
    GetLatestReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.GetLatestReq";
  }
  protected:
  explicit GetLatestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 2,
    kKFieldNumber = 3,
    kK2FieldNumber = 5,
    kTxIdFieldNumber = 1,
    kTsFieldNumber = 4,
    kLatestFieldNumber = 6,
  };
  // string table = 2;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // bytes k = 3;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // bytes k2 = 5;
  void clear_k2();
  const std::string& k2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k2();
  PROTOBUF_NODISCARD std::string* release_k2();
  void set_allocated_k2(std::string* k2);
  private:
  const std::string& _internal_k2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k2(const std::string& value);
  std::string* _internal_mutable_k2();
  public:

  // uint64 tx_id = 1;
  void clear_tx_id();
  uint64_t tx_id() const;
  void set_tx_id(uint64_t value);
  private:
  uint64_t _internal_tx_id() const;
  void _internal_set_tx_id(uint64_t value);
  public:

  // uint64 ts = 4;
  void clear_ts();
  uint64_t ts() const;
  void set_ts(uint64_t value);
  private:
  uint64_t _internal_ts() const;
  void _internal_set_ts(uint64_t value);
  public:

  // bool latest = 6;
  void clear_latest();
  bool latest() const;
  void set_latest(bool value);
  private:
  bool _internal_latest() const;
  void _internal_set_latest(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.GetLatestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k2_;
    uint64_t tx_id_;
    uint64_t ts_;
    bool latest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class GetLatestReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.GetLatestReply) */ {
 public:
  inline GetLatestReply() : GetLatestReply(nullptr) {}
  ~GetLatestReply() override;
  explicit PROTOBUF_CONSTEXPR GetLatestReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestReply(const GetLatestReply& from);
  GetLatestReply(GetLatestReply&& from) noexcept
    : GetLatestReply() {
    *this = ::std::move(from);
  }

  inline GetLatestReply& operator=(const GetLatestReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestReply& operator=(GetLatestReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestReply* internal_default_instance() {
    return reinterpret_cast<const GetLatestReply*>(
               &_GetLatestReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetLatestReply& a, GetLatestReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLatestReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLatestReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLatestReply& from) {
    GetLatestReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.GetLatestReply";
  }
  protected:
  explicit GetLatestReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
    kOkFieldNumber = 2,
  };
  // bytes v = 1;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // bool ok = 2;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.GetLatestReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class HistorySeekReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.HistorySeekReq) */ {
 public:
  inline HistorySeekReq() : HistorySeekReq(nullptr) {}
  ~HistorySeekReq() override;
  explicit PROTOBUF_CONSTEXPR HistorySeekReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistorySeekReq(const HistorySeekReq& from);
  HistorySeekReq(HistorySeekReq&& from) noexcept
    : HistorySeekReq() {
    *this = ::std::move(from);
  }

  inline HistorySeekReq& operator=(const HistorySeekReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistorySeekReq& operator=(HistorySeekReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistorySeekReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistorySeekReq* internal_default_instance() {
    return reinterpret_cast<const HistorySeekReq*>(
               &_HistorySeekReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HistorySeekReq& a, HistorySeekReq& b) {
    a.Swap(&b);
  }
  inline void Swap(HistorySeekReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistorySeekReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistorySeekReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistorySeekReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistorySeekReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistorySeekReq& from) {
    HistorySeekReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistorySeekReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.HistorySeekReq";
  }
  protected:
  explicit HistorySeekReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 2,
    kKFieldNumber = 3,
    kTxIdFieldNumber = 1,
    kTsFieldNumber = 4,
  };
  // string table = 2;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // bytes k = 3;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // uint64 tx_id = 1;
  void clear_tx_id();
  uint64_t tx_id() const;
  void set_tx_id(uint64_t value);
  private:
  uint64_t _internal_tx_id() const;
  void _internal_set_tx_id(uint64_t value);
  public:

  // uint64 ts = 4;
  void clear_ts();
  uint64_t ts() const;
  void set_ts(uint64_t value);
  private:
  uint64_t _internal_ts() const;
  void _internal_set_ts(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.HistorySeekReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    uint64_t tx_id_;
    uint64_t ts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class HistorySeekReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.HistorySeekReply) */ {
 public:
  inline HistorySeekReply() : HistorySeekReply(nullptr) {}
  ~HistorySeekReply() override;
  explicit PROTOBUF_CONSTEXPR HistorySeekReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistorySeekReply(const HistorySeekReply& from);
  HistorySeekReply(HistorySeekReply&& from) noexcept
    : HistorySeekReply() {
    *this = ::std::move(from);
  }

  inline HistorySeekReply& operator=(const HistorySeekReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistorySeekReply& operator=(HistorySeekReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistorySeekReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistorySeekReply* internal_default_instance() {
    return reinterpret_cast<const HistorySeekReply*>(
               &_HistorySeekReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HistorySeekReply& a, HistorySeekReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HistorySeekReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistorySeekReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistorySeekReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistorySeekReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistorySeekReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistorySeekReply& from) {
    HistorySeekReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistorySeekReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.HistorySeekReply";
  }
  protected:
  explicit HistorySeekReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
    kOkFieldNumber = 2,
  };
  // bytes v = 1;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // bool ok = 2;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.HistorySeekReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class IndexRangeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.IndexRangeReq) */ {
 public:
  inline IndexRangeReq() : IndexRangeReq(nullptr) {}
  ~IndexRangeReq() override;
  explicit PROTOBUF_CONSTEXPR IndexRangeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexRangeReq(const IndexRangeReq& from);
  IndexRangeReq(IndexRangeReq&& from) noexcept
    : IndexRangeReq() {
    *this = ::std::move(from);
  }

  inline IndexRangeReq& operator=(const IndexRangeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexRangeReq& operator=(IndexRangeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexRangeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexRangeReq* internal_default_instance() {
    return reinterpret_cast<const IndexRangeReq*>(
               &_IndexRangeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(IndexRangeReq& a, IndexRangeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexRangeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexRangeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexRangeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexRangeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexRangeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexRangeReq& from) {
    IndexRangeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexRangeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.IndexRangeReq";
  }
  protected:
  explicit IndexRangeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 2,
    kKFieldNumber = 3,
    kPageTokenFieldNumber = 9,
    kTxIdFieldNumber = 1,
    kFromTsFieldNumber = 4,
    kToTsFieldNumber = 5,
    kLimitFieldNumber = 7,
    kOrderAscendFieldNumber = 6,
    kPageSizeFieldNumber = 8,
  };
  // string table = 2;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // bytes k = 3;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // string page_token = 9;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // uint64 tx_id = 1;
  void clear_tx_id();
  uint64_t tx_id() const;
  void set_tx_id(uint64_t value);
  private:
  uint64_t _internal_tx_id() const;
  void _internal_set_tx_id(uint64_t value);
  public:

  // sint64 from_ts = 4;
  void clear_from_ts();
  int64_t from_ts() const;
  void set_from_ts(int64_t value);
  private:
  int64_t _internal_from_ts() const;
  void _internal_set_from_ts(int64_t value);
  public:

  // sint64 to_ts = 5;
  void clear_to_ts();
  int64_t to_ts() const;
  void set_to_ts(int64_t value);
  private:
  int64_t _internal_to_ts() const;
  void _internal_set_to_ts(int64_t value);
  public:

  // sint64 limit = 7;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // bool order_ascend = 6;
  void clear_order_ascend();
  bool order_ascend() const;
  void set_order_ascend(bool value);
  private:
  bool _internal_order_ascend() const;
  void _internal_set_order_ascend(bool value);
  public:

  // int32 page_size = 8;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.IndexRangeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    uint64_t tx_id_;
    int64_t from_ts_;
    int64_t to_ts_;
    int64_t limit_;
    bool order_ascend_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class IndexRangeReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.IndexRangeReply) */ {
 public:
  inline IndexRangeReply() : IndexRangeReply(nullptr) {}
  ~IndexRangeReply() override;
  explicit PROTOBUF_CONSTEXPR IndexRangeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexRangeReply(const IndexRangeReply& from);
  IndexRangeReply(IndexRangeReply&& from) noexcept
    : IndexRangeReply() {
    *this = ::std::move(from);
  }

  inline IndexRangeReply& operator=(const IndexRangeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexRangeReply& operator=(IndexRangeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexRangeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexRangeReply* internal_default_instance() {
    return reinterpret_cast<const IndexRangeReply*>(
               &_IndexRangeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(IndexRangeReply& a, IndexRangeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexRangeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexRangeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexRangeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexRangeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexRangeReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexRangeReply& from) {
    IndexRangeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexRangeReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.IndexRangeReply";
  }
  protected:
  explicit IndexRangeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated uint64 timestamps = 1;
  int timestamps_size() const;
  private:
  int _internal_timestamps_size() const;
  public:
  void clear_timestamps();
  private:
  uint64_t _internal_timestamps(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_timestamps() const;
  void _internal_add_timestamps(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_timestamps();
  public:
  uint64_t timestamps(int index) const;
  void set_timestamps(int index, uint64_t value);
  void add_timestamps(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      timestamps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_timestamps();

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:remote.IndexRangeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > timestamps_;
    mutable std::atomic<int> _timestamps_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class HistoryRangeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.HistoryRangeReq) */ {
 public:
  inline HistoryRangeReq() : HistoryRangeReq(nullptr) {}
  ~HistoryRangeReq() override;
  explicit PROTOBUF_CONSTEXPR HistoryRangeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistoryRangeReq(const HistoryRangeReq& from);
  HistoryRangeReq(HistoryRangeReq&& from) noexcept
    : HistoryRangeReq() {
    *this = ::std::move(from);
  }

  inline HistoryRangeReq& operator=(const HistoryRangeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoryRangeReq& operator=(HistoryRangeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoryRangeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistoryRangeReq* internal_default_instance() {
    return reinterpret_cast<const HistoryRangeReq*>(
               &_HistoryRangeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HistoryRangeReq& a, HistoryRangeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoryRangeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoryRangeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoryRangeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistoryRangeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistoryRangeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistoryRangeReq& from) {
    HistoryRangeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoryRangeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.HistoryRangeReq";
  }
  protected:
  explicit HistoryRangeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 2,
    kPageTokenFieldNumber = 9,
    kTxIdFieldNumber = 1,
    kFromTsFieldNumber = 4,
    kToTsFieldNumber = 5,
    kLimitFieldNumber = 7,
    kOrderAscendFieldNumber = 6,
    kPageSizeFieldNumber = 8,
  };
  // string table = 2;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // string page_token = 9;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // uint64 tx_id = 1;
  void clear_tx_id();
  uint64_t tx_id() const;
  void set_tx_id(uint64_t value);
  private:
  uint64_t _internal_tx_id() const;
  void _internal_set_tx_id(uint64_t value);
  public:

  // sint64 from_ts = 4;
  void clear_from_ts();
  int64_t from_ts() const;
  void set_from_ts(int64_t value);
  private:
  int64_t _internal_from_ts() const;
  void _internal_set_from_ts(int64_t value);
  public:

  // sint64 to_ts = 5;
  void clear_to_ts();
  int64_t to_ts() const;
  void set_to_ts(int64_t value);
  private:
  int64_t _internal_to_ts() const;
  void _internal_set_to_ts(int64_t value);
  public:

  // sint64 limit = 7;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // bool order_ascend = 6;
  void clear_order_ascend();
  bool order_ascend() const;
  void set_order_ascend(bool value);
  private:
  bool _internal_order_ascend() const;
  void _internal_set_order_ascend(bool value);
  public:

  // int32 page_size = 8;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.HistoryRangeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    uint64_t tx_id_;
    int64_t from_ts_;
    int64_t to_ts_;
    int64_t limit_;
    bool order_ascend_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class RangeAsOfReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.RangeAsOfReq) */ {
 public:
  inline RangeAsOfReq() : RangeAsOfReq(nullptr) {}
  ~RangeAsOfReq() override;
  explicit PROTOBUF_CONSTEXPR RangeAsOfReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeAsOfReq(const RangeAsOfReq& from);
  RangeAsOfReq(RangeAsOfReq&& from) noexcept
    : RangeAsOfReq() {
    *this = ::std::move(from);
  }

  inline RangeAsOfReq& operator=(const RangeAsOfReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeAsOfReq& operator=(RangeAsOfReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeAsOfReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeAsOfReq* internal_default_instance() {
    return reinterpret_cast<const RangeAsOfReq*>(
               &_RangeAsOfReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RangeAsOfReq& a, RangeAsOfReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeAsOfReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeAsOfReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeAsOfReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeAsOfReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeAsOfReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeAsOfReq& from) {
    RangeAsOfReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeAsOfReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.RangeAsOfReq";
  }
  protected:
  explicit RangeAsOfReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 2,
    kFromKeyFieldNumber = 3,
    kToKeyFieldNumber = 4,
    kPageTokenFieldNumber = 10,
    kTxIdFieldNumber = 1,
    kTsFieldNumber = 5,
    kLatestFieldNumber = 6,
    kOrderAscendFieldNumber = 7,
    kPageSizeFieldNumber = 9,
    kLimitFieldNumber = 8,
  };
  // string table = 2;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // bytes from_key = 3;
  void clear_from_key();
  const std::string& from_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_key();
  PROTOBUF_NODISCARD std::string* release_from_key();
  void set_allocated_from_key(std::string* from_key);
  private:
  const std::string& _internal_from_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_key(const std::string& value);
  std::string* _internal_mutable_from_key();
  public:

  // bytes to_key = 4;
  void clear_to_key();
  const std::string& to_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_key();
  PROTOBUF_NODISCARD std::string* release_to_key();
  void set_allocated_to_key(std::string* to_key);
  private:
  const std::string& _internal_to_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_key(const std::string& value);
  std::string* _internal_mutable_to_key();
  public:

  // string page_token = 10;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // uint64 tx_id = 1;
  void clear_tx_id();
  uint64_t tx_id() const;
  void set_tx_id(uint64_t value);
  private:
  uint64_t _internal_tx_id() const;
  void _internal_set_tx_id(uint64_t value);
  public:

  // uint64 ts = 5;
  void clear_ts();
  uint64_t ts() const;
  void set_ts(uint64_t value);
  private:
  uint64_t _internal_ts() const;
  void _internal_set_ts(uint64_t value);
  public:

  // bool latest = 6;
  void clear_latest();
  bool latest() const;
  void set_latest(bool value);
  private:
  bool _internal_latest() const;
  void _internal_set_latest(bool value);
  public:

  // bool order_ascend = 7;
  void clear_order_ascend();
  bool order_ascend() const;
  void set_order_ascend(bool value);
  private:
  bool _internal_order_ascend() const;
  void _internal_set_order_ascend(bool value);
  public:

  // int32 page_size = 9;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // sint64 limit = 8;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.RangeAsOfReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    uint64_t tx_id_;
    uint64_t ts_;
    bool latest_;
    bool order_ascend_;
    int32_t page_size_;
    int64_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class Pairs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.Pairs) */ {
 public:
  inline Pairs() : Pairs(nullptr) {}
  ~Pairs() override;
  explicit PROTOBUF_CONSTEXPR Pairs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pairs(const Pairs& from);
  Pairs(Pairs&& from) noexcept
    : Pairs() {
    *this = ::std::move(from);
  }

  inline Pairs& operator=(const Pairs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pairs& operator=(Pairs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pairs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pairs* internal_default_instance() {
    return reinterpret_cast<const Pairs*>(
               &_Pairs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Pairs& a, Pairs& b) {
    a.Swap(&b);
  }
  inline void Swap(Pairs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pairs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pairs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pairs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pairs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pairs& from) {
    Pairs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pairs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.Pairs";
  }
  protected:
  explicit Pairs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
    kValuesFieldNumber = 2,
    kNextPageTokenFieldNumber = 3,
  };
  // repeated bytes keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // repeated bytes values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // string next_page_token = 3;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:remote.Pairs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class PairsPagination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.PairsPagination) */ {
 public:
  inline PairsPagination() : PairsPagination(nullptr) {}
  ~PairsPagination() override;
  explicit PROTOBUF_CONSTEXPR PairsPagination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PairsPagination(const PairsPagination& from);
  PairsPagination(PairsPagination&& from) noexcept
    : PairsPagination() {
    *this = ::std::move(from);
  }

  inline PairsPagination& operator=(const PairsPagination& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairsPagination& operator=(PairsPagination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PairsPagination& default_instance() {
    return *internal_default_instance();
  }
  static inline const PairsPagination* internal_default_instance() {
    return reinterpret_cast<const PairsPagination*>(
               &_PairsPagination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PairsPagination& a, PairsPagination& b) {
    a.Swap(&b);
  }
  inline void Swap(PairsPagination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PairsPagination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PairsPagination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PairsPagination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PairsPagination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PairsPagination& from) {
    PairsPagination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PairsPagination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.PairsPagination";
  }
  protected:
  explicit PairsPagination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextKeyFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // bytes next_key = 1;
  void clear_next_key();
  const std::string& next_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_key();
  PROTOBUF_NODISCARD std::string* release_next_key();
  void set_allocated_next_key(std::string* next_key);
  private:
  const std::string& _internal_next_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_key(const std::string& value);
  std::string* _internal_mutable_next_key();
  public:

  // sint64 limit = 2;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.PairsPagination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_key_;
    int64_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class IndexPagination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.IndexPagination) */ {
 public:
  inline IndexPagination() : IndexPagination(nullptr) {}
  ~IndexPagination() override;
  explicit PROTOBUF_CONSTEXPR IndexPagination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexPagination(const IndexPagination& from);
  IndexPagination(IndexPagination&& from) noexcept
    : IndexPagination() {
    *this = ::std::move(from);
  }

  inline IndexPagination& operator=(const IndexPagination& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexPagination& operator=(IndexPagination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexPagination& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexPagination* internal_default_instance() {
    return reinterpret_cast<const IndexPagination*>(
               &_IndexPagination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(IndexPagination& a, IndexPagination& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexPagination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexPagination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexPagination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexPagination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexPagination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexPagination& from) {
    IndexPagination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexPagination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.IndexPagination";
  }
  protected:
  explicit IndexPagination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextTimeStampFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // sint64 next_time_stamp = 1;
  void clear_next_time_stamp();
  int64_t next_time_stamp() const;
  void set_next_time_stamp(int64_t value);
  private:
  int64_t _internal_next_time_stamp() const;
  void _internal_set_next_time_stamp(int64_t value);
  public:

  // sint64 limit = 2;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.IndexPagination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t next_time_stamp_;
    int64_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Cursor

// .remote.Op op = 1;
inline void Cursor::clear_op() {
  _impl_.op_ = 0;
}
inline ::remote::Op Cursor::_internal_op() const {
  return static_cast< ::remote::Op >(_impl_.op_);
}
inline ::remote::Op Cursor::op() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.op)
  return _internal_op();
}
inline void Cursor::_internal_set_op(::remote::Op value) {
  
  _impl_.op_ = value;
}
inline void Cursor::set_op(::remote::Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:remote.Cursor.op)
}

// string bucket_name = 2;
inline void Cursor::clear_bucket_name() {
  _impl_.bucket_name_.ClearToEmpty();
}
inline const std::string& Cursor::bucket_name() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.bucket_name)
  return _internal_bucket_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cursor::set_bucket_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bucket_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Cursor.bucket_name)
}
inline std::string* Cursor::mutable_bucket_name() {
  std::string* _s = _internal_mutable_bucket_name();
  // @@protoc_insertion_point(field_mutable:remote.Cursor.bucket_name)
  return _s;
}
inline const std::string& Cursor::_internal_bucket_name() const {
  return _impl_.bucket_name_.Get();
}
inline void Cursor::_internal_set_bucket_name(const std::string& value) {
  
  _impl_.bucket_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Cursor::_internal_mutable_bucket_name() {
  
  return _impl_.bucket_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Cursor::release_bucket_name() {
  // @@protoc_insertion_point(field_release:remote.Cursor.bucket_name)
  return _impl_.bucket_name_.Release();
}
inline void Cursor::set_allocated_bucket_name(std::string* bucket_name) {
  if (bucket_name != nullptr) {
    
  } else {
    
  }
  _impl_.bucket_name_.SetAllocated(bucket_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bucket_name_.IsDefault()) {
    _impl_.bucket_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Cursor.bucket_name)
}

// uint32 cursor = 3;
inline void Cursor::clear_cursor() {
  _impl_.cursor_ = 0u;
}
inline uint32_t Cursor::_internal_cursor() const {
  return _impl_.cursor_;
}
inline uint32_t Cursor::cursor() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.cursor)
  return _internal_cursor();
}
inline void Cursor::_internal_set_cursor(uint32_t value) {
  
  _impl_.cursor_ = value;
}
inline void Cursor::set_cursor(uint32_t value) {
  _internal_set_cursor(value);
  // @@protoc_insertion_point(field_set:remote.Cursor.cursor)
}

// bytes k = 4;
inline void Cursor::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& Cursor::k() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cursor::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Cursor.k)
}
inline std::string* Cursor::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.Cursor.k)
  return _s;
}
inline const std::string& Cursor::_internal_k() const {
  return _impl_.k_.Get();
}
inline void Cursor::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* Cursor::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* Cursor::release_k() {
  // @@protoc_insertion_point(field_release:remote.Cursor.k)
  return _impl_.k_.Release();
}
inline void Cursor::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Cursor.k)
}

// bytes v = 5;
inline void Cursor::clear_v() {
  _impl_.v_.ClearToEmpty();
}
inline const std::string& Cursor::v() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cursor::set_v(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Cursor.v)
}
inline std::string* Cursor::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:remote.Cursor.v)
  return _s;
}
inline const std::string& Cursor::_internal_v() const {
  return _impl_.v_.Get();
}
inline void Cursor::_internal_set_v(const std::string& value) {
  
  _impl_.v_.Set(value, GetArenaForAllocation());
}
inline std::string* Cursor::_internal_mutable_v() {
  
  return _impl_.v_.Mutable(GetArenaForAllocation());
}
inline std::string* Cursor::release_v() {
  // @@protoc_insertion_point(field_release:remote.Cursor.v)
  return _impl_.v_.Release();
}
inline void Cursor::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  _impl_.v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v_.IsDefault()) {
    _impl_.v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Cursor.v)
}

// -------------------------------------------------------------------

// Pair

// bytes k = 1;
inline void Pair::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& Pair::k() const {
  // @@protoc_insertion_point(field_get:remote.Pair.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pair::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Pair.k)
}
inline std::string* Pair::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.Pair.k)
  return _s;
}
inline const std::string& Pair::_internal_k() const {
  return _impl_.k_.Get();
}
inline void Pair::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* Pair::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* Pair::release_k() {
  // @@protoc_insertion_point(field_release:remote.Pair.k)
  return _impl_.k_.Release();
}
inline void Pair::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Pair.k)
}

// bytes v = 2;
inline void Pair::clear_v() {
  _impl_.v_.ClearToEmpty();
}
inline const std::string& Pair::v() const {
  // @@protoc_insertion_point(field_get:remote.Pair.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pair::set_v(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Pair.v)
}
inline std::string* Pair::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:remote.Pair.v)
  return _s;
}
inline const std::string& Pair::_internal_v() const {
  return _impl_.v_.Get();
}
inline void Pair::_internal_set_v(const std::string& value) {
  
  _impl_.v_.Set(value, GetArenaForAllocation());
}
inline std::string* Pair::_internal_mutable_v() {
  
  return _impl_.v_.Mutable(GetArenaForAllocation());
}
inline std::string* Pair::release_v() {
  // @@protoc_insertion_point(field_release:remote.Pair.v)
  return _impl_.v_.Release();
}
inline void Pair::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  _impl_.v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v_.IsDefault()) {
    _impl_.v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Pair.v)
}

// uint32 cursor_id = 3;
inline void Pair::clear_cursor_id() {
  _impl_.cursor_id_ = 0u;
}
inline uint32_t Pair::_internal_cursor_id() const {
  return _impl_.cursor_id_;
}
inline uint32_t Pair::cursor_id() const {
  // @@protoc_insertion_point(field_get:remote.Pair.cursor_id)
  return _internal_cursor_id();
}
inline void Pair::_internal_set_cursor_id(uint32_t value) {
  
  _impl_.cursor_id_ = value;
}
inline void Pair::set_cursor_id(uint32_t value) {
  _internal_set_cursor_id(value);
  // @@protoc_insertion_point(field_set:remote.Pair.cursor_id)
}

// uint64 view_id = 4;
inline void Pair::clear_view_id() {
  _impl_.view_id_ = uint64_t{0u};
}
inline uint64_t Pair::_internal_view_id() const {
  return _impl_.view_id_;
}
inline uint64_t Pair::view_id() const {
  // @@protoc_insertion_point(field_get:remote.Pair.view_id)
  return _internal_view_id();
}
inline void Pair::_internal_set_view_id(uint64_t value) {
  
  _impl_.view_id_ = value;
}
inline void Pair::set_view_id(uint64_t value) {
  _internal_set_view_id(value);
  // @@protoc_insertion_point(field_set:remote.Pair.view_id)
}

// uint64 tx_id = 5;
inline void Pair::clear_tx_id() {
  _impl_.tx_id_ = uint64_t{0u};
}
inline uint64_t Pair::_internal_tx_id() const {
  return _impl_.tx_id_;
}
inline uint64_t Pair::tx_id() const {
  // @@protoc_insertion_point(field_get:remote.Pair.tx_id)
  return _internal_tx_id();
}
inline void Pair::_internal_set_tx_id(uint64_t value) {
  
  _impl_.tx_id_ = value;
}
inline void Pair::set_tx_id(uint64_t value) {
  _internal_set_tx_id(value);
  // @@protoc_insertion_point(field_set:remote.Pair.tx_id)
}

// -------------------------------------------------------------------

// StorageChange

// .types.H256 location = 1;
inline bool StorageChange::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool StorageChange::has_location() const {
  return _internal_has_location();
}
inline const ::types::H256& StorageChange::_internal_location() const {
  const ::types::H256* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& StorageChange::location() const {
  // @@protoc_insertion_point(field_get:remote.StorageChange.location)
  return _internal_location();
}
inline void StorageChange::unsafe_arena_set_allocated_location(
    ::types::H256* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.StorageChange.location)
}
inline ::types::H256* StorageChange::release_location() {
  
  ::types::H256* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* StorageChange::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:remote.StorageChange.location)
  
  ::types::H256* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::types::H256* StorageChange::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::types::H256* StorageChange::mutable_location() {
  ::types::H256* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:remote.StorageChange.location)
  return _msg;
}
inline void StorageChange::set_allocated_location(::types::H256* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location));
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:remote.StorageChange.location)
}

// bytes data = 2;
inline void StorageChange::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& StorageChange::data() const {
  // @@protoc_insertion_point(field_get:remote.StorageChange.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageChange::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.StorageChange.data)
}
inline std::string* StorageChange::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:remote.StorageChange.data)
  return _s;
}
inline const std::string& StorageChange::_internal_data() const {
  return _impl_.data_.Get();
}
inline void StorageChange::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageChange::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageChange::release_data() {
  // @@protoc_insertion_point(field_release:remote.StorageChange.data)
  return _impl_.data_.Release();
}
inline void StorageChange::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.StorageChange.data)
}

// -------------------------------------------------------------------

// AccountChange

// .types.H160 address = 1;
inline bool AccountChange::_internal_has_address() const {
  return this != internal_default_instance() && _impl_.address_ != nullptr;
}
inline bool AccountChange::has_address() const {
  return _internal_has_address();
}
inline const ::types::H160& AccountChange::_internal_address() const {
  const ::types::H160* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& AccountChange::address() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.address)
  return _internal_address();
}
inline void AccountChange::unsafe_arena_set_allocated_address(
    ::types::H160* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.AccountChange.address)
}
inline ::types::H160* AccountChange::release_address() {
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* AccountChange::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:remote.AccountChange.address)
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::types::H160* AccountChange::_internal_mutable_address() {
  
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    _impl_.address_ = p;
  }
  return _impl_.address_;
}
inline ::types::H160* AccountChange::mutable_address() {
  ::types::H160* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:remote.AccountChange.address)
  return _msg;
}
inline void AccountChange::set_allocated_address(::types::H160* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address));
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.address_ = address;
  // @@protoc_insertion_point(field_set_allocated:remote.AccountChange.address)
}

// uint64 incarnation = 2;
inline void AccountChange::clear_incarnation() {
  _impl_.incarnation_ = uint64_t{0u};
}
inline uint64_t AccountChange::_internal_incarnation() const {
  return _impl_.incarnation_;
}
inline uint64_t AccountChange::incarnation() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.incarnation)
  return _internal_incarnation();
}
inline void AccountChange::_internal_set_incarnation(uint64_t value) {
  
  _impl_.incarnation_ = value;
}
inline void AccountChange::set_incarnation(uint64_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:remote.AccountChange.incarnation)
}

// .remote.Action action = 3;
inline void AccountChange::clear_action() {
  _impl_.action_ = 0;
}
inline ::remote::Action AccountChange::_internal_action() const {
  return static_cast< ::remote::Action >(_impl_.action_);
}
inline ::remote::Action AccountChange::action() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.action)
  return _internal_action();
}
inline void AccountChange::_internal_set_action(::remote::Action value) {
  
  _impl_.action_ = value;
}
inline void AccountChange::set_action(::remote::Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:remote.AccountChange.action)
}

// bytes data = 4;
inline void AccountChange::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& AccountChange::data() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountChange::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.AccountChange.data)
}
inline std::string* AccountChange::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:remote.AccountChange.data)
  return _s;
}
inline const std::string& AccountChange::_internal_data() const {
  return _impl_.data_.Get();
}
inline void AccountChange::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountChange::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountChange::release_data() {
  // @@protoc_insertion_point(field_release:remote.AccountChange.data)
  return _impl_.data_.Release();
}
inline void AccountChange::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.AccountChange.data)
}

// bytes code = 5;
inline void AccountChange::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& AccountChange::code() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountChange::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.AccountChange.code)
}
inline std::string* AccountChange::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:remote.AccountChange.code)
  return _s;
}
inline const std::string& AccountChange::_internal_code() const {
  return _impl_.code_.Get();
}
inline void AccountChange::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountChange::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountChange::release_code() {
  // @@protoc_insertion_point(field_release:remote.AccountChange.code)
  return _impl_.code_.Release();
}
inline void AccountChange::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.AccountChange.code)
}

// repeated .remote.StorageChange storage_changes = 6;
inline int AccountChange::_internal_storage_changes_size() const {
  return _impl_.storage_changes_.size();
}
inline int AccountChange::storage_changes_size() const {
  return _internal_storage_changes_size();
}
inline void AccountChange::clear_storage_changes() {
  _impl_.storage_changes_.Clear();
}
inline ::remote::StorageChange* AccountChange::mutable_storage_changes(int index) {
  // @@protoc_insertion_point(field_mutable:remote.AccountChange.storage_changes)
  return _impl_.storage_changes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange >*
AccountChange::mutable_storage_changes() {
  // @@protoc_insertion_point(field_mutable_list:remote.AccountChange.storage_changes)
  return &_impl_.storage_changes_;
}
inline const ::remote::StorageChange& AccountChange::_internal_storage_changes(int index) const {
  return _impl_.storage_changes_.Get(index);
}
inline const ::remote::StorageChange& AccountChange::storage_changes(int index) const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.storage_changes)
  return _internal_storage_changes(index);
}
inline ::remote::StorageChange* AccountChange::_internal_add_storage_changes() {
  return _impl_.storage_changes_.Add();
}
inline ::remote::StorageChange* AccountChange::add_storage_changes() {
  ::remote::StorageChange* _add = _internal_add_storage_changes();
  // @@protoc_insertion_point(field_add:remote.AccountChange.storage_changes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange >&
AccountChange::storage_changes() const {
  // @@protoc_insertion_point(field_list:remote.AccountChange.storage_changes)
  return _impl_.storage_changes_;
}

// -------------------------------------------------------------------

// StateChangeBatch

// uint64 state_version_id = 1;
inline void StateChangeBatch::clear_state_version_id() {
  _impl_.state_version_id_ = uint64_t{0u};
}
inline uint64_t StateChangeBatch::_internal_state_version_id() const {
  return _impl_.state_version_id_;
}
inline uint64_t StateChangeBatch::state_version_id() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.state_version_id)
  return _internal_state_version_id();
}
inline void StateChangeBatch::_internal_set_state_version_id(uint64_t value) {
  
  _impl_.state_version_id_ = value;
}
inline void StateChangeBatch::set_state_version_id(uint64_t value) {
  _internal_set_state_version_id(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeBatch.state_version_id)
}

// repeated .remote.StateChange change_batch = 2;
inline int StateChangeBatch::_internal_change_batch_size() const {
  return _impl_.change_batch_.size();
}
inline int StateChangeBatch::change_batch_size() const {
  return _internal_change_batch_size();
}
inline void StateChangeBatch::clear_change_batch() {
  _impl_.change_batch_.Clear();
}
inline ::remote::StateChange* StateChangeBatch::mutable_change_batch(int index) {
  // @@protoc_insertion_point(field_mutable:remote.StateChangeBatch.change_batch)
  return _impl_.change_batch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange >*
StateChangeBatch::mutable_change_batch() {
  // @@protoc_insertion_point(field_mutable_list:remote.StateChangeBatch.change_batch)
  return &_impl_.change_batch_;
}
inline const ::remote::StateChange& StateChangeBatch::_internal_change_batch(int index) const {
  return _impl_.change_batch_.Get(index);
}
inline const ::remote::StateChange& StateChangeBatch::change_batch(int index) const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.change_batch)
  return _internal_change_batch(index);
}
inline ::remote::StateChange* StateChangeBatch::_internal_add_change_batch() {
  return _impl_.change_batch_.Add();
}
inline ::remote::StateChange* StateChangeBatch::add_change_batch() {
  ::remote::StateChange* _add = _internal_add_change_batch();
  // @@protoc_insertion_point(field_add:remote.StateChangeBatch.change_batch)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange >&
StateChangeBatch::change_batch() const {
  // @@protoc_insertion_point(field_list:remote.StateChangeBatch.change_batch)
  return _impl_.change_batch_;
}

// uint64 pending_block_base_fee = 3;
inline void StateChangeBatch::clear_pending_block_base_fee() {
  _impl_.pending_block_base_fee_ = uint64_t{0u};
}
inline uint64_t StateChangeBatch::_internal_pending_block_base_fee() const {
  return _impl_.pending_block_base_fee_;
}
inline uint64_t StateChangeBatch::pending_block_base_fee() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.pending_block_base_fee)
  return _internal_pending_block_base_fee();
}
inline void StateChangeBatch::_internal_set_pending_block_base_fee(uint64_t value) {
  
  _impl_.pending_block_base_fee_ = value;
}
inline void StateChangeBatch::set_pending_block_base_fee(uint64_t value) {
  _internal_set_pending_block_base_fee(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeBatch.pending_block_base_fee)
}

// uint64 block_gas_limit = 4;
inline void StateChangeBatch::clear_block_gas_limit() {
  _impl_.block_gas_limit_ = uint64_t{0u};
}
inline uint64_t StateChangeBatch::_internal_block_gas_limit() const {
  return _impl_.block_gas_limit_;
}
inline uint64_t StateChangeBatch::block_gas_limit() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.block_gas_limit)
  return _internal_block_gas_limit();
}
inline void StateChangeBatch::_internal_set_block_gas_limit(uint64_t value) {
  
  _impl_.block_gas_limit_ = value;
}
inline void StateChangeBatch::set_block_gas_limit(uint64_t value) {
  _internal_set_block_gas_limit(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeBatch.block_gas_limit)
}

// uint64 finalized_block = 5;
inline void StateChangeBatch::clear_finalized_block() {
  _impl_.finalized_block_ = uint64_t{0u};
}
inline uint64_t StateChangeBatch::_internal_finalized_block() const {
  return _impl_.finalized_block_;
}
inline uint64_t StateChangeBatch::finalized_block() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.finalized_block)
  return _internal_finalized_block();
}
inline void StateChangeBatch::_internal_set_finalized_block(uint64_t value) {
  
  _impl_.finalized_block_ = value;
}
inline void StateChangeBatch::set_finalized_block(uint64_t value) {
  _internal_set_finalized_block(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeBatch.finalized_block)
}

// uint64 pending_blob_fee_per_gas = 6;
inline void StateChangeBatch::clear_pending_blob_fee_per_gas() {
  _impl_.pending_blob_fee_per_gas_ = uint64_t{0u};
}
inline uint64_t StateChangeBatch::_internal_pending_blob_fee_per_gas() const {
  return _impl_.pending_blob_fee_per_gas_;
}
inline uint64_t StateChangeBatch::pending_blob_fee_per_gas() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.pending_blob_fee_per_gas)
  return _internal_pending_blob_fee_per_gas();
}
inline void StateChangeBatch::_internal_set_pending_blob_fee_per_gas(uint64_t value) {
  
  _impl_.pending_blob_fee_per_gas_ = value;
}
inline void StateChangeBatch::set_pending_blob_fee_per_gas(uint64_t value) {
  _internal_set_pending_blob_fee_per_gas(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeBatch.pending_blob_fee_per_gas)
}

// -------------------------------------------------------------------

// StateChange

// .remote.Direction direction = 1;
inline void StateChange::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::remote::Direction StateChange::_internal_direction() const {
  return static_cast< ::remote::Direction >(_impl_.direction_);
}
inline ::remote::Direction StateChange::direction() const {
  // @@protoc_insertion_point(field_get:remote.StateChange.direction)
  return _internal_direction();
}
inline void StateChange::_internal_set_direction(::remote::Direction value) {
  
  _impl_.direction_ = value;
}
inline void StateChange::set_direction(::remote::Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:remote.StateChange.direction)
}

// uint64 block_height = 2;
inline void StateChange::clear_block_height() {
  _impl_.block_height_ = uint64_t{0u};
}
inline uint64_t StateChange::_internal_block_height() const {
  return _impl_.block_height_;
}
inline uint64_t StateChange::block_height() const {
  // @@protoc_insertion_point(field_get:remote.StateChange.block_height)
  return _internal_block_height();
}
inline void StateChange::_internal_set_block_height(uint64_t value) {
  
  _impl_.block_height_ = value;
}
inline void StateChange::set_block_height(uint64_t value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:remote.StateChange.block_height)
}

// .types.H256 block_hash = 3;
inline bool StateChange::_internal_has_block_hash() const {
  return this != internal_default_instance() && _impl_.block_hash_ != nullptr;
}
inline bool StateChange::has_block_hash() const {
  return _internal_has_block_hash();
}
inline const ::types::H256& StateChange::_internal_block_hash() const {
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& StateChange::block_hash() const {
  // @@protoc_insertion_point(field_get:remote.StateChange.block_hash)
  return _internal_block_hash();
}
inline void StateChange::unsafe_arena_set_allocated_block_hash(
    ::types::H256* block_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = block_hash;
  if (block_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.StateChange.block_hash)
}
inline ::types::H256* StateChange::release_block_hash() {
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* StateChange::unsafe_arena_release_block_hash() {
  // @@protoc_insertion_point(field_release:remote.StateChange.block_hash)
  
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* StateChange::_internal_mutable_block_hash() {
  
  if (_impl_.block_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.block_hash_ = p;
  }
  return _impl_.block_hash_;
}
inline ::types::H256* StateChange::mutable_block_hash() {
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:remote.StateChange.block_hash)
  return _msg;
}
inline void StateChange::set_allocated_block_hash(::types::H256* block_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_hash_);
  }
  if (block_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_hash));
    if (message_arena != submessage_arena) {
      block_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_hash_ = block_hash;
  // @@protoc_insertion_point(field_set_allocated:remote.StateChange.block_hash)
}

// repeated .remote.AccountChange changes = 4;
inline int StateChange::_internal_changes_size() const {
  return _impl_.changes_.size();
}
inline int StateChange::changes_size() const {
  return _internal_changes_size();
}
inline void StateChange::clear_changes() {
  _impl_.changes_.Clear();
}
inline ::remote::AccountChange* StateChange::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:remote.StateChange.changes)
  return _impl_.changes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange >*
StateChange::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:remote.StateChange.changes)
  return &_impl_.changes_;
}
inline const ::remote::AccountChange& StateChange::_internal_changes(int index) const {
  return _impl_.changes_.Get(index);
}
inline const ::remote::AccountChange& StateChange::changes(int index) const {
  // @@protoc_insertion_point(field_get:remote.StateChange.changes)
  return _internal_changes(index);
}
inline ::remote::AccountChange* StateChange::_internal_add_changes() {
  return _impl_.changes_.Add();
}
inline ::remote::AccountChange* StateChange::add_changes() {
  ::remote::AccountChange* _add = _internal_add_changes();
  // @@protoc_insertion_point(field_add:remote.StateChange.changes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange >&
StateChange::changes() const {
  // @@protoc_insertion_point(field_list:remote.StateChange.changes)
  return _impl_.changes_;
}

// repeated bytes txs = 5;
inline int StateChange::_internal_txs_size() const {
  return _impl_.txs_.size();
}
inline int StateChange::txs_size() const {
  return _internal_txs_size();
}
inline void StateChange::clear_txs() {
  _impl_.txs_.Clear();
}
inline std::string* StateChange::add_txs() {
  std::string* _s = _internal_add_txs();
  // @@protoc_insertion_point(field_add_mutable:remote.StateChange.txs)
  return _s;
}
inline const std::string& StateChange::_internal_txs(int index) const {
  return _impl_.txs_.Get(index);
}
inline const std::string& StateChange::txs(int index) const {
  // @@protoc_insertion_point(field_get:remote.StateChange.txs)
  return _internal_txs(index);
}
inline std::string* StateChange::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:remote.StateChange.txs)
  return _impl_.txs_.Mutable(index);
}
inline void StateChange::set_txs(int index, const std::string& value) {
  _impl_.txs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remote.StateChange.txs)
}
inline void StateChange::set_txs(int index, std::string&& value) {
  _impl_.txs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remote.StateChange.txs)
}
inline void StateChange::set_txs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.txs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remote.StateChange.txs)
}
inline void StateChange::set_txs(int index, const void* value, size_t size) {
  _impl_.txs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remote.StateChange.txs)
}
inline std::string* StateChange::_internal_add_txs() {
  return _impl_.txs_.Add();
}
inline void StateChange::add_txs(const std::string& value) {
  _impl_.txs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:remote.StateChange.txs)
}
inline void StateChange::add_txs(std::string&& value) {
  _impl_.txs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:remote.StateChange.txs)
}
inline void StateChange::add_txs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.txs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remote.StateChange.txs)
}
inline void StateChange::add_txs(const void* value, size_t size) {
  _impl_.txs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remote.StateChange.txs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StateChange::txs() const {
  // @@protoc_insertion_point(field_list:remote.StateChange.txs)
  return _impl_.txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StateChange::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:remote.StateChange.txs)
  return &_impl_.txs_;
}

// -------------------------------------------------------------------

// StateChangeRequest

// bool with_storage = 1;
inline void StateChangeRequest::clear_with_storage() {
  _impl_.with_storage_ = false;
}
inline bool StateChangeRequest::_internal_with_storage() const {
  return _impl_.with_storage_;
}
inline bool StateChangeRequest::with_storage() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeRequest.with_storage)
  return _internal_with_storage();
}
inline void StateChangeRequest::_internal_set_with_storage(bool value) {
  
  _impl_.with_storage_ = value;
}
inline void StateChangeRequest::set_with_storage(bool value) {
  _internal_set_with_storage(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeRequest.with_storage)
}

// bool with_transactions = 2;
inline void StateChangeRequest::clear_with_transactions() {
  _impl_.with_transactions_ = false;
}
inline bool StateChangeRequest::_internal_with_transactions() const {
  return _impl_.with_transactions_;
}
inline bool StateChangeRequest::with_transactions() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeRequest.with_transactions)
  return _internal_with_transactions();
}
inline void StateChangeRequest::_internal_set_with_transactions(bool value) {
  
  _impl_.with_transactions_ = value;
}
inline void StateChangeRequest::set_with_transactions(bool value) {
  _internal_set_with_transactions(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeRequest.with_transactions)
}

// -------------------------------------------------------------------

// SnapshotsRequest

// -------------------------------------------------------------------

// SnapshotsReply

// repeated string blocks_files = 1;
inline int SnapshotsReply::_internal_blocks_files_size() const {
  return _impl_.blocks_files_.size();
}
inline int SnapshotsReply::blocks_files_size() const {
  return _internal_blocks_files_size();
}
inline void SnapshotsReply::clear_blocks_files() {
  _impl_.blocks_files_.Clear();
}
inline std::string* SnapshotsReply::add_blocks_files() {
  std::string* _s = _internal_add_blocks_files();
  // @@protoc_insertion_point(field_add_mutable:remote.SnapshotsReply.blocks_files)
  return _s;
}
inline const std::string& SnapshotsReply::_internal_blocks_files(int index) const {
  return _impl_.blocks_files_.Get(index);
}
inline const std::string& SnapshotsReply::blocks_files(int index) const {
  // @@protoc_insertion_point(field_get:remote.SnapshotsReply.blocks_files)
  return _internal_blocks_files(index);
}
inline std::string* SnapshotsReply::mutable_blocks_files(int index) {
  // @@protoc_insertion_point(field_mutable:remote.SnapshotsReply.blocks_files)
  return _impl_.blocks_files_.Mutable(index);
}
inline void SnapshotsReply::set_blocks_files(int index, const std::string& value) {
  _impl_.blocks_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remote.SnapshotsReply.blocks_files)
}
inline void SnapshotsReply::set_blocks_files(int index, std::string&& value) {
  _impl_.blocks_files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remote.SnapshotsReply.blocks_files)
}
inline void SnapshotsReply::set_blocks_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.blocks_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remote.SnapshotsReply.blocks_files)
}
inline void SnapshotsReply::set_blocks_files(int index, const char* value, size_t size) {
  _impl_.blocks_files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remote.SnapshotsReply.blocks_files)
}
inline std::string* SnapshotsReply::_internal_add_blocks_files() {
  return _impl_.blocks_files_.Add();
}
inline void SnapshotsReply::add_blocks_files(const std::string& value) {
  _impl_.blocks_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:remote.SnapshotsReply.blocks_files)
}
inline void SnapshotsReply::add_blocks_files(std::string&& value) {
  _impl_.blocks_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:remote.SnapshotsReply.blocks_files)
}
inline void SnapshotsReply::add_blocks_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.blocks_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remote.SnapshotsReply.blocks_files)
}
inline void SnapshotsReply::add_blocks_files(const char* value, size_t size) {
  _impl_.blocks_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remote.SnapshotsReply.blocks_files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SnapshotsReply::blocks_files() const {
  // @@protoc_insertion_point(field_list:remote.SnapshotsReply.blocks_files)
  return _impl_.blocks_files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SnapshotsReply::mutable_blocks_files() {
  // @@protoc_insertion_point(field_mutable_list:remote.SnapshotsReply.blocks_files)
  return &_impl_.blocks_files_;
}

// repeated string history_files = 2;
inline int SnapshotsReply::_internal_history_files_size() const {
  return _impl_.history_files_.size();
}
inline int SnapshotsReply::history_files_size() const {
  return _internal_history_files_size();
}
inline void SnapshotsReply::clear_history_files() {
  _impl_.history_files_.Clear();
}
inline std::string* SnapshotsReply::add_history_files() {
  std::string* _s = _internal_add_history_files();
  // @@protoc_insertion_point(field_add_mutable:remote.SnapshotsReply.history_files)
  return _s;
}
inline const std::string& SnapshotsReply::_internal_history_files(int index) const {
  return _impl_.history_files_.Get(index);
}
inline const std::string& SnapshotsReply::history_files(int index) const {
  // @@protoc_insertion_point(field_get:remote.SnapshotsReply.history_files)
  return _internal_history_files(index);
}
inline std::string* SnapshotsReply::mutable_history_files(int index) {
  // @@protoc_insertion_point(field_mutable:remote.SnapshotsReply.history_files)
  return _impl_.history_files_.Mutable(index);
}
inline void SnapshotsReply::set_history_files(int index, const std::string& value) {
  _impl_.history_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remote.SnapshotsReply.history_files)
}
inline void SnapshotsReply::set_history_files(int index, std::string&& value) {
  _impl_.history_files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remote.SnapshotsReply.history_files)
}
inline void SnapshotsReply::set_history_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.history_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remote.SnapshotsReply.history_files)
}
inline void SnapshotsReply::set_history_files(int index, const char* value, size_t size) {
  _impl_.history_files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remote.SnapshotsReply.history_files)
}
inline std::string* SnapshotsReply::_internal_add_history_files() {
  return _impl_.history_files_.Add();
}
inline void SnapshotsReply::add_history_files(const std::string& value) {
  _impl_.history_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:remote.SnapshotsReply.history_files)
}
inline void SnapshotsReply::add_history_files(std::string&& value) {
  _impl_.history_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:remote.SnapshotsReply.history_files)
}
inline void SnapshotsReply::add_history_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.history_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remote.SnapshotsReply.history_files)
}
inline void SnapshotsReply::add_history_files(const char* value, size_t size) {
  _impl_.history_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remote.SnapshotsReply.history_files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SnapshotsReply::history_files() const {
  // @@protoc_insertion_point(field_list:remote.SnapshotsReply.history_files)
  return _impl_.history_files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SnapshotsReply::mutable_history_files() {
  // @@protoc_insertion_point(field_mutable_list:remote.SnapshotsReply.history_files)
  return &_impl_.history_files_;
}

// -------------------------------------------------------------------

// RangeReq

// uint64 tx_id = 1;
inline void RangeReq::clear_tx_id() {
  _impl_.tx_id_ = uint64_t{0u};
}
inline uint64_t RangeReq::_internal_tx_id() const {
  return _impl_.tx_id_;
}
inline uint64_t RangeReq::tx_id() const {
  // @@protoc_insertion_point(field_get:remote.RangeReq.tx_id)
  return _internal_tx_id();
}
inline void RangeReq::_internal_set_tx_id(uint64_t value) {
  
  _impl_.tx_id_ = value;
}
inline void RangeReq::set_tx_id(uint64_t value) {
  _internal_set_tx_id(value);
  // @@protoc_insertion_point(field_set:remote.RangeReq.tx_id)
}

// string table = 2;
inline void RangeReq::clear_table() {
  _impl_.table_.ClearToEmpty();
}
inline const std::string& RangeReq::table() const {
  // @@protoc_insertion_point(field_get:remote.RangeReq.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeReq::set_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.RangeReq.table)
}
inline std::string* RangeReq::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:remote.RangeReq.table)
  return _s;
}
inline const std::string& RangeReq::_internal_table() const {
  return _impl_.table_.Get();
}
inline void RangeReq::_internal_set_table(const std::string& value) {
  
  _impl_.table_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeReq::_internal_mutable_table() {
  
  return _impl_.table_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeReq::release_table() {
  // @@protoc_insertion_point(field_release:remote.RangeReq.table)
  return _impl_.table_.Release();
}
inline void RangeReq::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  _impl_.table_.SetAllocated(table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RangeReq.table)
}

// bytes from_prefix = 3;
inline void RangeReq::clear_from_prefix() {
  _impl_.from_prefix_.ClearToEmpty();
}
inline const std::string& RangeReq::from_prefix() const {
  // @@protoc_insertion_point(field_get:remote.RangeReq.from_prefix)
  return _internal_from_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeReq::set_from_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_prefix_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.RangeReq.from_prefix)
}
inline std::string* RangeReq::mutable_from_prefix() {
  std::string* _s = _internal_mutable_from_prefix();
  // @@protoc_insertion_point(field_mutable:remote.RangeReq.from_prefix)
  return _s;
}
inline const std::string& RangeReq::_internal_from_prefix() const {
  return _impl_.from_prefix_.Get();
}
inline void RangeReq::_internal_set_from_prefix(const std::string& value) {
  
  _impl_.from_prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeReq::_internal_mutable_from_prefix() {
  
  return _impl_.from_prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeReq::release_from_prefix() {
  // @@protoc_insertion_point(field_release:remote.RangeReq.from_prefix)
  return _impl_.from_prefix_.Release();
}
inline void RangeReq::set_allocated_from_prefix(std::string* from_prefix) {
  if (from_prefix != nullptr) {
    
  } else {
    
  }
  _impl_.from_prefix_.SetAllocated(from_prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_prefix_.IsDefault()) {
    _impl_.from_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RangeReq.from_prefix)
}

// bytes to_prefix = 4;
inline void RangeReq::clear_to_prefix() {
  _impl_.to_prefix_.ClearToEmpty();
}
inline const std::string& RangeReq::to_prefix() const {
  // @@protoc_insertion_point(field_get:remote.RangeReq.to_prefix)
  return _internal_to_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeReq::set_to_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_prefix_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.RangeReq.to_prefix)
}
inline std::string* RangeReq::mutable_to_prefix() {
  std::string* _s = _internal_mutable_to_prefix();
  // @@protoc_insertion_point(field_mutable:remote.RangeReq.to_prefix)
  return _s;
}
inline const std::string& RangeReq::_internal_to_prefix() const {
  return _impl_.to_prefix_.Get();
}
inline void RangeReq::_internal_set_to_prefix(const std::string& value) {
  
  _impl_.to_prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeReq::_internal_mutable_to_prefix() {
  
  return _impl_.to_prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeReq::release_to_prefix() {
  // @@protoc_insertion_point(field_release:remote.RangeReq.to_prefix)
  return _impl_.to_prefix_.Release();
}
inline void RangeReq::set_allocated_to_prefix(std::string* to_prefix) {
  if (to_prefix != nullptr) {
    
  } else {
    
  }
  _impl_.to_prefix_.SetAllocated(to_prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_prefix_.IsDefault()) {
    _impl_.to_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RangeReq.to_prefix)
}

// bool order_ascend = 5;
inline void RangeReq::clear_order_ascend() {
  _impl_.order_ascend_ = false;
}
inline bool RangeReq::_internal_order_ascend() const {
  return _impl_.order_ascend_;
}
inline bool RangeReq::order_ascend() const {
  // @@protoc_insertion_point(field_get:remote.RangeReq.order_ascend)
  return _internal_order_ascend();
}
inline void RangeReq::_internal_set_order_ascend(bool value) {
  
  _impl_.order_ascend_ = value;
}
inline void RangeReq::set_order_ascend(bool value) {
  _internal_set_order_ascend(value);
  // @@protoc_insertion_point(field_set:remote.RangeReq.order_ascend)
}

// sint64 limit = 6;
inline void RangeReq::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t RangeReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t RangeReq::limit() const {
  // @@protoc_insertion_point(field_get:remote.RangeReq.limit)
  return _internal_limit();
}
inline void RangeReq::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void RangeReq::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:remote.RangeReq.limit)
}

// int32 page_size = 7;
inline void RangeReq::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t RangeReq::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t RangeReq::page_size() const {
  // @@protoc_insertion_point(field_get:remote.RangeReq.page_size)
  return _internal_page_size();
}
inline void RangeReq::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void RangeReq::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:remote.RangeReq.page_size)
}

// string page_token = 8;
inline void RangeReq::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& RangeReq::page_token() const {
  // @@protoc_insertion_point(field_get:remote.RangeReq.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeReq::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.RangeReq.page_token)
}
inline std::string* RangeReq::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:remote.RangeReq.page_token)
  return _s;
}
inline const std::string& RangeReq::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void RangeReq::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeReq::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeReq::release_page_token() {
  // @@protoc_insertion_point(field_release:remote.RangeReq.page_token)
  return _impl_.page_token_.Release();
}
inline void RangeReq::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RangeReq.page_token)
}

// -------------------------------------------------------------------

// GetLatestReq

// uint64 tx_id = 1;
inline void GetLatestReq::clear_tx_id() {
  _impl_.tx_id_ = uint64_t{0u};
}
inline uint64_t GetLatestReq::_internal_tx_id() const {
  return _impl_.tx_id_;
}
inline uint64_t GetLatestReq::tx_id() const {
  // @@protoc_insertion_point(field_get:remote.GetLatestReq.tx_id)
  return _internal_tx_id();
}
inline void GetLatestReq::_internal_set_tx_id(uint64_t value) {
  
  _impl_.tx_id_ = value;
}
inline void GetLatestReq::set_tx_id(uint64_t value) {
  _internal_set_tx_id(value);
  // @@protoc_insertion_point(field_set:remote.GetLatestReq.tx_id)
}

// string table = 2;
inline void GetLatestReq::clear_table() {
  _impl_.table_.ClearToEmpty();
}
inline const std::string& GetLatestReq::table() const {
  // @@protoc_insertion_point(field_get:remote.GetLatestReq.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLatestReq::set_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.GetLatestReq.table)
}
inline std::string* GetLatestReq::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:remote.GetLatestReq.table)
  return _s;
}
inline const std::string& GetLatestReq::_internal_table() const {
  return _impl_.table_.Get();
}
inline void GetLatestReq::_internal_set_table(const std::string& value) {
  
  _impl_.table_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLatestReq::_internal_mutable_table() {
  
  return _impl_.table_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLatestReq::release_table() {
  // @@protoc_insertion_point(field_release:remote.GetLatestReq.table)
  return _impl_.table_.Release();
}
inline void GetLatestReq::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  _impl_.table_.SetAllocated(table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.GetLatestReq.table)
}

// bytes k = 3;
inline void GetLatestReq::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& GetLatestReq::k() const {
  // @@protoc_insertion_point(field_get:remote.GetLatestReq.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLatestReq::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.GetLatestReq.k)
}
inline std::string* GetLatestReq::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.GetLatestReq.k)
  return _s;
}
inline const std::string& GetLatestReq::_internal_k() const {
  return _impl_.k_.Get();
}
inline void GetLatestReq::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLatestReq::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLatestReq::release_k() {
  // @@protoc_insertion_point(field_release:remote.GetLatestReq.k)
  return _impl_.k_.Release();
}
inline void GetLatestReq::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.GetLatestReq.k)
}

// uint64 ts = 4;
inline void GetLatestReq::clear_ts() {
  _impl_.ts_ = uint64_t{0u};
}
inline uint64_t GetLatestReq::_internal_ts() const {
  return _impl_.ts_;
}
inline uint64_t GetLatestReq::ts() const {
  // @@protoc_insertion_point(field_get:remote.GetLatestReq.ts)
  return _internal_ts();
}
inline void GetLatestReq::_internal_set_ts(uint64_t value) {
  
  _impl_.ts_ = value;
}
inline void GetLatestReq::set_ts(uint64_t value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:remote.GetLatestReq.ts)
}

// bytes k2 = 5;
inline void GetLatestReq::clear_k2() {
  _impl_.k2_.ClearToEmpty();
}
inline const std::string& GetLatestReq::k2() const {
  // @@protoc_insertion_point(field_get:remote.GetLatestReq.k2)
  return _internal_k2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLatestReq::set_k2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.GetLatestReq.k2)
}
inline std::string* GetLatestReq::mutable_k2() {
  std::string* _s = _internal_mutable_k2();
  // @@protoc_insertion_point(field_mutable:remote.GetLatestReq.k2)
  return _s;
}
inline const std::string& GetLatestReq::_internal_k2() const {
  return _impl_.k2_.Get();
}
inline void GetLatestReq::_internal_set_k2(const std::string& value) {
  
  _impl_.k2_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLatestReq::_internal_mutable_k2() {
  
  return _impl_.k2_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLatestReq::release_k2() {
  // @@protoc_insertion_point(field_release:remote.GetLatestReq.k2)
  return _impl_.k2_.Release();
}
inline void GetLatestReq::set_allocated_k2(std::string* k2) {
  if (k2 != nullptr) {
    
  } else {
    
  }
  _impl_.k2_.SetAllocated(k2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k2_.IsDefault()) {
    _impl_.k2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.GetLatestReq.k2)
}

// bool latest = 6;
inline void GetLatestReq::clear_latest() {
  _impl_.latest_ = false;
}
inline bool GetLatestReq::_internal_latest() const {
  return _impl_.latest_;
}
inline bool GetLatestReq::latest() const {
  // @@protoc_insertion_point(field_get:remote.GetLatestReq.latest)
  return _internal_latest();
}
inline void GetLatestReq::_internal_set_latest(bool value) {
  
  _impl_.latest_ = value;
}
inline void GetLatestReq::set_latest(bool value) {
  _internal_set_latest(value);
  // @@protoc_insertion_point(field_set:remote.GetLatestReq.latest)
}

// -------------------------------------------------------------------

// GetLatestReply

// bytes v = 1;
inline void GetLatestReply::clear_v() {
  _impl_.v_.ClearToEmpty();
}
inline const std::string& GetLatestReply::v() const {
  // @@protoc_insertion_point(field_get:remote.GetLatestReply.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLatestReply::set_v(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.GetLatestReply.v)
}
inline std::string* GetLatestReply::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:remote.GetLatestReply.v)
  return _s;
}
inline const std::string& GetLatestReply::_internal_v() const {
  return _impl_.v_.Get();
}
inline void GetLatestReply::_internal_set_v(const std::string& value) {
  
  _impl_.v_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLatestReply::_internal_mutable_v() {
  
  return _impl_.v_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLatestReply::release_v() {
  // @@protoc_insertion_point(field_release:remote.GetLatestReply.v)
  return _impl_.v_.Release();
}
inline void GetLatestReply::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  _impl_.v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v_.IsDefault()) {
    _impl_.v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.GetLatestReply.v)
}

// bool ok = 2;
inline void GetLatestReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool GetLatestReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool GetLatestReply::ok() const {
  // @@protoc_insertion_point(field_get:remote.GetLatestReply.ok)
  return _internal_ok();
}
inline void GetLatestReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void GetLatestReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:remote.GetLatestReply.ok)
}

// -------------------------------------------------------------------

// HistorySeekReq

// uint64 tx_id = 1;
inline void HistorySeekReq::clear_tx_id() {
  _impl_.tx_id_ = uint64_t{0u};
}
inline uint64_t HistorySeekReq::_internal_tx_id() const {
  return _impl_.tx_id_;
}
inline uint64_t HistorySeekReq::tx_id() const {
  // @@protoc_insertion_point(field_get:remote.HistorySeekReq.tx_id)
  return _internal_tx_id();
}
inline void HistorySeekReq::_internal_set_tx_id(uint64_t value) {
  
  _impl_.tx_id_ = value;
}
inline void HistorySeekReq::set_tx_id(uint64_t value) {
  _internal_set_tx_id(value);
  // @@protoc_insertion_point(field_set:remote.HistorySeekReq.tx_id)
}

// string table = 2;
inline void HistorySeekReq::clear_table() {
  _impl_.table_.ClearToEmpty();
}
inline const std::string& HistorySeekReq::table() const {
  // @@protoc_insertion_point(field_get:remote.HistorySeekReq.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistorySeekReq::set_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.HistorySeekReq.table)
}
inline std::string* HistorySeekReq::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:remote.HistorySeekReq.table)
  return _s;
}
inline const std::string& HistorySeekReq::_internal_table() const {
  return _impl_.table_.Get();
}
inline void HistorySeekReq::_internal_set_table(const std::string& value) {
  
  _impl_.table_.Set(value, GetArenaForAllocation());
}
inline std::string* HistorySeekReq::_internal_mutable_table() {
  
  return _impl_.table_.Mutable(GetArenaForAllocation());
}
inline std::string* HistorySeekReq::release_table() {
  // @@protoc_insertion_point(field_release:remote.HistorySeekReq.table)
  return _impl_.table_.Release();
}
inline void HistorySeekReq::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  _impl_.table_.SetAllocated(table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.HistorySeekReq.table)
}

// bytes k = 3;
inline void HistorySeekReq::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& HistorySeekReq::k() const {
  // @@protoc_insertion_point(field_get:remote.HistorySeekReq.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistorySeekReq::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.HistorySeekReq.k)
}
inline std::string* HistorySeekReq::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.HistorySeekReq.k)
  return _s;
}
inline const std::string& HistorySeekReq::_internal_k() const {
  return _impl_.k_.Get();
}
inline void HistorySeekReq::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* HistorySeekReq::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* HistorySeekReq::release_k() {
  // @@protoc_insertion_point(field_release:remote.HistorySeekReq.k)
  return _impl_.k_.Release();
}
inline void HistorySeekReq::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.HistorySeekReq.k)
}

// uint64 ts = 4;
inline void HistorySeekReq::clear_ts() {
  _impl_.ts_ = uint64_t{0u};
}
inline uint64_t HistorySeekReq::_internal_ts() const {
  return _impl_.ts_;
}
inline uint64_t HistorySeekReq::ts() const {
  // @@protoc_insertion_point(field_get:remote.HistorySeekReq.ts)
  return _internal_ts();
}
inline void HistorySeekReq::_internal_set_ts(uint64_t value) {
  
  _impl_.ts_ = value;
}
inline void HistorySeekReq::set_ts(uint64_t value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:remote.HistorySeekReq.ts)
}

// -------------------------------------------------------------------

// HistorySeekReply

// bytes v = 1;
inline void HistorySeekReply::clear_v() {
  _impl_.v_.ClearToEmpty();
}
inline const std::string& HistorySeekReply::v() const {
  // @@protoc_insertion_point(field_get:remote.HistorySeekReply.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistorySeekReply::set_v(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.HistorySeekReply.v)
}
inline std::string* HistorySeekReply::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:remote.HistorySeekReply.v)
  return _s;
}
inline const std::string& HistorySeekReply::_internal_v() const {
  return _impl_.v_.Get();
}
inline void HistorySeekReply::_internal_set_v(const std::string& value) {
  
  _impl_.v_.Set(value, GetArenaForAllocation());
}
inline std::string* HistorySeekReply::_internal_mutable_v() {
  
  return _impl_.v_.Mutable(GetArenaForAllocation());
}
inline std::string* HistorySeekReply::release_v() {
  // @@protoc_insertion_point(field_release:remote.HistorySeekReply.v)
  return _impl_.v_.Release();
}
inline void HistorySeekReply::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  _impl_.v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v_.IsDefault()) {
    _impl_.v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.HistorySeekReply.v)
}

// bool ok = 2;
inline void HistorySeekReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool HistorySeekReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool HistorySeekReply::ok() const {
  // @@protoc_insertion_point(field_get:remote.HistorySeekReply.ok)
  return _internal_ok();
}
inline void HistorySeekReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void HistorySeekReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:remote.HistorySeekReply.ok)
}

// -------------------------------------------------------------------

// IndexRangeReq

// uint64 tx_id = 1;
inline void IndexRangeReq::clear_tx_id() {
  _impl_.tx_id_ = uint64_t{0u};
}
inline uint64_t IndexRangeReq::_internal_tx_id() const {
  return _impl_.tx_id_;
}
inline uint64_t IndexRangeReq::tx_id() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.tx_id)
  return _internal_tx_id();
}
inline void IndexRangeReq::_internal_set_tx_id(uint64_t value) {
  
  _impl_.tx_id_ = value;
}
inline void IndexRangeReq::set_tx_id(uint64_t value) {
  _internal_set_tx_id(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.tx_id)
}

// string table = 2;
inline void IndexRangeReq::clear_table() {
  _impl_.table_.ClearToEmpty();
}
inline const std::string& IndexRangeReq::table() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexRangeReq::set_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.table)
}
inline std::string* IndexRangeReq::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:remote.IndexRangeReq.table)
  return _s;
}
inline const std::string& IndexRangeReq::_internal_table() const {
  return _impl_.table_.Get();
}
inline void IndexRangeReq::_internal_set_table(const std::string& value) {
  
  _impl_.table_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexRangeReq::_internal_mutable_table() {
  
  return _impl_.table_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexRangeReq::release_table() {
  // @@protoc_insertion_point(field_release:remote.IndexRangeReq.table)
  return _impl_.table_.Release();
}
inline void IndexRangeReq::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  _impl_.table_.SetAllocated(table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.IndexRangeReq.table)
}

// bytes k = 3;
inline void IndexRangeReq::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& IndexRangeReq::k() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexRangeReq::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.k)
}
inline std::string* IndexRangeReq::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.IndexRangeReq.k)
  return _s;
}
inline const std::string& IndexRangeReq::_internal_k() const {
  return _impl_.k_.Get();
}
inline void IndexRangeReq::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexRangeReq::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexRangeReq::release_k() {
  // @@protoc_insertion_point(field_release:remote.IndexRangeReq.k)
  return _impl_.k_.Release();
}
inline void IndexRangeReq::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.IndexRangeReq.k)
}

// sint64 from_ts = 4;
inline void IndexRangeReq::clear_from_ts() {
  _impl_.from_ts_ = int64_t{0};
}
inline int64_t IndexRangeReq::_internal_from_ts() const {
  return _impl_.from_ts_;
}
inline int64_t IndexRangeReq::from_ts() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.from_ts)
  return _internal_from_ts();
}
inline void IndexRangeReq::_internal_set_from_ts(int64_t value) {
  
  _impl_.from_ts_ = value;
}
inline void IndexRangeReq::set_from_ts(int64_t value) {
  _internal_set_from_ts(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.from_ts)
}

// sint64 to_ts = 5;
inline void IndexRangeReq::clear_to_ts() {
  _impl_.to_ts_ = int64_t{0};
}
inline int64_t IndexRangeReq::_internal_to_ts() const {
  return _impl_.to_ts_;
}
inline int64_t IndexRangeReq::to_ts() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.to_ts)
  return _internal_to_ts();
}
inline void IndexRangeReq::_internal_set_to_ts(int64_t value) {
  
  _impl_.to_ts_ = value;
}
inline void IndexRangeReq::set_to_ts(int64_t value) {
  _internal_set_to_ts(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.to_ts)
}

// bool order_ascend = 6;
inline void IndexRangeReq::clear_order_ascend() {
  _impl_.order_ascend_ = false;
}
inline bool IndexRangeReq::_internal_order_ascend() const {
  return _impl_.order_ascend_;
}
inline bool IndexRangeReq::order_ascend() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.order_ascend)
  return _internal_order_ascend();
}
inline void IndexRangeReq::_internal_set_order_ascend(bool value) {
  
  _impl_.order_ascend_ = value;
}
inline void IndexRangeReq::set_order_ascend(bool value) {
  _internal_set_order_ascend(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.order_ascend)
}

// sint64 limit = 7;
inline void IndexRangeReq::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t IndexRangeReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t IndexRangeReq::limit() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.limit)
  return _internal_limit();
}
inline void IndexRangeReq::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void IndexRangeReq::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.limit)
}

// int32 page_size = 8;
inline void IndexRangeReq::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t IndexRangeReq::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t IndexRangeReq::page_size() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.page_size)
  return _internal_page_size();
}
inline void IndexRangeReq::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void IndexRangeReq::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.page_size)
}

// string page_token = 9;
inline void IndexRangeReq::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& IndexRangeReq::page_token() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexRangeReq::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.page_token)
}
inline std::string* IndexRangeReq::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:remote.IndexRangeReq.page_token)
  return _s;
}
inline const std::string& IndexRangeReq::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void IndexRangeReq::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexRangeReq::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexRangeReq::release_page_token() {
  // @@protoc_insertion_point(field_release:remote.IndexRangeReq.page_token)
  return _impl_.page_token_.Release();
}
inline void IndexRangeReq::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.IndexRangeReq.page_token)
}

// -------------------------------------------------------------------

// IndexRangeReply

// repeated uint64 timestamps = 1;
inline int IndexRangeReply::_internal_timestamps_size() const {
  return _impl_.timestamps_.size();
}
inline int IndexRangeReply::timestamps_size() const {
  return _internal_timestamps_size();
}
inline void IndexRangeReply::clear_timestamps() {
  _impl_.timestamps_.Clear();
}
inline uint64_t IndexRangeReply::_internal_timestamps(int index) const {
  return _impl_.timestamps_.Get(index);
}
inline uint64_t IndexRangeReply::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReply.timestamps)
  return _internal_timestamps(index);
}
inline void IndexRangeReply::set_timestamps(int index, uint64_t value) {
  _impl_.timestamps_.Set(index, value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReply.timestamps)
}
inline void IndexRangeReply::_internal_add_timestamps(uint64_t value) {
  _impl_.timestamps_.Add(value);
}
inline void IndexRangeReply::add_timestamps(uint64_t value) {
  _internal_add_timestamps(value);
  // @@protoc_insertion_point(field_add:remote.IndexRangeReply.timestamps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
IndexRangeReply::_internal_timestamps() const {
  return _impl_.timestamps_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
IndexRangeReply::timestamps() const {
  // @@protoc_insertion_point(field_list:remote.IndexRangeReply.timestamps)
  return _internal_timestamps();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
IndexRangeReply::_internal_mutable_timestamps() {
  return &_impl_.timestamps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
IndexRangeReply::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:remote.IndexRangeReply.timestamps)
  return _internal_mutable_timestamps();
}

// string next_page_token = 2;
inline void IndexRangeReply::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& IndexRangeReply::next_page_token() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReply.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexRangeReply::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.IndexRangeReply.next_page_token)
}
inline std::string* IndexRangeReply::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:remote.IndexRangeReply.next_page_token)
  return _s;
}
inline const std::string& IndexRangeReply::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void IndexRangeReply::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexRangeReply::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexRangeReply::release_next_page_token() {
  // @@protoc_insertion_point(field_release:remote.IndexRangeReply.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void IndexRangeReply::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.IndexRangeReply.next_page_token)
}

// -------------------------------------------------------------------

// HistoryRangeReq

// uint64 tx_id = 1;
inline void HistoryRangeReq::clear_tx_id() {
  _impl_.tx_id_ = uint64_t{0u};
}
inline uint64_t HistoryRangeReq::_internal_tx_id() const {
  return _impl_.tx_id_;
}
inline uint64_t HistoryRangeReq::tx_id() const {
  // @@protoc_insertion_point(field_get:remote.HistoryRangeReq.tx_id)
  return _internal_tx_id();
}
inline void HistoryRangeReq::_internal_set_tx_id(uint64_t value) {
  
  _impl_.tx_id_ = value;
}
inline void HistoryRangeReq::set_tx_id(uint64_t value) {
  _internal_set_tx_id(value);
  // @@protoc_insertion_point(field_set:remote.HistoryRangeReq.tx_id)
}

// string table = 2;
inline void HistoryRangeReq::clear_table() {
  _impl_.table_.ClearToEmpty();
}
inline const std::string& HistoryRangeReq::table() const {
  // @@protoc_insertion_point(field_get:remote.HistoryRangeReq.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistoryRangeReq::set_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.HistoryRangeReq.table)
}
inline std::string* HistoryRangeReq::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:remote.HistoryRangeReq.table)
  return _s;
}
inline const std::string& HistoryRangeReq::_internal_table() const {
  return _impl_.table_.Get();
}
inline void HistoryRangeReq::_internal_set_table(const std::string& value) {
  
  _impl_.table_.Set(value, GetArenaForAllocation());
}
inline std::string* HistoryRangeReq::_internal_mutable_table() {
  
  return _impl_.table_.Mutable(GetArenaForAllocation());
}
inline std::string* HistoryRangeReq::release_table() {
  // @@protoc_insertion_point(field_release:remote.HistoryRangeReq.table)
  return _impl_.table_.Release();
}
inline void HistoryRangeReq::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  _impl_.table_.SetAllocated(table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.HistoryRangeReq.table)
}

// sint64 from_ts = 4;
inline void HistoryRangeReq::clear_from_ts() {
  _impl_.from_ts_ = int64_t{0};
}
inline int64_t HistoryRangeReq::_internal_from_ts() const {
  return _impl_.from_ts_;
}
inline int64_t HistoryRangeReq::from_ts() const {
  // @@protoc_insertion_point(field_get:remote.HistoryRangeReq.from_ts)
  return _internal_from_ts();
}
inline void HistoryRangeReq::_internal_set_from_ts(int64_t value) {
  
  _impl_.from_ts_ = value;
}
inline void HistoryRangeReq::set_from_ts(int64_t value) {
  _internal_set_from_ts(value);
  // @@protoc_insertion_point(field_set:remote.HistoryRangeReq.from_ts)
}

// sint64 to_ts = 5;
inline void HistoryRangeReq::clear_to_ts() {
  _impl_.to_ts_ = int64_t{0};
}
inline int64_t HistoryRangeReq::_internal_to_ts() const {
  return _impl_.to_ts_;
}
inline int64_t HistoryRangeReq::to_ts() const {
  // @@protoc_insertion_point(field_get:remote.HistoryRangeReq.to_ts)
  return _internal_to_ts();
}
inline void HistoryRangeReq::_internal_set_to_ts(int64_t value) {
  
  _impl_.to_ts_ = value;
}
inline void HistoryRangeReq::set_to_ts(int64_t value) {
  _internal_set_to_ts(value);
  // @@protoc_insertion_point(field_set:remote.HistoryRangeReq.to_ts)
}

// bool order_ascend = 6;
inline void HistoryRangeReq::clear_order_ascend() {
  _impl_.order_ascend_ = false;
}
inline bool HistoryRangeReq::_internal_order_ascend() const {
  return _impl_.order_ascend_;
}
inline bool HistoryRangeReq::order_ascend() const {
  // @@protoc_insertion_point(field_get:remote.HistoryRangeReq.order_ascend)
  return _internal_order_ascend();
}
inline void HistoryRangeReq::_internal_set_order_ascend(bool value) {
  
  _impl_.order_ascend_ = value;
}
inline void HistoryRangeReq::set_order_ascend(bool value) {
  _internal_set_order_ascend(value);
  // @@protoc_insertion_point(field_set:remote.HistoryRangeReq.order_ascend)
}

// sint64 limit = 7;
inline void HistoryRangeReq::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t HistoryRangeReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t HistoryRangeReq::limit() const {
  // @@protoc_insertion_point(field_get:remote.HistoryRangeReq.limit)
  return _internal_limit();
}
inline void HistoryRangeReq::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void HistoryRangeReq::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:remote.HistoryRangeReq.limit)
}

// int32 page_size = 8;
inline void HistoryRangeReq::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t HistoryRangeReq::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t HistoryRangeReq::page_size() const {
  // @@protoc_insertion_point(field_get:remote.HistoryRangeReq.page_size)
  return _internal_page_size();
}
inline void HistoryRangeReq::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void HistoryRangeReq::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:remote.HistoryRangeReq.page_size)
}

// string page_token = 9;
inline void HistoryRangeReq::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& HistoryRangeReq::page_token() const {
  // @@protoc_insertion_point(field_get:remote.HistoryRangeReq.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistoryRangeReq::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.HistoryRangeReq.page_token)
}
inline std::string* HistoryRangeReq::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:remote.HistoryRangeReq.page_token)
  return _s;
}
inline const std::string& HistoryRangeReq::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void HistoryRangeReq::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* HistoryRangeReq::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* HistoryRangeReq::release_page_token() {
  // @@protoc_insertion_point(field_release:remote.HistoryRangeReq.page_token)
  return _impl_.page_token_.Release();
}
inline void HistoryRangeReq::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.HistoryRangeReq.page_token)
}

// -------------------------------------------------------------------

// RangeAsOfReq

// uint64 tx_id = 1;
inline void RangeAsOfReq::clear_tx_id() {
  _impl_.tx_id_ = uint64_t{0u};
}
inline uint64_t RangeAsOfReq::_internal_tx_id() const {
  return _impl_.tx_id_;
}
inline uint64_t RangeAsOfReq::tx_id() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.tx_id)
  return _internal_tx_id();
}
inline void RangeAsOfReq::_internal_set_tx_id(uint64_t value) {
  
  _impl_.tx_id_ = value;
}
inline void RangeAsOfReq::set_tx_id(uint64_t value) {
  _internal_set_tx_id(value);
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.tx_id)
}

// string table = 2;
inline void RangeAsOfReq::clear_table() {
  _impl_.table_.ClearToEmpty();
}
inline const std::string& RangeAsOfReq::table() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeAsOfReq::set_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.table)
}
inline std::string* RangeAsOfReq::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:remote.RangeAsOfReq.table)
  return _s;
}
inline const std::string& RangeAsOfReq::_internal_table() const {
  return _impl_.table_.Get();
}
inline void RangeAsOfReq::_internal_set_table(const std::string& value) {
  
  _impl_.table_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeAsOfReq::_internal_mutable_table() {
  
  return _impl_.table_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeAsOfReq::release_table() {
  // @@protoc_insertion_point(field_release:remote.RangeAsOfReq.table)
  return _impl_.table_.Release();
}
inline void RangeAsOfReq::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  _impl_.table_.SetAllocated(table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RangeAsOfReq.table)
}

// bytes from_key = 3;
inline void RangeAsOfReq::clear_from_key() {
  _impl_.from_key_.ClearToEmpty();
}
inline const std::string& RangeAsOfReq::from_key() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.from_key)
  return _internal_from_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeAsOfReq::set_from_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.from_key)
}
inline std::string* RangeAsOfReq::mutable_from_key() {
  std::string* _s = _internal_mutable_from_key();
  // @@protoc_insertion_point(field_mutable:remote.RangeAsOfReq.from_key)
  return _s;
}
inline const std::string& RangeAsOfReq::_internal_from_key() const {
  return _impl_.from_key_.Get();
}
inline void RangeAsOfReq::_internal_set_from_key(const std::string& value) {
  
  _impl_.from_key_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeAsOfReq::_internal_mutable_from_key() {
  
  return _impl_.from_key_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeAsOfReq::release_from_key() {
  // @@protoc_insertion_point(field_release:remote.RangeAsOfReq.from_key)
  return _impl_.from_key_.Release();
}
inline void RangeAsOfReq::set_allocated_from_key(std::string* from_key) {
  if (from_key != nullptr) {
    
  } else {
    
  }
  _impl_.from_key_.SetAllocated(from_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_key_.IsDefault()) {
    _impl_.from_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RangeAsOfReq.from_key)
}

// bytes to_key = 4;
inline void RangeAsOfReq::clear_to_key() {
  _impl_.to_key_.ClearToEmpty();
}
inline const std::string& RangeAsOfReq::to_key() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.to_key)
  return _internal_to_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeAsOfReq::set_to_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.to_key)
}
inline std::string* RangeAsOfReq::mutable_to_key() {
  std::string* _s = _internal_mutable_to_key();
  // @@protoc_insertion_point(field_mutable:remote.RangeAsOfReq.to_key)
  return _s;
}
inline const std::string& RangeAsOfReq::_internal_to_key() const {
  return _impl_.to_key_.Get();
}
inline void RangeAsOfReq::_internal_set_to_key(const std::string& value) {
  
  _impl_.to_key_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeAsOfReq::_internal_mutable_to_key() {
  
  return _impl_.to_key_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeAsOfReq::release_to_key() {
  // @@protoc_insertion_point(field_release:remote.RangeAsOfReq.to_key)
  return _impl_.to_key_.Release();
}
inline void RangeAsOfReq::set_allocated_to_key(std::string* to_key) {
  if (to_key != nullptr) {
    
  } else {
    
  }
  _impl_.to_key_.SetAllocated(to_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_key_.IsDefault()) {
    _impl_.to_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RangeAsOfReq.to_key)
}

// uint64 ts = 5;
inline void RangeAsOfReq::clear_ts() {
  _impl_.ts_ = uint64_t{0u};
}
inline uint64_t RangeAsOfReq::_internal_ts() const {
  return _impl_.ts_;
}
inline uint64_t RangeAsOfReq::ts() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.ts)
  return _internal_ts();
}
inline void RangeAsOfReq::_internal_set_ts(uint64_t value) {
  
  _impl_.ts_ = value;
}
inline void RangeAsOfReq::set_ts(uint64_t value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.ts)
}

// bool latest = 6;
inline void RangeAsOfReq::clear_latest() {
  _impl_.latest_ = false;
}
inline bool RangeAsOfReq::_internal_latest() const {
  return _impl_.latest_;
}
inline bool RangeAsOfReq::latest() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.latest)
  return _internal_latest();
}
inline void RangeAsOfReq::_internal_set_latest(bool value) {
  
  _impl_.latest_ = value;
}
inline void RangeAsOfReq::set_latest(bool value) {
  _internal_set_latest(value);
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.latest)
}

// bool order_ascend = 7;
inline void RangeAsOfReq::clear_order_ascend() {
  _impl_.order_ascend_ = false;
}
inline bool RangeAsOfReq::_internal_order_ascend() const {
  return _impl_.order_ascend_;
}
inline bool RangeAsOfReq::order_ascend() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.order_ascend)
  return _internal_order_ascend();
}
inline void RangeAsOfReq::_internal_set_order_ascend(bool value) {
  
  _impl_.order_ascend_ = value;
}
inline void RangeAsOfReq::set_order_ascend(bool value) {
  _internal_set_order_ascend(value);
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.order_ascend)
}

// sint64 limit = 8;
inline void RangeAsOfReq::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t RangeAsOfReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t RangeAsOfReq::limit() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.limit)
  return _internal_limit();
}
inline void RangeAsOfReq::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void RangeAsOfReq::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.limit)
}

// int32 page_size = 9;
inline void RangeAsOfReq::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t RangeAsOfReq::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t RangeAsOfReq::page_size() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.page_size)
  return _internal_page_size();
}
inline void RangeAsOfReq::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void RangeAsOfReq::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.page_size)
}

// string page_token = 10;
inline void RangeAsOfReq::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& RangeAsOfReq::page_token() const {
  // @@protoc_insertion_point(field_get:remote.RangeAsOfReq.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeAsOfReq::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.RangeAsOfReq.page_token)
}
inline std::string* RangeAsOfReq::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:remote.RangeAsOfReq.page_token)
  return _s;
}
inline const std::string& RangeAsOfReq::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void RangeAsOfReq::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeAsOfReq::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeAsOfReq::release_page_token() {
  // @@protoc_insertion_point(field_release:remote.RangeAsOfReq.page_token)
  return _impl_.page_token_.Release();
}
inline void RangeAsOfReq::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RangeAsOfReq.page_token)
}

// -------------------------------------------------------------------

// Pairs

// repeated bytes keys = 1;
inline int Pairs::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int Pairs::keys_size() const {
  return _internal_keys_size();
}
inline void Pairs::clear_keys() {
  _impl_.keys_.Clear();
}
inline std::string* Pairs::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:remote.Pairs.keys)
  return _s;
}
inline const std::string& Pairs::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const std::string& Pairs::keys(int index) const {
  // @@protoc_insertion_point(field_get:remote.Pairs.keys)
  return _internal_keys(index);
}
inline std::string* Pairs::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:remote.Pairs.keys)
  return _impl_.keys_.Mutable(index);
}
inline void Pairs::set_keys(int index, const std::string& value) {
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remote.Pairs.keys)
}
inline void Pairs::set_keys(int index, std::string&& value) {
  _impl_.keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remote.Pairs.keys)
}
inline void Pairs::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remote.Pairs.keys)
}
inline void Pairs::set_keys(int index, const void* value, size_t size) {
  _impl_.keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remote.Pairs.keys)
}
inline std::string* Pairs::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline void Pairs::add_keys(const std::string& value) {
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:remote.Pairs.keys)
}
inline void Pairs::add_keys(std::string&& value) {
  _impl_.keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:remote.Pairs.keys)
}
inline void Pairs::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remote.Pairs.keys)
}
inline void Pairs::add_keys(const void* value, size_t size) {
  _impl_.keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remote.Pairs.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Pairs::keys() const {
  // @@protoc_insertion_point(field_list:remote.Pairs.keys)
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Pairs::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:remote.Pairs.keys)
  return &_impl_.keys_;
}

// repeated bytes values = 2;
inline int Pairs::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Pairs::values_size() const {
  return _internal_values_size();
}
inline void Pairs::clear_values() {
  _impl_.values_.Clear();
}
inline std::string* Pairs::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:remote.Pairs.values)
  return _s;
}
inline const std::string& Pairs::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const std::string& Pairs::values(int index) const {
  // @@protoc_insertion_point(field_get:remote.Pairs.values)
  return _internal_values(index);
}
inline std::string* Pairs::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:remote.Pairs.values)
  return _impl_.values_.Mutable(index);
}
inline void Pairs::set_values(int index, const std::string& value) {
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remote.Pairs.values)
}
inline void Pairs::set_values(int index, std::string&& value) {
  _impl_.values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remote.Pairs.values)
}
inline void Pairs::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remote.Pairs.values)
}
inline void Pairs::set_values(int index, const void* value, size_t size) {
  _impl_.values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remote.Pairs.values)
}
inline std::string* Pairs::_internal_add_values() {
  return _impl_.values_.Add();
}
inline void Pairs::add_values(const std::string& value) {
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:remote.Pairs.values)
}
inline void Pairs::add_values(std::string&& value) {
  _impl_.values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:remote.Pairs.values)
}
inline void Pairs::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remote.Pairs.values)
}
inline void Pairs::add_values(const void* value, size_t size) {
  _impl_.values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remote.Pairs.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Pairs::values() const {
  // @@protoc_insertion_point(field_list:remote.Pairs.values)
  return _impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Pairs::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:remote.Pairs.values)
  return &_impl_.values_;
}

// string next_page_token = 3;
inline void Pairs::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& Pairs::next_page_token() const {
  // @@protoc_insertion_point(field_get:remote.Pairs.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pairs::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Pairs.next_page_token)
}
inline std::string* Pairs::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:remote.Pairs.next_page_token)
  return _s;
}
inline const std::string& Pairs::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void Pairs::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* Pairs::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* Pairs::release_next_page_token() {
  // @@protoc_insertion_point(field_release:remote.Pairs.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void Pairs::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Pairs.next_page_token)
}

// -------------------------------------------------------------------

// PairsPagination

// bytes next_key = 1;
inline void PairsPagination::clear_next_key() {
  _impl_.next_key_.ClearToEmpty();
}
inline const std::string& PairsPagination::next_key() const {
  // @@protoc_insertion_point(field_get:remote.PairsPagination.next_key)
  return _internal_next_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PairsPagination::set_next_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.PairsPagination.next_key)
}
inline std::string* PairsPagination::mutable_next_key() {
  std::string* _s = _internal_mutable_next_key();
  // @@protoc_insertion_point(field_mutable:remote.PairsPagination.next_key)
  return _s;
}
inline const std::string& PairsPagination::_internal_next_key() const {
  return _impl_.next_key_.Get();
}
inline void PairsPagination::_internal_set_next_key(const std::string& value) {
  
  _impl_.next_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PairsPagination::_internal_mutable_next_key() {
  
  return _impl_.next_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PairsPagination::release_next_key() {
  // @@protoc_insertion_point(field_release:remote.PairsPagination.next_key)
  return _impl_.next_key_.Release();
}
inline void PairsPagination::set_allocated_next_key(std::string* next_key) {
  if (next_key != nullptr) {
    
  } else {
    
  }
  _impl_.next_key_.SetAllocated(next_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_key_.IsDefault()) {
    _impl_.next_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.PairsPagination.next_key)
}

// sint64 limit = 2;
inline void PairsPagination::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t PairsPagination::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t PairsPagination::limit() const {
  // @@protoc_insertion_point(field_get:remote.PairsPagination.limit)
  return _internal_limit();
}
inline void PairsPagination::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void PairsPagination::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:remote.PairsPagination.limit)
}

// -------------------------------------------------------------------

// IndexPagination

// sint64 next_time_stamp = 1;
inline void IndexPagination::clear_next_time_stamp() {
  _impl_.next_time_stamp_ = int64_t{0};
}
inline int64_t IndexPagination::_internal_next_time_stamp() const {
  return _impl_.next_time_stamp_;
}
inline int64_t IndexPagination::next_time_stamp() const {
  // @@protoc_insertion_point(field_get:remote.IndexPagination.next_time_stamp)
  return _internal_next_time_stamp();
}
inline void IndexPagination::_internal_set_next_time_stamp(int64_t value) {
  
  _impl_.next_time_stamp_ = value;
}
inline void IndexPagination::set_next_time_stamp(int64_t value) {
  _internal_set_next_time_stamp(value);
  // @@protoc_insertion_point(field_set:remote.IndexPagination.next_time_stamp)
}

// sint64 limit = 2;
inline void IndexPagination::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t IndexPagination::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t IndexPagination::limit() const {
  // @@protoc_insertion_point(field_get:remote.IndexPagination.limit)
  return _internal_limit();
}
inline void IndexPagination::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void IndexPagination::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:remote.IndexPagination.limit)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace remote

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::remote::Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Op>() {
  return ::remote::Op_descriptor();
}
template <> struct is_proto_enum< ::remote::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Action>() {
  return ::remote::Action_descriptor();
}
template <> struct is_proto_enum< ::remote::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Direction>() {
  return ::remote::Direction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_remote_2fkv_2eproto
