// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: remote/ethbackend.proto

#include "remote/ethbackend.pb.h"
#include "remote/ethbackend.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace remote {

static const char* ETHBACKEND_method_names[] = {
  "/remote.ETHBACKEND/Etherbase",
  "/remote.ETHBACKEND/NetVersion",
  "/remote.ETHBACKEND/NetPeerCount",
  "/remote.ETHBACKEND/Version",
  "/remote.ETHBACKEND/Syncing",
  "/remote.ETHBACKEND/ProtocolVersion",
  "/remote.ETHBACKEND/ClientVersion",
  "/remote.ETHBACKEND/Subscribe",
  "/remote.ETHBACKEND/SubscribeLogs",
  "/remote.ETHBACKEND/Block",
  "/remote.ETHBACKEND/CanonicalBodyForStorage",
  "/remote.ETHBACKEND/CanonicalHash",
  "/remote.ETHBACKEND/HeaderNumber",
  "/remote.ETHBACKEND/TxnLookup",
  "/remote.ETHBACKEND/NodeInfo",
  "/remote.ETHBACKEND/Peers",
  "/remote.ETHBACKEND/AddPeer",
  "/remote.ETHBACKEND/PendingBlock",
  "/remote.ETHBACKEND/BorTxnLookup",
  "/remote.ETHBACKEND/BorEvents",
};

std::unique_ptr< ETHBACKEND::Stub> ETHBACKEND::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< ETHBACKEND::Stub> stub(new ETHBACKEND::Stub(channel, options));
  return stub;
}

ETHBACKEND::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Etherbase_(ETHBACKEND_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_NetVersion_(ETHBACKEND_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_NetPeerCount_(ETHBACKEND_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Version_(ETHBACKEND_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Syncing_(ETHBACKEND_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ProtocolVersion_(ETHBACKEND_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ClientVersion_(ETHBACKEND_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Subscribe_(ETHBACKEND_method_names[7], options.suffix_for_stats(),::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_SubscribeLogs_(ETHBACKEND_method_names[8], options.suffix_for_stats(),::grpc::internal::RpcMethod::BIDI_STREAMING, channel)
  , rpcmethod_Block_(ETHBACKEND_method_names[9], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CanonicalBodyForStorage_(ETHBACKEND_method_names[10], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CanonicalHash_(ETHBACKEND_method_names[11], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_HeaderNumber_(ETHBACKEND_method_names[12], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_TxnLookup_(ETHBACKEND_method_names[13], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_NodeInfo_(ETHBACKEND_method_names[14], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Peers_(ETHBACKEND_method_names[15], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AddPeer_(ETHBACKEND_method_names[16], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_PendingBlock_(ETHBACKEND_method_names[17], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_BorTxnLookup_(ETHBACKEND_method_names[18], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_BorEvents_(ETHBACKEND_method_names[19], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status ETHBACKEND::Stub::Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::remote::EtherbaseReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::EtherbaseRequest, ::remote::EtherbaseReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Etherbase_, context, request, response);
}

void ETHBACKEND::Stub::async::Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::EtherbaseRequest, ::remote::EtherbaseReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Etherbase_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::Etherbase(::grpc::ClientContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Etherbase_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::EtherbaseReply>* ETHBACKEND::Stub::PrepareAsyncEtherbaseRaw(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::EtherbaseReply, ::remote::EtherbaseRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Etherbase_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::EtherbaseReply>* ETHBACKEND::Stub::AsyncEtherbaseRaw(::grpc::ClientContext* context, const ::remote::EtherbaseRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncEtherbaseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::remote::NetVersionReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::NetVersionRequest, ::remote::NetVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_NetVersion_, context, request, response);
}

void ETHBACKEND::Stub::async::NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::NetVersionRequest, ::remote::NetVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_NetVersion_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::NetVersion(::grpc::ClientContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_NetVersion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::NetVersionReply>* ETHBACKEND::Stub::PrepareAsyncNetVersionRaw(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::NetVersionReply, ::remote::NetVersionRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_NetVersion_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::NetVersionReply>* ETHBACKEND::Stub::AsyncNetVersionRaw(::grpc::ClientContext* context, const ::remote::NetVersionRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncNetVersionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::remote::NetPeerCountReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::NetPeerCountRequest, ::remote::NetPeerCountReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_NetPeerCount_, context, request, response);
}

void ETHBACKEND::Stub::async::NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::NetPeerCountRequest, ::remote::NetPeerCountReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_NetPeerCount_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::NetPeerCount(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_NetPeerCount_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::NetPeerCountReply>* ETHBACKEND::Stub::PrepareAsyncNetPeerCountRaw(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::NetPeerCountReply, ::remote::NetPeerCountRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_NetPeerCount_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::NetPeerCountReply>* ETHBACKEND::Stub::AsyncNetPeerCountRaw(::grpc::ClientContext* context, const ::remote::NetPeerCountRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncNetPeerCountRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::Version(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::VersionReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::google::protobuf::Empty, ::types::VersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Version_, context, request, response);
}

void ETHBACKEND::Stub::async::Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::google::protobuf::Empty, ::types::VersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Version_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::Version(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Version_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::types::VersionReply>* ETHBACKEND::Stub::PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::types::VersionReply, ::google::protobuf::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Version_, context, request);
}

::grpc::ClientAsyncResponseReader< ::types::VersionReply>* ETHBACKEND::Stub::AsyncVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncVersionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::SyncingReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::google::protobuf::Empty, ::remote::SyncingReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Syncing_, context, request, response);
}

void ETHBACKEND::Stub::async::Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::google::protobuf::Empty, ::remote::SyncingReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Syncing_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::Syncing(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Syncing_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::SyncingReply>* ETHBACKEND::Stub::PrepareAsyncSyncingRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::SyncingReply, ::google::protobuf::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Syncing_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::SyncingReply>* ETHBACKEND::Stub::AsyncSyncingRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSyncingRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::remote::ProtocolVersionReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::ProtocolVersionRequest, ::remote::ProtocolVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ProtocolVersion_, context, request, response);
}

void ETHBACKEND::Stub::async::ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::ProtocolVersionRequest, ::remote::ProtocolVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ProtocolVersion_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::ProtocolVersion(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ProtocolVersion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::ProtocolVersionReply>* ETHBACKEND::Stub::PrepareAsyncProtocolVersionRaw(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::ProtocolVersionReply, ::remote::ProtocolVersionRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ProtocolVersion_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::ProtocolVersionReply>* ETHBACKEND::Stub::AsyncProtocolVersionRaw(::grpc::ClientContext* context, const ::remote::ProtocolVersionRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncProtocolVersionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::remote::ClientVersionReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::ClientVersionRequest, ::remote::ClientVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ClientVersion_, context, request, response);
}

void ETHBACKEND::Stub::async::ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::ClientVersionRequest, ::remote::ClientVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ClientVersion_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::ClientVersion(::grpc::ClientContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ClientVersion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::ClientVersionReply>* ETHBACKEND::Stub::PrepareAsyncClientVersionRaw(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::ClientVersionReply, ::remote::ClientVersionRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ClientVersion_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::ClientVersionReply>* ETHBACKEND::Stub::AsyncClientVersionRaw(::grpc::ClientContext* context, const ::remote::ClientVersionRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncClientVersionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::ClientReader< ::remote::SubscribeReply>* ETHBACKEND::Stub::SubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request) {
  return ::grpc::internal::ClientReaderFactory< ::remote::SubscribeReply>::Create(channel_.get(), rpcmethod_Subscribe_, context, request);
}

void ETHBACKEND::Stub::async::Subscribe(::grpc::ClientContext* context, const ::remote::SubscribeRequest* request, ::grpc::ClientReadReactor< ::remote::SubscribeReply>* reactor) {
  ::grpc::internal::ClientCallbackReaderFactory< ::remote::SubscribeReply>::Create(stub_->channel_.get(), stub_->rpcmethod_Subscribe_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::remote::SubscribeReply>* ETHBACKEND::Stub::AsyncSubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::remote::SubscribeReply>::Create(channel_.get(), cq, rpcmethod_Subscribe_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::remote::SubscribeReply>* ETHBACKEND::Stub::PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::remote::SubscribeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::remote::SubscribeReply>::Create(channel_.get(), cq, rpcmethod_Subscribe_, context, request, false, nullptr);
}

::grpc::ClientReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* ETHBACKEND::Stub::SubscribeLogsRaw(::grpc::ClientContext* context) {
  return ::grpc::internal::ClientReaderWriterFactory< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>::Create(channel_.get(), rpcmethod_SubscribeLogs_, context);
}

void ETHBACKEND::Stub::async::SubscribeLogs(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::remote::LogsFilterRequest,::remote::SubscribeLogsReply>* reactor) {
  ::grpc::internal::ClientCallbackReaderWriterFactory< ::remote::LogsFilterRequest,::remote::SubscribeLogsReply>::Create(stub_->channel_.get(), stub_->rpcmethod_SubscribeLogs_, context, reactor);
}

::grpc::ClientAsyncReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* ETHBACKEND::Stub::AsyncSubscribeLogsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncReaderWriterFactory< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>::Create(channel_.get(), cq, rpcmethod_SubscribeLogs_, context, true, tag);
}

::grpc::ClientAsyncReaderWriter< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>* ETHBACKEND::Stub::PrepareAsyncSubscribeLogsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncReaderWriterFactory< ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>::Create(channel_.get(), cq, rpcmethod_SubscribeLogs_, context, false, nullptr);
}

::grpc::Status ETHBACKEND::Stub::Block(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::remote::BlockReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::BlockRequest, ::remote::BlockReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Block_, context, request, response);
}

void ETHBACKEND::Stub::async::Block(::grpc::ClientContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::BlockRequest, ::remote::BlockReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Block_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::Block(::grpc::ClientContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Block_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::BlockReply>* ETHBACKEND::Stub::PrepareAsyncBlockRaw(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::BlockReply, ::remote::BlockRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Block_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::BlockReply>* ETHBACKEND::Stub::AsyncBlockRaw(::grpc::ClientContext* context, const ::remote::BlockRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncBlockRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::remote::CanonicalBodyForStorageReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::CanonicalBodyForStorageRequest, ::remote::CanonicalBodyForStorageReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_CanonicalBodyForStorage_, context, request, response);
}

void ETHBACKEND::Stub::async::CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::CanonicalBodyForStorageRequest, ::remote::CanonicalBodyForStorageReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CanonicalBodyForStorage_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::CanonicalBodyForStorage(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CanonicalBodyForStorage_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::CanonicalBodyForStorageReply>* ETHBACKEND::Stub::PrepareAsyncCanonicalBodyForStorageRaw(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::CanonicalBodyForStorageReply, ::remote::CanonicalBodyForStorageRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CanonicalBodyForStorage_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::CanonicalBodyForStorageReply>* ETHBACKEND::Stub::AsyncCanonicalBodyForStorageRaw(::grpc::ClientContext* context, const ::remote::CanonicalBodyForStorageRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCanonicalBodyForStorageRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::remote::CanonicalHashReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::CanonicalHashRequest, ::remote::CanonicalHashReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_CanonicalHash_, context, request, response);
}

void ETHBACKEND::Stub::async::CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::CanonicalHashRequest, ::remote::CanonicalHashReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CanonicalHash_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::CanonicalHash(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CanonicalHash_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::CanonicalHashReply>* ETHBACKEND::Stub::PrepareAsyncCanonicalHashRaw(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::CanonicalHashReply, ::remote::CanonicalHashRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CanonicalHash_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::CanonicalHashReply>* ETHBACKEND::Stub::AsyncCanonicalHashRaw(::grpc::ClientContext* context, const ::remote::CanonicalHashRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCanonicalHashRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::remote::HeaderNumberReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::HeaderNumberRequest, ::remote::HeaderNumberReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_HeaderNumber_, context, request, response);
}

void ETHBACKEND::Stub::async::HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::HeaderNumberRequest, ::remote::HeaderNumberReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_HeaderNumber_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::HeaderNumber(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_HeaderNumber_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::HeaderNumberReply>* ETHBACKEND::Stub::PrepareAsyncHeaderNumberRaw(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::HeaderNumberReply, ::remote::HeaderNumberRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_HeaderNumber_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::HeaderNumberReply>* ETHBACKEND::Stub::AsyncHeaderNumberRaw(::grpc::ClientContext* context, const ::remote::HeaderNumberRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncHeaderNumberRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::remote::TxnLookupReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::TxnLookupRequest, ::remote::TxnLookupReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_TxnLookup_, context, request, response);
}

void ETHBACKEND::Stub::async::TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::TxnLookupRequest, ::remote::TxnLookupReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_TxnLookup_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::TxnLookup(::grpc::ClientContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_TxnLookup_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::TxnLookupReply>* ETHBACKEND::Stub::PrepareAsyncTxnLookupRaw(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::TxnLookupReply, ::remote::TxnLookupRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_TxnLookup_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::TxnLookupReply>* ETHBACKEND::Stub::AsyncTxnLookupRaw(::grpc::ClientContext* context, const ::remote::TxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncTxnLookupRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::remote::NodesInfoReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::NodesInfoRequest, ::remote::NodesInfoReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_NodeInfo_, context, request, response);
}

void ETHBACKEND::Stub::async::NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::NodesInfoRequest, ::remote::NodesInfoReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_NodeInfo_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::NodeInfo(::grpc::ClientContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_NodeInfo_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::NodesInfoReply>* ETHBACKEND::Stub::PrepareAsyncNodeInfoRaw(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::NodesInfoReply, ::remote::NodesInfoRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_NodeInfo_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::NodesInfoReply>* ETHBACKEND::Stub::AsyncNodeInfoRaw(::grpc::ClientContext* context, const ::remote::NodesInfoRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncNodeInfoRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::PeersReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::google::protobuf::Empty, ::remote::PeersReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Peers_, context, request, response);
}

void ETHBACKEND::Stub::async::Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::google::protobuf::Empty, ::remote::PeersReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Peers_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Peers_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::PeersReply>* ETHBACKEND::Stub::PrepareAsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::PeersReply, ::google::protobuf::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Peers_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::PeersReply>* ETHBACKEND::Stub::AsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPeersRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::remote::AddPeerReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::AddPeerRequest, ::remote::AddPeerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AddPeer_, context, request, response);
}

void ETHBACKEND::Stub::async::AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::AddPeerRequest, ::remote::AddPeerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AddPeer_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::AddPeer(::grpc::ClientContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AddPeer_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::AddPeerReply>* ETHBACKEND::Stub::PrepareAsyncAddPeerRaw(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::AddPeerReply, ::remote::AddPeerRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AddPeer_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::AddPeerReply>* ETHBACKEND::Stub::AsyncAddPeerRaw(::grpc::ClientContext* context, const ::remote::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAddPeerRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::remote::PendingBlockReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::google::protobuf::Empty, ::remote::PendingBlockReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_PendingBlock_, context, request, response);
}

void ETHBACKEND::Stub::async::PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::google::protobuf::Empty, ::remote::PendingBlockReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_PendingBlock_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::PendingBlock(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_PendingBlock_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::PendingBlockReply>* ETHBACKEND::Stub::PrepareAsyncPendingBlockRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::PendingBlockReply, ::google::protobuf::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_PendingBlock_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::PendingBlockReply>* ETHBACKEND::Stub::AsyncPendingBlockRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPendingBlockRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::remote::BorTxnLookupReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::BorTxnLookupRequest, ::remote::BorTxnLookupReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_BorTxnLookup_, context, request, response);
}

void ETHBACKEND::Stub::async::BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::BorTxnLookupRequest, ::remote::BorTxnLookupReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_BorTxnLookup_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::BorTxnLookup(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_BorTxnLookup_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::BorTxnLookupReply>* ETHBACKEND::Stub::PrepareAsyncBorTxnLookupRaw(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::BorTxnLookupReply, ::remote::BorTxnLookupRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_BorTxnLookup_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::BorTxnLookupReply>* ETHBACKEND::Stub::AsyncBorTxnLookupRaw(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncBorTxnLookupRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ETHBACKEND::Stub::BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::remote::BorEventsReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::remote::BorEventsRequest, ::remote::BorEventsReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_BorEvents_, context, request, response);
}

void ETHBACKEND::Stub::async::BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::remote::BorEventsRequest, ::remote::BorEventsReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_BorEvents_, context, request, response, std::move(f));
}

void ETHBACKEND::Stub::async::BorEvents(::grpc::ClientContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_BorEvents_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::remote::BorEventsReply>* ETHBACKEND::Stub::PrepareAsyncBorEventsRaw(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::remote::BorEventsReply, ::remote::BorEventsRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_BorEvents_, context, request);
}

::grpc::ClientAsyncResponseReader< ::remote::BorEventsReply>* ETHBACKEND::Stub::AsyncBorEventsRaw(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncBorEventsRaw(context, request, cq);
  result->StartCall();
  return result;
}

ETHBACKEND::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::EtherbaseRequest, ::remote::EtherbaseReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::EtherbaseRequest* req,
             ::remote::EtherbaseReply* resp) {
               return service->Etherbase(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::NetVersionRequest, ::remote::NetVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::NetVersionRequest* req,
             ::remote::NetVersionReply* resp) {
               return service->NetVersion(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::NetPeerCountRequest, ::remote::NetPeerCountReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::NetPeerCountRequest* req,
             ::remote::NetPeerCountReply* resp) {
               return service->NetPeerCount(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::google::protobuf::Empty, ::types::VersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::google::protobuf::Empty* req,
             ::types::VersionReply* resp) {
               return service->Version(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::google::protobuf::Empty, ::remote::SyncingReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::google::protobuf::Empty* req,
             ::remote::SyncingReply* resp) {
               return service->Syncing(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::ProtocolVersionRequest, ::remote::ProtocolVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::ProtocolVersionRequest* req,
             ::remote::ProtocolVersionReply* resp) {
               return service->ProtocolVersion(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::ClientVersionRequest, ::remote::ClientVersionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::ClientVersionRequest* req,
             ::remote::ClientVersionReply* resp) {
               return service->ClientVersion(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[7],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< ETHBACKEND::Service, ::remote::SubscribeRequest, ::remote::SubscribeReply>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::SubscribeRequest* req,
             ::grpc::ServerWriter<::remote::SubscribeReply>* writer) {
               return service->Subscribe(ctx, req, writer);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[8],
      ::grpc::internal::RpcMethod::BIDI_STREAMING,
      new ::grpc::internal::BidiStreamingHandler< ETHBACKEND::Service, ::remote::LogsFilterRequest, ::remote::SubscribeLogsReply>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             ::grpc::ServerReaderWriter<::remote::SubscribeLogsReply,
             ::remote::LogsFilterRequest>* stream) {
               return service->SubscribeLogs(ctx, stream);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::BlockRequest, ::remote::BlockReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::BlockRequest* req,
             ::remote::BlockReply* resp) {
               return service->Block(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::CanonicalBodyForStorageRequest, ::remote::CanonicalBodyForStorageReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::CanonicalBodyForStorageRequest* req,
             ::remote::CanonicalBodyForStorageReply* resp) {
               return service->CanonicalBodyForStorage(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::CanonicalHashRequest, ::remote::CanonicalHashReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::CanonicalHashRequest* req,
             ::remote::CanonicalHashReply* resp) {
               return service->CanonicalHash(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::HeaderNumberRequest, ::remote::HeaderNumberReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::HeaderNumberRequest* req,
             ::remote::HeaderNumberReply* resp) {
               return service->HeaderNumber(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::TxnLookupRequest, ::remote::TxnLookupReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::TxnLookupRequest* req,
             ::remote::TxnLookupReply* resp) {
               return service->TxnLookup(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::NodesInfoRequest, ::remote::NodesInfoReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::NodesInfoRequest* req,
             ::remote::NodesInfoReply* resp) {
               return service->NodeInfo(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::google::protobuf::Empty, ::remote::PeersReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::google::protobuf::Empty* req,
             ::remote::PeersReply* resp) {
               return service->Peers(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::AddPeerRequest, ::remote::AddPeerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::AddPeerRequest* req,
             ::remote::AddPeerReply* resp) {
               return service->AddPeer(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::google::protobuf::Empty, ::remote::PendingBlockReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::google::protobuf::Empty* req,
             ::remote::PendingBlockReply* resp) {
               return service->PendingBlock(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::BorTxnLookupRequest, ::remote::BorTxnLookupReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::BorTxnLookupRequest* req,
             ::remote::BorTxnLookupReply* resp) {
               return service->BorTxnLookup(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ETHBACKEND_method_names[19],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ETHBACKEND::Service, ::remote::BorEventsRequest, ::remote::BorEventsReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ETHBACKEND::Service* service,
             ::grpc::ServerContext* ctx,
             const ::remote::BorEventsRequest* req,
             ::remote::BorEventsReply* resp) {
               return service->BorEvents(ctx, req, resp);
             }, this)));
}

ETHBACKEND::Service::~Service() {
}

::grpc::Status ETHBACKEND::Service::Etherbase(::grpc::ServerContext* context, const ::remote::EtherbaseRequest* request, ::remote::EtherbaseReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::NetVersion(::grpc::ServerContext* context, const ::remote::NetVersionRequest* request, ::remote::NetVersionReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::NetPeerCount(::grpc::ServerContext* context, const ::remote::NetPeerCountRequest* request, ::remote::NetPeerCountReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::Version(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::types::VersionReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::Syncing(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::remote::SyncingReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::ProtocolVersion(::grpc::ServerContext* context, const ::remote::ProtocolVersionRequest* request, ::remote::ProtocolVersionReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::ClientVersion(::grpc::ServerContext* context, const ::remote::ClientVersionRequest* request, ::remote::ClientVersionReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::Subscribe(::grpc::ServerContext* context, const ::remote::SubscribeRequest* request, ::grpc::ServerWriter< ::remote::SubscribeReply>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::SubscribeLogs(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::remote::SubscribeLogsReply, ::remote::LogsFilterRequest>* stream) {
  (void) context;
  (void) stream;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::Block(::grpc::ServerContext* context, const ::remote::BlockRequest* request, ::remote::BlockReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::CanonicalBodyForStorage(::grpc::ServerContext* context, const ::remote::CanonicalBodyForStorageRequest* request, ::remote::CanonicalBodyForStorageReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::CanonicalHash(::grpc::ServerContext* context, const ::remote::CanonicalHashRequest* request, ::remote::CanonicalHashReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::HeaderNumber(::grpc::ServerContext* context, const ::remote::HeaderNumberRequest* request, ::remote::HeaderNumberReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::TxnLookup(::grpc::ServerContext* context, const ::remote::TxnLookupRequest* request, ::remote::TxnLookupReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::NodeInfo(::grpc::ServerContext* context, const ::remote::NodesInfoRequest* request, ::remote::NodesInfoReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::Peers(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::remote::PeersReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::AddPeer(::grpc::ServerContext* context, const ::remote::AddPeerRequest* request, ::remote::AddPeerReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::PendingBlock(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::remote::PendingBlockReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::BorTxnLookup(::grpc::ServerContext* context, const ::remote::BorTxnLookupRequest* request, ::remote::BorTxnLookupReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ETHBACKEND::Service::BorEvents(::grpc::ServerContext* context, const ::remote::BorEventsRequest* request, ::remote::BorEventsReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace remote

