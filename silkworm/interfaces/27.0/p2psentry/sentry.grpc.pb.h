// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: p2psentry/sentry.proto
#ifndef GRPC_p2psentry_2fsentry_2eproto__INCLUDED
#define GRPC_p2psentry_2fsentry_2eproto__INCLUDED

#include "p2psentry/sentry.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace sentry {

class Sentry final {
 public:
  static constexpr char const* service_full_name() {
    return "sentry.Sentry";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // SetStatus - force new ETH client state of sentry - network_id, max_block, etc...
    virtual ::grpc::Status SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::sentry::SetStatusReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>> AsyncSetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>>(AsyncSetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>> PrepareAsyncSetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>>(PrepareAsyncSetStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncPenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncPenalizePeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncPenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncPenalizePeerRaw(context, request, cq));
    }
    virtual ::grpc::Status PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncPeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncPeerMinBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncPeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncPeerMinBlockRaw(context, request, cq));
    }
    // HandShake - pre-requirement for all Send* methods - returns list of ETH protocol versions,
    // without knowledge of protocol - impossible encode correct P2P message
    virtual ::grpc::Status HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sentry::HandShakeReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>> AsyncHandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>>(AsyncHandShakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>> PrepareAsyncHandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>>(PrepareAsyncHandShakeRaw(context, request, cq));
    }
    virtual ::grpc::Status SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::sentry::SentPeers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> AsyncSendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(AsyncSendMessageByMinBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> PrepareAsyncSendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(PrepareAsyncSendMessageByMinBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::sentry::SentPeers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> AsyncSendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(AsyncSendMessageByIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> PrepareAsyncSendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(PrepareAsyncSendMessageByIdRaw(context, request, cq));
    }
    virtual ::grpc::Status SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::sentry::SentPeers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> AsyncSendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(AsyncSendMessageToRandomPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> PrepareAsyncSendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(PrepareAsyncSendMessageToRandomPeersRaw(context, request, cq));
    }
    virtual ::grpc::Status SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::sentry::SentPeers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> AsyncSendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(AsyncSendMessageToAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> PrepareAsyncSendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(PrepareAsyncSendMessageToAllRaw(context, request, cq));
    }
    // Subscribe to receive messages.
    // Calling multiple times with a different set of ids starts separate streams.
    // It is possible to subscribe to the same set if ids more than once.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sentry::InboundMessage>> Messages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sentry::InboundMessage>>(MessagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>> AsyncMessages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>>(AsyncMessagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>> PrepareAsyncMessages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>>(PrepareAsyncMessagesRaw(context, request, cq));
    }
    virtual ::grpc::Status Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sentry::PeersReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeersReply>> AsyncPeers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeersReply>>(AsyncPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeersReply>> PrepareAsyncPeers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeersReply>>(PrepareAsyncPeersRaw(context, request, cq));
    }
    virtual ::grpc::Status PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::sentry::PeerCountReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>> AsyncPeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>>(AsyncPeerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>> PrepareAsyncPeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>>(PrepareAsyncPeerCountRaw(context, request, cq));
    }
    virtual ::grpc::Status PeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::sentry::PeerByIdReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerByIdReply>> AsyncPeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerByIdReply>>(AsyncPeerByIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerByIdReply>> PrepareAsyncPeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerByIdReply>>(PrepareAsyncPeerByIdRaw(context, request, cq));
    }
    // Subscribe to notifications about connected or lost peers.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sentry::PeerEvent>> PeerEvents(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sentry::PeerEvent>>(PeerEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::PeerEvent>> AsyncPeerEvents(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::PeerEvent>>(AsyncPeerEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::PeerEvent>> PrepareAsyncPeerEvents(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::PeerEvent>>(PrepareAsyncPeerEventsRaw(context, request, cq));
    }
    virtual ::grpc::Status AddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::sentry::AddPeerReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::AddPeerReply>> AsyncAddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::AddPeerReply>>(AsyncAddPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::AddPeerReply>> PrepareAsyncAddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::AddPeerReply>>(PrepareAsyncAddPeerRaw(context, request, cq));
    }
    // NodeInfo returns a collection of metadata known about the host.
    virtual ::grpc::Status NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::NodeInfoReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>> AsyncNodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>>(AsyncNodeInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>> PrepareAsyncNodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>>(PrepareAsyncNodeInfoRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // SetStatus - force new ETH client state of sentry - network_id, max_block, etc...
      virtual void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // HandShake - pre-requirement for all Send* methods - returns list of ETH protocol versions,
      // without knowledge of protocol - impossible encode correct P2P message
      virtual void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Subscribe to receive messages.
      // Calling multiple times with a different set of ids starts separate streams.
      // It is possible to subscribe to the same set if ids more than once.
      virtual void Messages(::grpc::ClientContext* context, const ::sentry::MessagesRequest* request, ::grpc::ClientReadReactor< ::sentry::InboundMessage>* reactor) = 0;
      virtual void Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::PeersReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::PeersReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest* request, ::sentry::PeerByIdReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest* request, ::sentry::PeerByIdReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Subscribe to notifications about connected or lost peers.
      virtual void PeerEvents(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest* request, ::grpc::ClientReadReactor< ::sentry::PeerEvent>* reactor) = 0;
      virtual void AddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest* request, ::sentry::AddPeerReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest* request, ::sentry::AddPeerReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // NodeInfo returns a collection of metadata known about the host.
      virtual void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>* AsyncSetStatusRaw(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>* PrepareAsyncSetStatusRaw(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncPenalizePeerRaw(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncPenalizePeerRaw(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncPeerMinBlockRaw(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncPeerMinBlockRaw(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>* AsyncHandShakeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>* PrepareAsyncHandShakeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* AsyncSendMessageByMinBlockRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* PrepareAsyncSendMessageByMinBlockRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* AsyncSendMessageByIdRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* PrepareAsyncSendMessageByIdRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* AsyncSendMessageToRandomPeersRaw(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* PrepareAsyncSendMessageToRandomPeersRaw(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* AsyncSendMessageToAllRaw(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* PrepareAsyncSendMessageToAllRaw(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sentry::InboundMessage>* MessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>* AsyncMessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>* PrepareAsyncMessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeersReply>* AsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeersReply>* PrepareAsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>* AsyncPeerCountRaw(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>* PrepareAsyncPeerCountRaw(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerByIdReply>* AsyncPeerByIdRaw(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerByIdReply>* PrepareAsyncPeerByIdRaw(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sentry::PeerEvent>* PeerEventsRaw(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentry::PeerEvent>* AsyncPeerEventsRaw(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentry::PeerEvent>* PrepareAsyncPeerEventsRaw(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::AddPeerReply>* AsyncAddPeerRaw(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::AddPeerReply>* PrepareAsyncAddPeerRaw(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>* AsyncNodeInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>* PrepareAsyncNodeInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::sentry::SetStatusReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>> AsyncSetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>>(AsyncSetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>> PrepareAsyncSetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>>(PrepareAsyncSetStatusRaw(context, request, cq));
    }
    ::grpc::Status PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncPenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncPenalizePeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncPenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncPenalizePeerRaw(context, request, cq));
    }
    ::grpc::Status PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncPeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncPeerMinBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncPeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncPeerMinBlockRaw(context, request, cq));
    }
    ::grpc::Status HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sentry::HandShakeReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>> AsyncHandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>>(AsyncHandShakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>> PrepareAsyncHandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>>(PrepareAsyncHandShakeRaw(context, request, cq));
    }
    ::grpc::Status SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::sentry::SentPeers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> AsyncSendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(AsyncSendMessageByMinBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> PrepareAsyncSendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(PrepareAsyncSendMessageByMinBlockRaw(context, request, cq));
    }
    ::grpc::Status SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::sentry::SentPeers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> AsyncSendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(AsyncSendMessageByIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> PrepareAsyncSendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(PrepareAsyncSendMessageByIdRaw(context, request, cq));
    }
    ::grpc::Status SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::sentry::SentPeers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> AsyncSendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(AsyncSendMessageToRandomPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> PrepareAsyncSendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(PrepareAsyncSendMessageToRandomPeersRaw(context, request, cq));
    }
    ::grpc::Status SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::sentry::SentPeers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> AsyncSendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(AsyncSendMessageToAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> PrepareAsyncSendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(PrepareAsyncSendMessageToAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sentry::InboundMessage>> Messages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sentry::InboundMessage>>(MessagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::InboundMessage>> AsyncMessages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::InboundMessage>>(AsyncMessagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::InboundMessage>> PrepareAsyncMessages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::InboundMessage>>(PrepareAsyncMessagesRaw(context, request, cq));
    }
    ::grpc::Status Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sentry::PeersReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeersReply>> AsyncPeers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeersReply>>(AsyncPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeersReply>> PrepareAsyncPeers(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeersReply>>(PrepareAsyncPeersRaw(context, request, cq));
    }
    ::grpc::Status PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::sentry::PeerCountReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>> AsyncPeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>>(AsyncPeerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>> PrepareAsyncPeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>>(PrepareAsyncPeerCountRaw(context, request, cq));
    }
    ::grpc::Status PeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::sentry::PeerByIdReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerByIdReply>> AsyncPeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerByIdReply>>(AsyncPeerByIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerByIdReply>> PrepareAsyncPeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerByIdReply>>(PrepareAsyncPeerByIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sentry::PeerEvent>> PeerEvents(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sentry::PeerEvent>>(PeerEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::PeerEvent>> AsyncPeerEvents(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::PeerEvent>>(AsyncPeerEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::PeerEvent>> PrepareAsyncPeerEvents(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::PeerEvent>>(PrepareAsyncPeerEventsRaw(context, request, cq));
    }
    ::grpc::Status AddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::sentry::AddPeerReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::AddPeerReply>> AsyncAddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::AddPeerReply>>(AsyncAddPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::AddPeerReply>> PrepareAsyncAddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::AddPeerReply>>(PrepareAsyncAddPeerRaw(context, request, cq));
    }
    ::grpc::Status NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::NodeInfoReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>> AsyncNodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>>(AsyncNodeInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>> PrepareAsyncNodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>>(PrepareAsyncNodeInfoRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, std::function<void(::grpc::Status)>) override;
      void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, std::function<void(::grpc::Status)>) override;
      void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Messages(::grpc::ClientContext* context, const ::sentry::MessagesRequest* request, ::grpc::ClientReadReactor< ::sentry::InboundMessage>* reactor) override;
      void Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::PeersReply* response, std::function<void(::grpc::Status)>) override;
      void Peers(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::PeersReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, std::function<void(::grpc::Status)>) override;
      void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest* request, ::sentry::PeerByIdReply* response, std::function<void(::grpc::Status)>) override;
      void PeerById(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest* request, ::sentry::PeerByIdReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PeerEvents(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest* request, ::grpc::ClientReadReactor< ::sentry::PeerEvent>* reactor) override;
      void AddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest* request, ::sentry::AddPeerReply* response, std::function<void(::grpc::Status)>) override;
      void AddPeer(::grpc::ClientContext* context, const ::sentry::AddPeerRequest* request, ::sentry::AddPeerReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, std::function<void(::grpc::Status)>) override;
      void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>* AsyncSetStatusRaw(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>* PrepareAsyncSetStatusRaw(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncPenalizePeerRaw(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncPenalizePeerRaw(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncPeerMinBlockRaw(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncPeerMinBlockRaw(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>* AsyncHandShakeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>* PrepareAsyncHandShakeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* AsyncSendMessageByMinBlockRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* PrepareAsyncSendMessageByMinBlockRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* AsyncSendMessageByIdRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* PrepareAsyncSendMessageByIdRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* AsyncSendMessageToRandomPeersRaw(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* PrepareAsyncSendMessageToRandomPeersRaw(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* AsyncSendMessageToAllRaw(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* PrepareAsyncSendMessageToAllRaw(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sentry::InboundMessage>* MessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request) override;
    ::grpc::ClientAsyncReader< ::sentry::InboundMessage>* AsyncMessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sentry::InboundMessage>* PrepareAsyncMessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::PeersReply>* AsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::PeersReply>* PrepareAsyncPeersRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>* AsyncPeerCountRaw(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>* PrepareAsyncPeerCountRaw(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::PeerByIdReply>* AsyncPeerByIdRaw(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::PeerByIdReply>* PrepareAsyncPeerByIdRaw(::grpc::ClientContext* context, const ::sentry::PeerByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sentry::PeerEvent>* PeerEventsRaw(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request) override;
    ::grpc::ClientAsyncReader< ::sentry::PeerEvent>* AsyncPeerEventsRaw(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sentry::PeerEvent>* PrepareAsyncPeerEventsRaw(::grpc::ClientContext* context, const ::sentry::PeerEventsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::AddPeerReply>* AsyncAddPeerRaw(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::AddPeerReply>* PrepareAsyncAddPeerRaw(::grpc::ClientContext* context, const ::sentry::AddPeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>* AsyncNodeInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>* PrepareAsyncNodeInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_PenalizePeer_;
    const ::grpc::internal::RpcMethod rpcmethod_PeerMinBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_HandShake_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMessageByMinBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMessageById_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMessageToRandomPeers_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMessageToAll_;
    const ::grpc::internal::RpcMethod rpcmethod_Messages_;
    const ::grpc::internal::RpcMethod rpcmethod_Peers_;
    const ::grpc::internal::RpcMethod rpcmethod_PeerCount_;
    const ::grpc::internal::RpcMethod rpcmethod_PeerById_;
    const ::grpc::internal::RpcMethod rpcmethod_PeerEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_AddPeer_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // SetStatus - force new ETH client state of sentry - network_id, max_block, etc...
    virtual ::grpc::Status SetStatus(::grpc::ServerContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response);
    virtual ::grpc::Status PenalizePeer(::grpc::ServerContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status PeerMinBlock(::grpc::ServerContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response);
    // HandShake - pre-requirement for all Send* methods - returns list of ETH protocol versions,
    // without knowledge of protocol - impossible encode correct P2P message
    virtual ::grpc::Status HandShake(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response);
    virtual ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response);
    virtual ::grpc::Status SendMessageById(::grpc::ServerContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response);
    virtual ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response);
    virtual ::grpc::Status SendMessageToAll(::grpc::ServerContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response);
    // Subscribe to receive messages.
    // Calling multiple times with a different set of ids starts separate streams.
    // It is possible to subscribe to the same set if ids more than once.
    virtual ::grpc::Status Messages(::grpc::ServerContext* context, const ::sentry::MessagesRequest* request, ::grpc::ServerWriter< ::sentry::InboundMessage>* writer);
    virtual ::grpc::Status Peers(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sentry::PeersReply* response);
    virtual ::grpc::Status PeerCount(::grpc::ServerContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response);
    virtual ::grpc::Status PeerById(::grpc::ServerContext* context, const ::sentry::PeerByIdRequest* request, ::sentry::PeerByIdReply* response);
    // Subscribe to notifications about connected or lost peers.
    virtual ::grpc::Status PeerEvents(::grpc::ServerContext* context, const ::sentry::PeerEventsRequest* request, ::grpc::ServerWriter< ::sentry::PeerEvent>* writer);
    virtual ::grpc::Status AddPeer(::grpc::ServerContext* context, const ::sentry::AddPeerRequest* request, ::sentry::AddPeerReply* response);
    // NodeInfo returns a collection of metadata known about the host.
    virtual ::grpc::Status NodeInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetStatus() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStatus(::grpc::ServerContext* context, ::sentry::StatusData* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SetStatusReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPenalizePeer(::grpc::ServerContext* context, ::sentry::PenalizePeerRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerMinBlock(::grpc::ServerContext* context, ::sentry::PeerMinBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HandShake() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandShake(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sentry::HandShakeReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageByMinBlock(::grpc::ServerContext* context, ::sentry::SendMessageByMinBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SentPeers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMessageById() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageById(::grpc::ServerContext* context, ::sentry::SendMessageByIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SentPeers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageToRandomPeers(::grpc::ServerContext* context, ::sentry::SendMessageToRandomPeersRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SentPeers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageToAll(::grpc::ServerContext* context, ::sentry::OutboundMessageData* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SentPeers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Messages() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMessages(::grpc::ServerContext* context, ::sentry::MessagesRequest* request, ::grpc::ServerAsyncWriter< ::sentry::InboundMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Peers() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeers(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sentry::PeersReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PeerCount() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerCount(::grpc::ServerContext* context, ::sentry::PeerCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::PeerCountReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PeerById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PeerById() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_PeerById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerById(::grpc::ServerContext* /*context*/, const ::sentry::PeerByIdRequest* /*request*/, ::sentry::PeerByIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerById(::grpc::ServerContext* context, ::sentry::PeerByIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::PeerByIdReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PeerEvents() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_PeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerEvents(::grpc::ServerContext* /*context*/, const ::sentry::PeerEventsRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerEvents(::grpc::ServerContext* context, ::sentry::PeerEventsRequest* request, ::grpc::ServerAsyncWriter< ::sentry::PeerEvent>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(12, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddPeer() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::sentry::AddPeerRequest* /*request*/, ::sentry::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPeer(::grpc::ServerContext* context, ::sentry::AddPeerRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::AddPeerReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeInfo() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeInfo(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::types::NodeInfoReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetStatus<WithAsyncMethod_PenalizePeer<WithAsyncMethod_PeerMinBlock<WithAsyncMethod_HandShake<WithAsyncMethod_SendMessageByMinBlock<WithAsyncMethod_SendMessageById<WithAsyncMethod_SendMessageToRandomPeers<WithAsyncMethod_SendMessageToAll<WithAsyncMethod_Messages<WithAsyncMethod_Peers<WithAsyncMethod_PeerCount<WithAsyncMethod_PeerById<WithAsyncMethod_PeerEvents<WithAsyncMethod_AddPeer<WithAsyncMethod_NodeInfo<Service > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetStatus() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::StatusData, ::sentry::SetStatusReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response) { return this->SetStatus(context, request, response); }));}
    void SetMessageAllocatorFor_SetStatus(
        ::grpc::MessageAllocator< ::sentry::StatusData, ::sentry::SetStatusReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::StatusData, ::sentry::SetStatusReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response) { return this->PenalizePeer(context, request, response); }));}
    void SetMessageAllocatorFor_PenalizePeer(
        ::grpc::MessageAllocator< ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PenalizePeer(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response) { return this->PeerMinBlock(context, request, response); }));}
    void SetMessageAllocatorFor_PeerMinBlock(
        ::grpc::MessageAllocator< ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PeerMinBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HandShake() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sentry::HandShakeReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response) { return this->HandShake(context, request, response); }));}
    void SetMessageAllocatorFor_HandShake(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::sentry::HandShakeReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sentry::HandShakeReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HandShake(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response) { return this->SendMessageByMinBlock(context, request, response); }));}
    void SetMessageAllocatorFor_SendMessageByMinBlock(
        ::grpc::MessageAllocator< ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendMessageByMinBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendMessageById() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response) { return this->SendMessageById(context, request, response); }));}
    void SetMessageAllocatorFor_SendMessageById(
        ::grpc::MessageAllocator< ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendMessageById(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response) { return this->SendMessageToRandomPeers(context, request, response); }));}
    void SetMessageAllocatorFor_SendMessageToRandomPeers(
        ::grpc::MessageAllocator< ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendMessageToRandomPeers(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::OutboundMessageData, ::sentry::SentPeers>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response) { return this->SendMessageToAll(context, request, response); }));}
    void SetMessageAllocatorFor_SendMessageToAll(
        ::grpc::MessageAllocator< ::sentry::OutboundMessageData, ::sentry::SentPeers>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::OutboundMessageData, ::sentry::SentPeers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendMessageToAll(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Messages() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::sentry::MessagesRequest, ::sentry::InboundMessage>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::MessagesRequest* request) { return this->Messages(context, request); }));
    }
    ~WithCallbackMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::sentry::InboundMessage>* Messages(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Peers() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sentry::PeersReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::sentry::PeersReply* response) { return this->Peers(context, request, response); }));}
    void SetMessageAllocatorFor_Peers(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::sentry::PeersReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sentry::PeersReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Peers(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::PeersReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PeerCount() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::PeerCountRequest, ::sentry::PeerCountReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response) { return this->PeerCount(context, request, response); }));}
    void SetMessageAllocatorFor_PeerCount(
        ::grpc::MessageAllocator< ::sentry::PeerCountRequest, ::sentry::PeerCountReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::PeerCountRequest, ::sentry::PeerCountReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PeerCount(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PeerById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PeerById() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::PeerByIdRequest, ::sentry::PeerByIdReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::PeerByIdRequest* request, ::sentry::PeerByIdReply* response) { return this->PeerById(context, request, response); }));}
    void SetMessageAllocatorFor_PeerById(
        ::grpc::MessageAllocator< ::sentry::PeerByIdRequest, ::sentry::PeerByIdReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::PeerByIdRequest, ::sentry::PeerByIdReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PeerById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerById(::grpc::ServerContext* /*context*/, const ::sentry::PeerByIdRequest* /*request*/, ::sentry::PeerByIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PeerById(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PeerByIdRequest* /*request*/, ::sentry::PeerByIdReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PeerEvents() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackServerStreamingHandler< ::sentry::PeerEventsRequest, ::sentry::PeerEvent>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::PeerEventsRequest* request) { return this->PeerEvents(context, request); }));
    }
    ~WithCallbackMethod_PeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerEvents(::grpc::ServerContext* /*context*/, const ::sentry::PeerEventsRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::sentry::PeerEvent>* PeerEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PeerEventsRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddPeer() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::sentry::AddPeerRequest, ::sentry::AddPeerReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentry::AddPeerRequest* request, ::sentry::AddPeerReply* response) { return this->AddPeer(context, request, response); }));}
    void SetMessageAllocatorFor_AddPeer(
        ::grpc::MessageAllocator< ::sentry::AddPeerRequest, ::sentry::AddPeerReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentry::AddPeerRequest, ::sentry::AddPeerReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::sentry::AddPeerRequest* /*request*/, ::sentry::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::AddPeerRequest* /*request*/, ::sentry::AddPeerReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_NodeInfo() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::types::NodeInfoReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response) { return this->NodeInfo(context, request, response); }));}
    void SetMessageAllocatorFor_NodeInfo(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::types::NodeInfoReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::types::NodeInfoReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NodeInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SetStatus<WithCallbackMethod_PenalizePeer<WithCallbackMethod_PeerMinBlock<WithCallbackMethod_HandShake<WithCallbackMethod_SendMessageByMinBlock<WithCallbackMethod_SendMessageById<WithCallbackMethod_SendMessageToRandomPeers<WithCallbackMethod_SendMessageToAll<WithCallbackMethod_Messages<WithCallbackMethod_Peers<WithCallbackMethod_PeerCount<WithCallbackMethod_PeerById<WithCallbackMethod_PeerEvents<WithCallbackMethod_AddPeer<WithCallbackMethod_NodeInfo<Service > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetStatus() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HandShake() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMessageById() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Messages() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Peers() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PeerCount() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PeerById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PeerById() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_PeerById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerById(::grpc::ServerContext* /*context*/, const ::sentry::PeerByIdRequest* /*request*/, ::sentry::PeerByIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PeerEvents() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_PeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerEvents(::grpc::ServerContext* /*context*/, const ::sentry::PeerEventsRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddPeer() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::sentry::AddPeerRequest* /*request*/, ::sentry::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeInfo() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetStatus() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPenalizePeer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerMinBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HandShake() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandShake(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageByMinBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMessageById() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageById(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageToRandomPeers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageToAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Messages() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMessages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Peers() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PeerCount() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PeerById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PeerById() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_PeerById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerById(::grpc::ServerContext* /*context*/, const ::sentry::PeerByIdRequest* /*request*/, ::sentry::PeerByIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerById(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PeerEvents() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_PeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerEvents(::grpc::ServerContext* /*context*/, const ::sentry::PeerEventsRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(12, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddPeer() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::sentry::AddPeerRequest* /*request*/, ::sentry::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPeer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeInfo() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetStatus() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PenalizePeer(context, request, response); }));
    }
    ~WithRawCallbackMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PenalizePeer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PeerMinBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PeerMinBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HandShake() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HandShake(context, request, response); }));
    }
    ~WithRawCallbackMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HandShake(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMessageByMinBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendMessageByMinBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendMessageById() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMessageById(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendMessageById(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMessageToRandomPeers(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendMessageToRandomPeers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMessageToAll(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendMessageToAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Messages() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->Messages(context, request); }));
    }
    ~WithRawCallbackMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Messages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Peers() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Peers(context, request, response); }));
    }
    ~WithRawCallbackMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Peers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PeerCount() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PeerCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PeerCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PeerById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PeerById() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PeerById(context, request, response); }));
    }
    ~WithRawCallbackMethod_PeerById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerById(::grpc::ServerContext* /*context*/, const ::sentry::PeerByIdRequest* /*request*/, ::sentry::PeerByIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PeerById(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PeerEvents() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->PeerEvents(context, request); }));
    }
    ~WithRawCallbackMethod_PeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerEvents(::grpc::ServerContext* /*context*/, const ::sentry::PeerEventsRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* PeerEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddPeer() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddPeer(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::sentry::AddPeerRequest* /*request*/, ::sentry::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_NodeInfo() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NodeInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetStatus() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::StatusData, ::sentry::SetStatusReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::StatusData, ::sentry::SetStatusReply>* streamer) {
                       return this->StreamedSetStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::StatusData,::sentry::SetStatusReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedPenalizePeer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPenalizePeer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::PenalizePeerRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedPeerMinBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPeerMinBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::PeerMinBlockRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HandShake() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sentry::HandShakeReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sentry::HandShakeReply>* streamer) {
                       return this->StreamedHandShake(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHandShake(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sentry::HandShakeReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>* streamer) {
                       return this->StreamedSendMessageByMinBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMessageByMinBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::SendMessageByMinBlockRequest,::sentry::SentPeers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMessageById() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>* streamer) {
                       return this->StreamedSendMessageById(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMessageById(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::SendMessageByIdRequest,::sentry::SentPeers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>* streamer) {
                       return this->StreamedSendMessageToRandomPeers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMessageToRandomPeers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::SendMessageToRandomPeersRequest,::sentry::SentPeers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::OutboundMessageData, ::sentry::SentPeers>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::OutboundMessageData, ::sentry::SentPeers>* streamer) {
                       return this->StreamedSendMessageToAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMessageToAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::OutboundMessageData,::sentry::SentPeers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Peers() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sentry::PeersReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sentry::PeersReply>* streamer) {
                       return this->StreamedPeers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::PeersReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPeers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sentry::PeersReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PeerCount() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::PeerCountRequest, ::sentry::PeerCountReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::PeerCountRequest, ::sentry::PeerCountReply>* streamer) {
                       return this->StreamedPeerCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPeerCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::PeerCountRequest,::sentry::PeerCountReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PeerById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PeerById() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::PeerByIdRequest, ::sentry::PeerByIdReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::PeerByIdRequest, ::sentry::PeerByIdReply>* streamer) {
                       return this->StreamedPeerById(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PeerById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PeerById(::grpc::ServerContext* /*context*/, const ::sentry::PeerByIdRequest* /*request*/, ::sentry::PeerByIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPeerById(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::PeerByIdRequest,::sentry::PeerByIdReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddPeer() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::AddPeerRequest, ::sentry::AddPeerReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentry::AddPeerRequest, ::sentry::AddPeerReply>* streamer) {
                       return this->StreamedAddPeer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddPeer(::grpc::ServerContext* /*context*/, const ::sentry::AddPeerRequest* /*request*/, ::sentry::AddPeerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddPeer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::AddPeerRequest,::sentry::AddPeerReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeInfo() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::types::NodeInfoReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::types::NodeInfoReply>* streamer) {
                       return this->StreamedNodeInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::types::NodeInfoReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetStatus<WithStreamedUnaryMethod_PenalizePeer<WithStreamedUnaryMethod_PeerMinBlock<WithStreamedUnaryMethod_HandShake<WithStreamedUnaryMethod_SendMessageByMinBlock<WithStreamedUnaryMethod_SendMessageById<WithStreamedUnaryMethod_SendMessageToRandomPeers<WithStreamedUnaryMethod_SendMessageToAll<WithStreamedUnaryMethod_Peers<WithStreamedUnaryMethod_PeerCount<WithStreamedUnaryMethod_PeerById<WithStreamedUnaryMethod_AddPeer<WithStreamedUnaryMethod_NodeInfo<Service > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Messages() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::sentry::MessagesRequest, ::sentry::InboundMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::sentry::MessagesRequest, ::sentry::InboundMessage>* streamer) {
                       return this->StreamedMessages(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedMessages(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::sentry::MessagesRequest,::sentry::InboundMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_PeerEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_PeerEvents() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::sentry::PeerEventsRequest, ::sentry::PeerEvent>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::sentry::PeerEventsRequest, ::sentry::PeerEvent>* streamer) {
                       return this->StreamedPeerEvents(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_PeerEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PeerEvents(::grpc::ServerContext* /*context*/, const ::sentry::PeerEventsRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeerEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedPeerEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::sentry::PeerEventsRequest,::sentry::PeerEvent>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Messages<WithSplitStreamingMethod_PeerEvents<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetStatus<WithStreamedUnaryMethod_PenalizePeer<WithStreamedUnaryMethod_PeerMinBlock<WithStreamedUnaryMethod_HandShake<WithStreamedUnaryMethod_SendMessageByMinBlock<WithStreamedUnaryMethod_SendMessageById<WithStreamedUnaryMethod_SendMessageToRandomPeers<WithStreamedUnaryMethod_SendMessageToAll<WithSplitStreamingMethod_Messages<WithStreamedUnaryMethod_Peers<WithStreamedUnaryMethod_PeerCount<WithStreamedUnaryMethod_PeerById<WithSplitStreamingMethod_PeerEvents<WithStreamedUnaryMethod_AddPeer<WithStreamedUnaryMethod_NodeInfo<Service > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace sentry


#endif  // GRPC_p2psentry_2fsentry_2eproto__INCLUDED
