// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: p2psentry/sentry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_p2psentry_2fsentry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_p2psentry_2fsentry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_p2psentry_2fsentry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_p2psentry_2fsentry_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_p2psentry_2fsentry_2eproto;
namespace sentry {
class AddPeerReply;
struct AddPeerReplyDefaultTypeInternal;
extern AddPeerReplyDefaultTypeInternal _AddPeerReply_default_instance_;
class AddPeerRequest;
struct AddPeerRequestDefaultTypeInternal;
extern AddPeerRequestDefaultTypeInternal _AddPeerRequest_default_instance_;
class Forks;
struct ForksDefaultTypeInternal;
extern ForksDefaultTypeInternal _Forks_default_instance_;
class HandShakeReply;
struct HandShakeReplyDefaultTypeInternal;
extern HandShakeReplyDefaultTypeInternal _HandShakeReply_default_instance_;
class InboundMessage;
struct InboundMessageDefaultTypeInternal;
extern InboundMessageDefaultTypeInternal _InboundMessage_default_instance_;
class MessagesRequest;
struct MessagesRequestDefaultTypeInternal;
extern MessagesRequestDefaultTypeInternal _MessagesRequest_default_instance_;
class OutboundMessageData;
struct OutboundMessageDataDefaultTypeInternal;
extern OutboundMessageDataDefaultTypeInternal _OutboundMessageData_default_instance_;
class PeerByIdReply;
struct PeerByIdReplyDefaultTypeInternal;
extern PeerByIdReplyDefaultTypeInternal _PeerByIdReply_default_instance_;
class PeerByIdRequest;
struct PeerByIdRequestDefaultTypeInternal;
extern PeerByIdRequestDefaultTypeInternal _PeerByIdRequest_default_instance_;
class PeerCountPerProtocol;
struct PeerCountPerProtocolDefaultTypeInternal;
extern PeerCountPerProtocolDefaultTypeInternal _PeerCountPerProtocol_default_instance_;
class PeerCountReply;
struct PeerCountReplyDefaultTypeInternal;
extern PeerCountReplyDefaultTypeInternal _PeerCountReply_default_instance_;
class PeerCountRequest;
struct PeerCountRequestDefaultTypeInternal;
extern PeerCountRequestDefaultTypeInternal _PeerCountRequest_default_instance_;
class PeerEvent;
struct PeerEventDefaultTypeInternal;
extern PeerEventDefaultTypeInternal _PeerEvent_default_instance_;
class PeerEventsRequest;
struct PeerEventsRequestDefaultTypeInternal;
extern PeerEventsRequestDefaultTypeInternal _PeerEventsRequest_default_instance_;
class PeerMinBlockRequest;
struct PeerMinBlockRequestDefaultTypeInternal;
extern PeerMinBlockRequestDefaultTypeInternal _PeerMinBlockRequest_default_instance_;
class PeersReply;
struct PeersReplyDefaultTypeInternal;
extern PeersReplyDefaultTypeInternal _PeersReply_default_instance_;
class PenalizePeerRequest;
struct PenalizePeerRequestDefaultTypeInternal;
extern PenalizePeerRequestDefaultTypeInternal _PenalizePeerRequest_default_instance_;
class SendMessageByIdRequest;
struct SendMessageByIdRequestDefaultTypeInternal;
extern SendMessageByIdRequestDefaultTypeInternal _SendMessageByIdRequest_default_instance_;
class SendMessageByMinBlockRequest;
struct SendMessageByMinBlockRequestDefaultTypeInternal;
extern SendMessageByMinBlockRequestDefaultTypeInternal _SendMessageByMinBlockRequest_default_instance_;
class SendMessageToRandomPeersRequest;
struct SendMessageToRandomPeersRequestDefaultTypeInternal;
extern SendMessageToRandomPeersRequestDefaultTypeInternal _SendMessageToRandomPeersRequest_default_instance_;
class SentPeers;
struct SentPeersDefaultTypeInternal;
extern SentPeersDefaultTypeInternal _SentPeers_default_instance_;
class SetStatusReply;
struct SetStatusReplyDefaultTypeInternal;
extern SetStatusReplyDefaultTypeInternal _SetStatusReply_default_instance_;
class StatusData;
struct StatusDataDefaultTypeInternal;
extern StatusDataDefaultTypeInternal _StatusData_default_instance_;
}  // namespace sentry
PROTOBUF_NAMESPACE_OPEN
template<> ::sentry::AddPeerReply* Arena::CreateMaybeMessage<::sentry::AddPeerReply>(Arena*);
template<> ::sentry::AddPeerRequest* Arena::CreateMaybeMessage<::sentry::AddPeerRequest>(Arena*);
template<> ::sentry::Forks* Arena::CreateMaybeMessage<::sentry::Forks>(Arena*);
template<> ::sentry::HandShakeReply* Arena::CreateMaybeMessage<::sentry::HandShakeReply>(Arena*);
template<> ::sentry::InboundMessage* Arena::CreateMaybeMessage<::sentry::InboundMessage>(Arena*);
template<> ::sentry::MessagesRequest* Arena::CreateMaybeMessage<::sentry::MessagesRequest>(Arena*);
template<> ::sentry::OutboundMessageData* Arena::CreateMaybeMessage<::sentry::OutboundMessageData>(Arena*);
template<> ::sentry::PeerByIdReply* Arena::CreateMaybeMessage<::sentry::PeerByIdReply>(Arena*);
template<> ::sentry::PeerByIdRequest* Arena::CreateMaybeMessage<::sentry::PeerByIdRequest>(Arena*);
template<> ::sentry::PeerCountPerProtocol* Arena::CreateMaybeMessage<::sentry::PeerCountPerProtocol>(Arena*);
template<> ::sentry::PeerCountReply* Arena::CreateMaybeMessage<::sentry::PeerCountReply>(Arena*);
template<> ::sentry::PeerCountRequest* Arena::CreateMaybeMessage<::sentry::PeerCountRequest>(Arena*);
template<> ::sentry::PeerEvent* Arena::CreateMaybeMessage<::sentry::PeerEvent>(Arena*);
template<> ::sentry::PeerEventsRequest* Arena::CreateMaybeMessage<::sentry::PeerEventsRequest>(Arena*);
template<> ::sentry::PeerMinBlockRequest* Arena::CreateMaybeMessage<::sentry::PeerMinBlockRequest>(Arena*);
template<> ::sentry::PeersReply* Arena::CreateMaybeMessage<::sentry::PeersReply>(Arena*);
template<> ::sentry::PenalizePeerRequest* Arena::CreateMaybeMessage<::sentry::PenalizePeerRequest>(Arena*);
template<> ::sentry::SendMessageByIdRequest* Arena::CreateMaybeMessage<::sentry::SendMessageByIdRequest>(Arena*);
template<> ::sentry::SendMessageByMinBlockRequest* Arena::CreateMaybeMessage<::sentry::SendMessageByMinBlockRequest>(Arena*);
template<> ::sentry::SendMessageToRandomPeersRequest* Arena::CreateMaybeMessage<::sentry::SendMessageToRandomPeersRequest>(Arena*);
template<> ::sentry::SentPeers* Arena::CreateMaybeMessage<::sentry::SentPeers>(Arena*);
template<> ::sentry::SetStatusReply* Arena::CreateMaybeMessage<::sentry::SetStatusReply>(Arena*);
template<> ::sentry::StatusData* Arena::CreateMaybeMessage<::sentry::StatusData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sentry {

enum PeerEvent_PeerEventId : int {
  PeerEvent_PeerEventId_Connect = 0,
  PeerEvent_PeerEventId_Disconnect = 1,
  PeerEvent_PeerEventId_PeerEvent_PeerEventId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PeerEvent_PeerEventId_PeerEvent_PeerEventId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PeerEvent_PeerEventId_IsValid(int value);
constexpr PeerEvent_PeerEventId PeerEvent_PeerEventId_PeerEventId_MIN = PeerEvent_PeerEventId_Connect;
constexpr PeerEvent_PeerEventId PeerEvent_PeerEventId_PeerEventId_MAX = PeerEvent_PeerEventId_Disconnect;
constexpr int PeerEvent_PeerEventId_PeerEventId_ARRAYSIZE = PeerEvent_PeerEventId_PeerEventId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeerEvent_PeerEventId_descriptor();
template<typename T>
inline const std::string& PeerEvent_PeerEventId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeerEvent_PeerEventId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeerEvent_PeerEventId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PeerEvent_PeerEventId_descriptor(), enum_t_value);
}
inline bool PeerEvent_PeerEventId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeerEvent_PeerEventId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PeerEvent_PeerEventId>(
    PeerEvent_PeerEventId_descriptor(), name, value);
}
enum MessageId : int {
  STATUS_65 = 0,
  GET_BLOCK_HEADERS_65 = 1,
  BLOCK_HEADERS_65 = 2,
  BLOCK_HASHES_65 = 3,
  GET_BLOCK_BODIES_65 = 4,
  BLOCK_BODIES_65 = 5,
  GET_NODE_DATA_65 = 6,
  NODE_DATA_65 = 7,
  GET_RECEIPTS_65 = 8,
  RECEIPTS_65 = 9,
  NEW_BLOCK_HASHES_65 = 10,
  NEW_BLOCK_65 = 11,
  TRANSACTIONS_65 = 12,
  NEW_POOLED_TRANSACTION_HASHES_65 = 13,
  GET_POOLED_TRANSACTIONS_65 = 14,
  POOLED_TRANSACTIONS_65 = 15,
  STATUS_66 = 17,
  NEW_BLOCK_HASHES_66 = 18,
  NEW_BLOCK_66 = 19,
  TRANSACTIONS_66 = 20,
  NEW_POOLED_TRANSACTION_HASHES_66 = 21,
  GET_BLOCK_HEADERS_66 = 22,
  GET_BLOCK_BODIES_66 = 23,
  GET_NODE_DATA_66 = 24,
  GET_RECEIPTS_66 = 25,
  GET_POOLED_TRANSACTIONS_66 = 26,
  BLOCK_HEADERS_66 = 27,
  BLOCK_BODIES_66 = 28,
  NODE_DATA_66 = 29,
  RECEIPTS_66 = 30,
  POOLED_TRANSACTIONS_66 = 31,
  NEW_POOLED_TRANSACTION_HASHES_68 = 32,
  MessageId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageId_IsValid(int value);
constexpr MessageId MessageId_MIN = STATUS_65;
constexpr MessageId MessageId_MAX = NEW_POOLED_TRANSACTION_HASHES_68;
constexpr int MessageId_ARRAYSIZE = MessageId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageId_descriptor();
template<typename T>
inline const std::string& MessageId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageId_descriptor(), enum_t_value);
}
inline bool MessageId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageId>(
    MessageId_descriptor(), name, value);
}
enum PenaltyKind : int {
  Kick = 0,
  PenaltyKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PenaltyKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PenaltyKind_IsValid(int value);
constexpr PenaltyKind PenaltyKind_MIN = Kick;
constexpr PenaltyKind PenaltyKind_MAX = Kick;
constexpr int PenaltyKind_ARRAYSIZE = PenaltyKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PenaltyKind_descriptor();
template<typename T>
inline const std::string& PenaltyKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PenaltyKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PenaltyKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PenaltyKind_descriptor(), enum_t_value);
}
inline bool PenaltyKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PenaltyKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PenaltyKind>(
    PenaltyKind_descriptor(), name, value);
}
enum Protocol : int {
  ETH65 = 0,
  ETH66 = 1,
  ETH67 = 2,
  ETH68 = 3,
  Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Protocol_IsValid(int value);
constexpr Protocol Protocol_MIN = ETH65;
constexpr Protocol Protocol_MAX = ETH68;
constexpr int Protocol_ARRAYSIZE = Protocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Protocol_descriptor();
template<typename T>
inline const std::string& Protocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Protocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Protocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Protocol_descriptor(), enum_t_value);
}
inline bool Protocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Protocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Protocol>(
    Protocol_descriptor(), name, value);
}
// ===================================================================

class OutboundMessageData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.OutboundMessageData) */ {
 public:
  inline OutboundMessageData() : OutboundMessageData(nullptr) {}
  ~OutboundMessageData() override;
  explicit PROTOBUF_CONSTEXPR OutboundMessageData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutboundMessageData(const OutboundMessageData& from);
  OutboundMessageData(OutboundMessageData&& from) noexcept
    : OutboundMessageData() {
    *this = ::std::move(from);
  }

  inline OutboundMessageData& operator=(const OutboundMessageData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutboundMessageData& operator=(OutboundMessageData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutboundMessageData& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutboundMessageData* internal_default_instance() {
    return reinterpret_cast<const OutboundMessageData*>(
               &_OutboundMessageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OutboundMessageData& a, OutboundMessageData& b) {
    a.Swap(&b);
  }
  inline void Swap(OutboundMessageData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutboundMessageData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutboundMessageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutboundMessageData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutboundMessageData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OutboundMessageData& from) {
    OutboundMessageData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutboundMessageData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.OutboundMessageData";
  }
  protected:
  explicit OutboundMessageData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .sentry.MessageId id = 1;
  void clear_id();
  ::sentry::MessageId id() const;
  void set_id(::sentry::MessageId value);
  private:
  ::sentry::MessageId _internal_id() const;
  void _internal_set_id(::sentry::MessageId value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.OutboundMessageData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SendMessageByMinBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SendMessageByMinBlockRequest) */ {
 public:
  inline SendMessageByMinBlockRequest() : SendMessageByMinBlockRequest(nullptr) {}
  ~SendMessageByMinBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR SendMessageByMinBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageByMinBlockRequest(const SendMessageByMinBlockRequest& from);
  SendMessageByMinBlockRequest(SendMessageByMinBlockRequest&& from) noexcept
    : SendMessageByMinBlockRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageByMinBlockRequest& operator=(const SendMessageByMinBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageByMinBlockRequest& operator=(SendMessageByMinBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageByMinBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageByMinBlockRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageByMinBlockRequest*>(
               &_SendMessageByMinBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SendMessageByMinBlockRequest& a, SendMessageByMinBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageByMinBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageByMinBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageByMinBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageByMinBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageByMinBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageByMinBlockRequest& from) {
    SendMessageByMinBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageByMinBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SendMessageByMinBlockRequest";
  }
  protected:
  explicit SendMessageByMinBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kMinBlockFieldNumber = 2,
    kMaxPeersFieldNumber = 3,
  };
  // .sentry.OutboundMessageData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::sentry::OutboundMessageData& data() const;
  PROTOBUF_NODISCARD ::sentry::OutboundMessageData* release_data();
  ::sentry::OutboundMessageData* mutable_data();
  void set_allocated_data(::sentry::OutboundMessageData* data);
  private:
  const ::sentry::OutboundMessageData& _internal_data() const;
  ::sentry::OutboundMessageData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::sentry::OutboundMessageData* data);
  ::sentry::OutboundMessageData* unsafe_arena_release_data();

  // uint64 min_block = 2;
  void clear_min_block();
  uint64_t min_block() const;
  void set_min_block(uint64_t value);
  private:
  uint64_t _internal_min_block() const;
  void _internal_set_min_block(uint64_t value);
  public:

  // uint64 max_peers = 3;
  void clear_max_peers();
  uint64_t max_peers() const;
  void set_max_peers(uint64_t value);
  private:
  uint64_t _internal_max_peers() const;
  void _internal_set_max_peers(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.SendMessageByMinBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentry::OutboundMessageData* data_;
    uint64_t min_block_;
    uint64_t max_peers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SendMessageByIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SendMessageByIdRequest) */ {
 public:
  inline SendMessageByIdRequest() : SendMessageByIdRequest(nullptr) {}
  ~SendMessageByIdRequest() override;
  explicit PROTOBUF_CONSTEXPR SendMessageByIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageByIdRequest(const SendMessageByIdRequest& from);
  SendMessageByIdRequest(SendMessageByIdRequest&& from) noexcept
    : SendMessageByIdRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageByIdRequest& operator=(const SendMessageByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageByIdRequest& operator=(SendMessageByIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageByIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageByIdRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageByIdRequest*>(
               &_SendMessageByIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SendMessageByIdRequest& a, SendMessageByIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageByIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageByIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageByIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageByIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageByIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageByIdRequest& from) {
    SendMessageByIdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageByIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SendMessageByIdRequest";
  }
  protected:
  explicit SendMessageByIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kPeerIdFieldNumber = 2,
  };
  // .sentry.OutboundMessageData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::sentry::OutboundMessageData& data() const;
  PROTOBUF_NODISCARD ::sentry::OutboundMessageData* release_data();
  ::sentry::OutboundMessageData* mutable_data();
  void set_allocated_data(::sentry::OutboundMessageData* data);
  private:
  const ::sentry::OutboundMessageData& _internal_data() const;
  ::sentry::OutboundMessageData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::sentry::OutboundMessageData* data);
  ::sentry::OutboundMessageData* unsafe_arena_release_data();

  // .types.H512 peer_id = 2;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  PROTOBUF_NODISCARD ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // @@protoc_insertion_point(class_scope:sentry.SendMessageByIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentry::OutboundMessageData* data_;
    ::types::H512* peer_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SendMessageToRandomPeersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SendMessageToRandomPeersRequest) */ {
 public:
  inline SendMessageToRandomPeersRequest() : SendMessageToRandomPeersRequest(nullptr) {}
  ~SendMessageToRandomPeersRequest() override;
  explicit PROTOBUF_CONSTEXPR SendMessageToRandomPeersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageToRandomPeersRequest(const SendMessageToRandomPeersRequest& from);
  SendMessageToRandomPeersRequest(SendMessageToRandomPeersRequest&& from) noexcept
    : SendMessageToRandomPeersRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageToRandomPeersRequest& operator=(const SendMessageToRandomPeersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageToRandomPeersRequest& operator=(SendMessageToRandomPeersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageToRandomPeersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageToRandomPeersRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageToRandomPeersRequest*>(
               &_SendMessageToRandomPeersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SendMessageToRandomPeersRequest& a, SendMessageToRandomPeersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageToRandomPeersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageToRandomPeersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageToRandomPeersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageToRandomPeersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageToRandomPeersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageToRandomPeersRequest& from) {
    SendMessageToRandomPeersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageToRandomPeersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SendMessageToRandomPeersRequest";
  }
  protected:
  explicit SendMessageToRandomPeersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kMaxPeersFieldNumber = 2,
  };
  // .sentry.OutboundMessageData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::sentry::OutboundMessageData& data() const;
  PROTOBUF_NODISCARD ::sentry::OutboundMessageData* release_data();
  ::sentry::OutboundMessageData* mutable_data();
  void set_allocated_data(::sentry::OutboundMessageData* data);
  private:
  const ::sentry::OutboundMessageData& _internal_data() const;
  ::sentry::OutboundMessageData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::sentry::OutboundMessageData* data);
  ::sentry::OutboundMessageData* unsafe_arena_release_data();

  // uint64 max_peers = 2;
  void clear_max_peers();
  uint64_t max_peers() const;
  void set_max_peers(uint64_t value);
  private:
  uint64_t _internal_max_peers() const;
  void _internal_set_max_peers(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.SendMessageToRandomPeersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentry::OutboundMessageData* data_;
    uint64_t max_peers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SentPeers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SentPeers) */ {
 public:
  inline SentPeers() : SentPeers(nullptr) {}
  ~SentPeers() override;
  explicit PROTOBUF_CONSTEXPR SentPeers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SentPeers(const SentPeers& from);
  SentPeers(SentPeers&& from) noexcept
    : SentPeers() {
    *this = ::std::move(from);
  }

  inline SentPeers& operator=(const SentPeers& from) {
    CopyFrom(from);
    return *this;
  }
  inline SentPeers& operator=(SentPeers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SentPeers& default_instance() {
    return *internal_default_instance();
  }
  static inline const SentPeers* internal_default_instance() {
    return reinterpret_cast<const SentPeers*>(
               &_SentPeers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SentPeers& a, SentPeers& b) {
    a.Swap(&b);
  }
  inline void Swap(SentPeers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SentPeers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SentPeers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SentPeers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SentPeers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SentPeers& from) {
    SentPeers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SentPeers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SentPeers";
  }
  protected:
  explicit SentPeers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
  };
  // repeated .types.H512 peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::types::H512* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 >*
      mutable_peers();
  private:
  const ::types::H512& _internal_peers(int index) const;
  ::types::H512* _internal_add_peers();
  public:
  const ::types::H512& peers(int index) const;
  ::types::H512* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 >&
      peers() const;

  // @@protoc_insertion_point(class_scope:sentry.SentPeers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 > peers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PenalizePeerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PenalizePeerRequest) */ {
 public:
  inline PenalizePeerRequest() : PenalizePeerRequest(nullptr) {}
  ~PenalizePeerRequest() override;
  explicit PROTOBUF_CONSTEXPR PenalizePeerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PenalizePeerRequest(const PenalizePeerRequest& from);
  PenalizePeerRequest(PenalizePeerRequest&& from) noexcept
    : PenalizePeerRequest() {
    *this = ::std::move(from);
  }

  inline PenalizePeerRequest& operator=(const PenalizePeerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PenalizePeerRequest& operator=(PenalizePeerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PenalizePeerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PenalizePeerRequest* internal_default_instance() {
    return reinterpret_cast<const PenalizePeerRequest*>(
               &_PenalizePeerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PenalizePeerRequest& a, PenalizePeerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PenalizePeerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PenalizePeerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PenalizePeerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PenalizePeerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PenalizePeerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PenalizePeerRequest& from) {
    PenalizePeerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PenalizePeerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PenalizePeerRequest";
  }
  protected:
  explicit PenalizePeerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kPenaltyFieldNumber = 2,
  };
  // .types.H512 peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  PROTOBUF_NODISCARD ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // .sentry.PenaltyKind penalty = 2;
  void clear_penalty();
  ::sentry::PenaltyKind penalty() const;
  void set_penalty(::sentry::PenaltyKind value);
  private:
  ::sentry::PenaltyKind _internal_penalty() const;
  void _internal_set_penalty(::sentry::PenaltyKind value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PenalizePeerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H512* peer_id_;
    int penalty_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerMinBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerMinBlockRequest) */ {
 public:
  inline PeerMinBlockRequest() : PeerMinBlockRequest(nullptr) {}
  ~PeerMinBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR PeerMinBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerMinBlockRequest(const PeerMinBlockRequest& from);
  PeerMinBlockRequest(PeerMinBlockRequest&& from) noexcept
    : PeerMinBlockRequest() {
    *this = ::std::move(from);
  }

  inline PeerMinBlockRequest& operator=(const PeerMinBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerMinBlockRequest& operator=(PeerMinBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerMinBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerMinBlockRequest* internal_default_instance() {
    return reinterpret_cast<const PeerMinBlockRequest*>(
               &_PeerMinBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PeerMinBlockRequest& a, PeerMinBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerMinBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerMinBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerMinBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerMinBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerMinBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerMinBlockRequest& from) {
    PeerMinBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerMinBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerMinBlockRequest";
  }
  protected:
  explicit PeerMinBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kMinBlockFieldNumber = 2,
  };
  // .types.H512 peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  PROTOBUF_NODISCARD ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // uint64 min_block = 2;
  void clear_min_block();
  uint64_t min_block() const;
  void set_min_block(uint64_t value);
  private:
  uint64_t _internal_min_block() const;
  void _internal_set_min_block(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PeerMinBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H512* peer_id_;
    uint64_t min_block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class AddPeerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.AddPeerRequest) */ {
 public:
  inline AddPeerRequest() : AddPeerRequest(nullptr) {}
  ~AddPeerRequest() override;
  explicit PROTOBUF_CONSTEXPR AddPeerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPeerRequest(const AddPeerRequest& from);
  AddPeerRequest(AddPeerRequest&& from) noexcept
    : AddPeerRequest() {
    *this = ::std::move(from);
  }

  inline AddPeerRequest& operator=(const AddPeerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPeerRequest& operator=(AddPeerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPeerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPeerRequest* internal_default_instance() {
    return reinterpret_cast<const AddPeerRequest*>(
               &_AddPeerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AddPeerRequest& a, AddPeerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPeerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPeerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPeerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPeerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPeerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddPeerRequest& from) {
    AddPeerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPeerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.AddPeerRequest";
  }
  protected:
  explicit AddPeerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:sentry.AddPeerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class InboundMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.InboundMessage) */ {
 public:
  inline InboundMessage() : InboundMessage(nullptr) {}
  ~InboundMessage() override;
  explicit PROTOBUF_CONSTEXPR InboundMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InboundMessage(const InboundMessage& from);
  InboundMessage(InboundMessage&& from) noexcept
    : InboundMessage() {
    *this = ::std::move(from);
  }

  inline InboundMessage& operator=(const InboundMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InboundMessage& operator=(InboundMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InboundMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InboundMessage* internal_default_instance() {
    return reinterpret_cast<const InboundMessage*>(
               &_InboundMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InboundMessage& a, InboundMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InboundMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InboundMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InboundMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InboundMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InboundMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InboundMessage& from) {
    InboundMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InboundMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.InboundMessage";
  }
  protected:
  explicit InboundMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPeerIdFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .types.H512 peer_id = 3;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  PROTOBUF_NODISCARD ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // .sentry.MessageId id = 1;
  void clear_id();
  ::sentry::MessageId id() const;
  void set_id(::sentry::MessageId value);
  private:
  ::sentry::MessageId _internal_id() const;
  void _internal_set_id(::sentry::MessageId value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.InboundMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::types::H512* peer_id_;
    int id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class Forks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.Forks) */ {
 public:
  inline Forks() : Forks(nullptr) {}
  ~Forks() override;
  explicit PROTOBUF_CONSTEXPR Forks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Forks(const Forks& from);
  Forks(Forks&& from) noexcept
    : Forks() {
    *this = ::std::move(from);
  }

  inline Forks& operator=(const Forks& from) {
    CopyFrom(from);
    return *this;
  }
  inline Forks& operator=(Forks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Forks& default_instance() {
    return *internal_default_instance();
  }
  static inline const Forks* internal_default_instance() {
    return reinterpret_cast<const Forks*>(
               &_Forks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Forks& a, Forks& b) {
    a.Swap(&b);
  }
  inline void Swap(Forks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Forks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Forks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Forks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Forks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Forks& from) {
    Forks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Forks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.Forks";
  }
  protected:
  explicit Forks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightForksFieldNumber = 2,
    kTimeForksFieldNumber = 3,
    kGenesisFieldNumber = 1,
  };
  // repeated uint64 height_forks = 2;
  int height_forks_size() const;
  private:
  int _internal_height_forks_size() const;
  public:
  void clear_height_forks();
  private:
  uint64_t _internal_height_forks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_height_forks() const;
  void _internal_add_height_forks(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_height_forks();
  public:
  uint64_t height_forks(int index) const;
  void set_height_forks(int index, uint64_t value);
  void add_height_forks(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      height_forks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_height_forks();

  // repeated uint64 time_forks = 3;
  int time_forks_size() const;
  private:
  int _internal_time_forks_size() const;
  public:
  void clear_time_forks();
  private:
  uint64_t _internal_time_forks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_time_forks() const;
  void _internal_add_time_forks(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_time_forks();
  public:
  uint64_t time_forks(int index) const;
  void set_time_forks(int index, uint64_t value);
  void add_time_forks(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      time_forks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_time_forks();

  // .types.H256 genesis = 1;
  bool has_genesis() const;
  private:
  bool _internal_has_genesis() const;
  public:
  void clear_genesis();
  const ::types::H256& genesis() const;
  PROTOBUF_NODISCARD ::types::H256* release_genesis();
  ::types::H256* mutable_genesis();
  void set_allocated_genesis(::types::H256* genesis);
  private:
  const ::types::H256& _internal_genesis() const;
  ::types::H256* _internal_mutable_genesis();
  public:
  void unsafe_arena_set_allocated_genesis(
      ::types::H256* genesis);
  ::types::H256* unsafe_arena_release_genesis();

  // @@protoc_insertion_point(class_scope:sentry.Forks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > height_forks_;
    mutable std::atomic<int> _height_forks_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > time_forks_;
    mutable std::atomic<int> _time_forks_cached_byte_size_;
    ::types::H256* genesis_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class StatusData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.StatusData) */ {
 public:
  inline StatusData() : StatusData(nullptr) {}
  ~StatusData() override;
  explicit PROTOBUF_CONSTEXPR StatusData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusData(const StatusData& from);
  StatusData(StatusData&& from) noexcept
    : StatusData() {
    *this = ::std::move(from);
  }

  inline StatusData& operator=(const StatusData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusData& operator=(StatusData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusData* internal_default_instance() {
    return reinterpret_cast<const StatusData*>(
               &_StatusData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StatusData& a, StatusData& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusData& from) {
    StatusData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.StatusData";
  }
  protected:
  explicit StatusData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalDifficultyFieldNumber = 2,
    kBestHashFieldNumber = 3,
    kForkDataFieldNumber = 4,
    kNetworkIdFieldNumber = 1,
    kMaxBlockHeightFieldNumber = 5,
    kMaxBlockTimeFieldNumber = 6,
  };
  // .types.H256 total_difficulty = 2;
  bool has_total_difficulty() const;
  private:
  bool _internal_has_total_difficulty() const;
  public:
  void clear_total_difficulty();
  const ::types::H256& total_difficulty() const;
  PROTOBUF_NODISCARD ::types::H256* release_total_difficulty();
  ::types::H256* mutable_total_difficulty();
  void set_allocated_total_difficulty(::types::H256* total_difficulty);
  private:
  const ::types::H256& _internal_total_difficulty() const;
  ::types::H256* _internal_mutable_total_difficulty();
  public:
  void unsafe_arena_set_allocated_total_difficulty(
      ::types::H256* total_difficulty);
  ::types::H256* unsafe_arena_release_total_difficulty();

  // .types.H256 best_hash = 3;
  bool has_best_hash() const;
  private:
  bool _internal_has_best_hash() const;
  public:
  void clear_best_hash();
  const ::types::H256& best_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_best_hash();
  ::types::H256* mutable_best_hash();
  void set_allocated_best_hash(::types::H256* best_hash);
  private:
  const ::types::H256& _internal_best_hash() const;
  ::types::H256* _internal_mutable_best_hash();
  public:
  void unsafe_arena_set_allocated_best_hash(
      ::types::H256* best_hash);
  ::types::H256* unsafe_arena_release_best_hash();

  // .sentry.Forks fork_data = 4;
  bool has_fork_data() const;
  private:
  bool _internal_has_fork_data() const;
  public:
  void clear_fork_data();
  const ::sentry::Forks& fork_data() const;
  PROTOBUF_NODISCARD ::sentry::Forks* release_fork_data();
  ::sentry::Forks* mutable_fork_data();
  void set_allocated_fork_data(::sentry::Forks* fork_data);
  private:
  const ::sentry::Forks& _internal_fork_data() const;
  ::sentry::Forks* _internal_mutable_fork_data();
  public:
  void unsafe_arena_set_allocated_fork_data(
      ::sentry::Forks* fork_data);
  ::sentry::Forks* unsafe_arena_release_fork_data();

  // uint64 network_id = 1;
  void clear_network_id();
  uint64_t network_id() const;
  void set_network_id(uint64_t value);
  private:
  uint64_t _internal_network_id() const;
  void _internal_set_network_id(uint64_t value);
  public:

  // uint64 max_block_height = 5;
  void clear_max_block_height();
  uint64_t max_block_height() const;
  void set_max_block_height(uint64_t value);
  private:
  uint64_t _internal_max_block_height() const;
  void _internal_set_max_block_height(uint64_t value);
  public:

  // uint64 max_block_time = 6;
  void clear_max_block_time();
  uint64_t max_block_time() const;
  void set_max_block_time(uint64_t value);
  private:
  uint64_t _internal_max_block_time() const;
  void _internal_set_max_block_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.StatusData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H256* total_difficulty_;
    ::types::H256* best_hash_;
    ::sentry::Forks* fork_data_;
    uint64_t network_id_;
    uint64_t max_block_height_;
    uint64_t max_block_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SetStatusReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:sentry.SetStatusReply) */ {
 public:
  inline SetStatusReply() : SetStatusReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetStatusReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetStatusReply(const SetStatusReply& from);
  SetStatusReply(SetStatusReply&& from) noexcept
    : SetStatusReply() {
    *this = ::std::move(from);
  }

  inline SetStatusReply& operator=(const SetStatusReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetStatusReply& operator=(SetStatusReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetStatusReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetStatusReply* internal_default_instance() {
    return reinterpret_cast<const SetStatusReply*>(
               &_SetStatusReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetStatusReply& a, SetStatusReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetStatusReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetStatusReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetStatusReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetStatusReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetStatusReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetStatusReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SetStatusReply";
  }
  protected:
  explicit SetStatusReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sentry.SetStatusReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class HandShakeReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.HandShakeReply) */ {
 public:
  inline HandShakeReply() : HandShakeReply(nullptr) {}
  ~HandShakeReply() override;
  explicit PROTOBUF_CONSTEXPR HandShakeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandShakeReply(const HandShakeReply& from);
  HandShakeReply(HandShakeReply&& from) noexcept
    : HandShakeReply() {
    *this = ::std::move(from);
  }

  inline HandShakeReply& operator=(const HandShakeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandShakeReply& operator=(HandShakeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandShakeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandShakeReply* internal_default_instance() {
    return reinterpret_cast<const HandShakeReply*>(
               &_HandShakeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HandShakeReply& a, HandShakeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HandShakeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandShakeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandShakeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandShakeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandShakeReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandShakeReply& from) {
    HandShakeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandShakeReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.HandShakeReply";
  }
  protected:
  explicit HandShakeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolFieldNumber = 1,
  };
  // .sentry.Protocol protocol = 1;
  void clear_protocol();
  ::sentry::Protocol protocol() const;
  void set_protocol(::sentry::Protocol value);
  private:
  ::sentry::Protocol _internal_protocol() const;
  void _internal_set_protocol(::sentry::Protocol value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.HandShakeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int protocol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class MessagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.MessagesRequest) */ {
 public:
  inline MessagesRequest() : MessagesRequest(nullptr) {}
  ~MessagesRequest() override;
  explicit PROTOBUF_CONSTEXPR MessagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessagesRequest(const MessagesRequest& from);
  MessagesRequest(MessagesRequest&& from) noexcept
    : MessagesRequest() {
    *this = ::std::move(from);
  }

  inline MessagesRequest& operator=(const MessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagesRequest& operator=(MessagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessagesRequest* internal_default_instance() {
    return reinterpret_cast<const MessagesRequest*>(
               &_MessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MessagesRequest& a, MessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessagesRequest& from) {
    MessagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.MessagesRequest";
  }
  protected:
  explicit MessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated .sentry.MessageId ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  ::sentry::MessageId _internal_ids(int index) const;
  void _internal_add_ids(::sentry::MessageId value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_ids();
  public:
  ::sentry::MessageId ids(int index) const;
  void set_ids(int index, ::sentry::MessageId value);
  void add_ids(::sentry::MessageId value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ids();

  // @@protoc_insertion_point(class_scope:sentry.MessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ids_;
    mutable std::atomic<int> _ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeersReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeersReply) */ {
 public:
  inline PeersReply() : PeersReply(nullptr) {}
  ~PeersReply() override;
  explicit PROTOBUF_CONSTEXPR PeersReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeersReply(const PeersReply& from);
  PeersReply(PeersReply&& from) noexcept
    : PeersReply() {
    *this = ::std::move(from);
  }

  inline PeersReply& operator=(const PeersReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeersReply& operator=(PeersReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeersReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeersReply* internal_default_instance() {
    return reinterpret_cast<const PeersReply*>(
               &_PeersReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PeersReply& a, PeersReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PeersReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeersReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeersReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeersReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeersReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeersReply& from) {
    PeersReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeersReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeersReply";
  }
  protected:
  explicit PeersReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
  };
  // repeated .types.PeerInfo peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::types::PeerInfo* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo >*
      mutable_peers();
  private:
  const ::types::PeerInfo& _internal_peers(int index) const;
  ::types::PeerInfo* _internal_add_peers();
  public:
  const ::types::PeerInfo& peers(int index) const;
  ::types::PeerInfo* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo >&
      peers() const;

  // @@protoc_insertion_point(class_scope:sentry.PeersReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo > peers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerCountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:sentry.PeerCountRequest) */ {
 public:
  inline PeerCountRequest() : PeerCountRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PeerCountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerCountRequest(const PeerCountRequest& from);
  PeerCountRequest(PeerCountRequest&& from) noexcept
    : PeerCountRequest() {
    *this = ::std::move(from);
  }

  inline PeerCountRequest& operator=(const PeerCountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerCountRequest& operator=(PeerCountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerCountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerCountRequest* internal_default_instance() {
    return reinterpret_cast<const PeerCountRequest*>(
               &_PeerCountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PeerCountRequest& a, PeerCountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerCountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerCountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerCountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerCountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PeerCountRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PeerCountRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerCountRequest";
  }
  protected:
  explicit PeerCountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sentry.PeerCountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerCountPerProtocol final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerCountPerProtocol) */ {
 public:
  inline PeerCountPerProtocol() : PeerCountPerProtocol(nullptr) {}
  ~PeerCountPerProtocol() override;
  explicit PROTOBUF_CONSTEXPR PeerCountPerProtocol(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerCountPerProtocol(const PeerCountPerProtocol& from);
  PeerCountPerProtocol(PeerCountPerProtocol&& from) noexcept
    : PeerCountPerProtocol() {
    *this = ::std::move(from);
  }

  inline PeerCountPerProtocol& operator=(const PeerCountPerProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerCountPerProtocol& operator=(PeerCountPerProtocol&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerCountPerProtocol& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerCountPerProtocol* internal_default_instance() {
    return reinterpret_cast<const PeerCountPerProtocol*>(
               &_PeerCountPerProtocol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PeerCountPerProtocol& a, PeerCountPerProtocol& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerCountPerProtocol* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerCountPerProtocol* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerCountPerProtocol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerCountPerProtocol>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerCountPerProtocol& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerCountPerProtocol& from) {
    PeerCountPerProtocol::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerCountPerProtocol* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerCountPerProtocol";
  }
  protected:
  explicit PeerCountPerProtocol(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 2,
    kProtocolFieldNumber = 1,
  };
  // uint64 count = 2;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // .sentry.Protocol protocol = 1;
  void clear_protocol();
  ::sentry::Protocol protocol() const;
  void set_protocol(::sentry::Protocol value);
  private:
  ::sentry::Protocol _internal_protocol() const;
  void _internal_set_protocol(::sentry::Protocol value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PeerCountPerProtocol)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t count_;
    int protocol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerCountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerCountReply) */ {
 public:
  inline PeerCountReply() : PeerCountReply(nullptr) {}
  ~PeerCountReply() override;
  explicit PROTOBUF_CONSTEXPR PeerCountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerCountReply(const PeerCountReply& from);
  PeerCountReply(PeerCountReply&& from) noexcept
    : PeerCountReply() {
    *this = ::std::move(from);
  }

  inline PeerCountReply& operator=(const PeerCountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerCountReply& operator=(PeerCountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerCountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerCountReply* internal_default_instance() {
    return reinterpret_cast<const PeerCountReply*>(
               &_PeerCountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PeerCountReply& a, PeerCountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerCountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerCountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerCountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerCountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerCountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerCountReply& from) {
    PeerCountReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerCountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerCountReply";
  }
  protected:
  explicit PeerCountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountsPerProtocolFieldNumber = 2,
    kCountFieldNumber = 1,
  };
  // repeated .sentry.PeerCountPerProtocol counts_per_protocol = 2;
  int counts_per_protocol_size() const;
  private:
  int _internal_counts_per_protocol_size() const;
  public:
  void clear_counts_per_protocol();
  ::sentry::PeerCountPerProtocol* mutable_counts_per_protocol(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentry::PeerCountPerProtocol >*
      mutable_counts_per_protocol();
  private:
  const ::sentry::PeerCountPerProtocol& _internal_counts_per_protocol(int index) const;
  ::sentry::PeerCountPerProtocol* _internal_add_counts_per_protocol();
  public:
  const ::sentry::PeerCountPerProtocol& counts_per_protocol(int index) const;
  ::sentry::PeerCountPerProtocol* add_counts_per_protocol();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentry::PeerCountPerProtocol >&
      counts_per_protocol() const;

  // uint64 count = 1;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PeerCountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentry::PeerCountPerProtocol > counts_per_protocol_;
    uint64_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerByIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerByIdRequest) */ {
 public:
  inline PeerByIdRequest() : PeerByIdRequest(nullptr) {}
  ~PeerByIdRequest() override;
  explicit PROTOBUF_CONSTEXPR PeerByIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerByIdRequest(const PeerByIdRequest& from);
  PeerByIdRequest(PeerByIdRequest&& from) noexcept
    : PeerByIdRequest() {
    *this = ::std::move(from);
  }

  inline PeerByIdRequest& operator=(const PeerByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerByIdRequest& operator=(PeerByIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerByIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerByIdRequest* internal_default_instance() {
    return reinterpret_cast<const PeerByIdRequest*>(
               &_PeerByIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PeerByIdRequest& a, PeerByIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerByIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerByIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerByIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerByIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerByIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerByIdRequest& from) {
    PeerByIdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerByIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerByIdRequest";
  }
  protected:
  explicit PeerByIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
  };
  // .types.H512 peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  PROTOBUF_NODISCARD ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // @@protoc_insertion_point(class_scope:sentry.PeerByIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H512* peer_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerByIdReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerByIdReply) */ {
 public:
  inline PeerByIdReply() : PeerByIdReply(nullptr) {}
  ~PeerByIdReply() override;
  explicit PROTOBUF_CONSTEXPR PeerByIdReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerByIdReply(const PeerByIdReply& from);
  PeerByIdReply(PeerByIdReply&& from) noexcept
    : PeerByIdReply() {
    *this = ::std::move(from);
  }

  inline PeerByIdReply& operator=(const PeerByIdReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerByIdReply& operator=(PeerByIdReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerByIdReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerByIdReply* internal_default_instance() {
    return reinterpret_cast<const PeerByIdReply*>(
               &_PeerByIdReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PeerByIdReply& a, PeerByIdReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerByIdReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerByIdReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerByIdReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerByIdReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerByIdReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerByIdReply& from) {
    PeerByIdReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerByIdReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerByIdReply";
  }
  protected:
  explicit PeerByIdReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
  };
  // optional .types.PeerInfo peer = 1;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::types::PeerInfo& peer() const;
  PROTOBUF_NODISCARD ::types::PeerInfo* release_peer();
  ::types::PeerInfo* mutable_peer();
  void set_allocated_peer(::types::PeerInfo* peer);
  private:
  const ::types::PeerInfo& _internal_peer() const;
  ::types::PeerInfo* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::types::PeerInfo* peer);
  ::types::PeerInfo* unsafe_arena_release_peer();

  // @@protoc_insertion_point(class_scope:sentry.PeerByIdReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::types::PeerInfo* peer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:sentry.PeerEventsRequest) */ {
 public:
  inline PeerEventsRequest() : PeerEventsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PeerEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerEventsRequest(const PeerEventsRequest& from);
  PeerEventsRequest(PeerEventsRequest&& from) noexcept
    : PeerEventsRequest() {
    *this = ::std::move(from);
  }

  inline PeerEventsRequest& operator=(const PeerEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerEventsRequest& operator=(PeerEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerEventsRequest* internal_default_instance() {
    return reinterpret_cast<const PeerEventsRequest*>(
               &_PeerEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PeerEventsRequest& a, PeerEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PeerEventsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PeerEventsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerEventsRequest";
  }
  protected:
  explicit PeerEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sentry.PeerEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerEvent) */ {
 public:
  inline PeerEvent() : PeerEvent(nullptr) {}
  ~PeerEvent() override;
  explicit PROTOBUF_CONSTEXPR PeerEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerEvent(const PeerEvent& from);
  PeerEvent(PeerEvent&& from) noexcept
    : PeerEvent() {
    *this = ::std::move(from);
  }

  inline PeerEvent& operator=(const PeerEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerEvent& operator=(PeerEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerEvent* internal_default_instance() {
    return reinterpret_cast<const PeerEvent*>(
               &_PeerEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PeerEvent& a, PeerEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerEvent& from) {
    PeerEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerEvent";
  }
  protected:
  explicit PeerEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PeerEvent_PeerEventId PeerEventId;
  static constexpr PeerEventId Connect =
    PeerEvent_PeerEventId_Connect;
  static constexpr PeerEventId Disconnect =
    PeerEvent_PeerEventId_Disconnect;
  static inline bool PeerEventId_IsValid(int value) {
    return PeerEvent_PeerEventId_IsValid(value);
  }
  static constexpr PeerEventId PeerEventId_MIN =
    PeerEvent_PeerEventId_PeerEventId_MIN;
  static constexpr PeerEventId PeerEventId_MAX =
    PeerEvent_PeerEventId_PeerEventId_MAX;
  static constexpr int PeerEventId_ARRAYSIZE =
    PeerEvent_PeerEventId_PeerEventId_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PeerEventId_descriptor() {
    return PeerEvent_PeerEventId_descriptor();
  }
  template<typename T>
  static inline const std::string& PeerEventId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PeerEventId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PeerEventId_Name.");
    return PeerEvent_PeerEventId_Name(enum_t_value);
  }
  static inline bool PeerEventId_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PeerEventId* value) {
    return PeerEvent_PeerEventId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kEventIdFieldNumber = 2,
  };
  // .types.H512 peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  PROTOBUF_NODISCARD ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // .sentry.PeerEvent.PeerEventId event_id = 2;
  void clear_event_id();
  ::sentry::PeerEvent_PeerEventId event_id() const;
  void set_event_id(::sentry::PeerEvent_PeerEventId value);
  private:
  ::sentry::PeerEvent_PeerEventId _internal_event_id() const;
  void _internal_set_event_id(::sentry::PeerEvent_PeerEventId value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PeerEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H512* peer_id_;
    int event_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class AddPeerReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.AddPeerReply) */ {
 public:
  inline AddPeerReply() : AddPeerReply(nullptr) {}
  ~AddPeerReply() override;
  explicit PROTOBUF_CONSTEXPR AddPeerReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPeerReply(const AddPeerReply& from);
  AddPeerReply(AddPeerReply&& from) noexcept
    : AddPeerReply() {
    *this = ::std::move(from);
  }

  inline AddPeerReply& operator=(const AddPeerReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPeerReply& operator=(AddPeerReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPeerReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPeerReply* internal_default_instance() {
    return reinterpret_cast<const AddPeerReply*>(
               &_AddPeerReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AddPeerReply& a, AddPeerReply& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPeerReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPeerReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPeerReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPeerReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPeerReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddPeerReply& from) {
    AddPeerReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPeerReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.AddPeerReply";
  }
  protected:
  explicit AddPeerReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.AddPeerReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OutboundMessageData

// .sentry.MessageId id = 1;
inline void OutboundMessageData::clear_id() {
  _impl_.id_ = 0;
}
inline ::sentry::MessageId OutboundMessageData::_internal_id() const {
  return static_cast< ::sentry::MessageId >(_impl_.id_);
}
inline ::sentry::MessageId OutboundMessageData::id() const {
  // @@protoc_insertion_point(field_get:sentry.OutboundMessageData.id)
  return _internal_id();
}
inline void OutboundMessageData::_internal_set_id(::sentry::MessageId value) {
  
  _impl_.id_ = value;
}
inline void OutboundMessageData::set_id(::sentry::MessageId value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sentry.OutboundMessageData.id)
}

// bytes data = 2;
inline void OutboundMessageData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& OutboundMessageData::data() const {
  // @@protoc_insertion_point(field_get:sentry.OutboundMessageData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutboundMessageData::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentry.OutboundMessageData.data)
}
inline std::string* OutboundMessageData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sentry.OutboundMessageData.data)
  return _s;
}
inline const std::string& OutboundMessageData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void OutboundMessageData::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* OutboundMessageData::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* OutboundMessageData::release_data() {
  // @@protoc_insertion_point(field_release:sentry.OutboundMessageData.data)
  return _impl_.data_.Release();
}
inline void OutboundMessageData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentry.OutboundMessageData.data)
}

// -------------------------------------------------------------------

// SendMessageByMinBlockRequest

// .sentry.OutboundMessageData data = 1;
inline bool SendMessageByMinBlockRequest::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool SendMessageByMinBlockRequest::has_data() const {
  return _internal_has_data();
}
inline void SendMessageByMinBlockRequest::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::sentry::OutboundMessageData& SendMessageByMinBlockRequest::_internal_data() const {
  const ::sentry::OutboundMessageData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentry::OutboundMessageData&>(
      ::sentry::_OutboundMessageData_default_instance_);
}
inline const ::sentry::OutboundMessageData& SendMessageByMinBlockRequest::data() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByMinBlockRequest.data)
  return _internal_data();
}
inline void SendMessageByMinBlockRequest::unsafe_arena_set_allocated_data(
    ::sentry::OutboundMessageData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.SendMessageByMinBlockRequest.data)
}
inline ::sentry::OutboundMessageData* SendMessageByMinBlockRequest::release_data() {
  
  ::sentry::OutboundMessageData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageByMinBlockRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:sentry.SendMessageByMinBlockRequest.data)
  
  ::sentry::OutboundMessageData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageByMinBlockRequest::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentry::OutboundMessageData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::sentry::OutboundMessageData* SendMessageByMinBlockRequest::mutable_data() {
  ::sentry::OutboundMessageData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sentry.SendMessageByMinBlockRequest.data)
  return _msg;
}
inline void SendMessageByMinBlockRequest::set_allocated_data(::sentry::OutboundMessageData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:sentry.SendMessageByMinBlockRequest.data)
}

// uint64 min_block = 2;
inline void SendMessageByMinBlockRequest::clear_min_block() {
  _impl_.min_block_ = uint64_t{0u};
}
inline uint64_t SendMessageByMinBlockRequest::_internal_min_block() const {
  return _impl_.min_block_;
}
inline uint64_t SendMessageByMinBlockRequest::min_block() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByMinBlockRequest.min_block)
  return _internal_min_block();
}
inline void SendMessageByMinBlockRequest::_internal_set_min_block(uint64_t value) {
  
  _impl_.min_block_ = value;
}
inline void SendMessageByMinBlockRequest::set_min_block(uint64_t value) {
  _internal_set_min_block(value);
  // @@protoc_insertion_point(field_set:sentry.SendMessageByMinBlockRequest.min_block)
}

// uint64 max_peers = 3;
inline void SendMessageByMinBlockRequest::clear_max_peers() {
  _impl_.max_peers_ = uint64_t{0u};
}
inline uint64_t SendMessageByMinBlockRequest::_internal_max_peers() const {
  return _impl_.max_peers_;
}
inline uint64_t SendMessageByMinBlockRequest::max_peers() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByMinBlockRequest.max_peers)
  return _internal_max_peers();
}
inline void SendMessageByMinBlockRequest::_internal_set_max_peers(uint64_t value) {
  
  _impl_.max_peers_ = value;
}
inline void SendMessageByMinBlockRequest::set_max_peers(uint64_t value) {
  _internal_set_max_peers(value);
  // @@protoc_insertion_point(field_set:sentry.SendMessageByMinBlockRequest.max_peers)
}

// -------------------------------------------------------------------

// SendMessageByIdRequest

// .sentry.OutboundMessageData data = 1;
inline bool SendMessageByIdRequest::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool SendMessageByIdRequest::has_data() const {
  return _internal_has_data();
}
inline void SendMessageByIdRequest::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::sentry::OutboundMessageData& SendMessageByIdRequest::_internal_data() const {
  const ::sentry::OutboundMessageData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentry::OutboundMessageData&>(
      ::sentry::_OutboundMessageData_default_instance_);
}
inline const ::sentry::OutboundMessageData& SendMessageByIdRequest::data() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByIdRequest.data)
  return _internal_data();
}
inline void SendMessageByIdRequest::unsafe_arena_set_allocated_data(
    ::sentry::OutboundMessageData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.SendMessageByIdRequest.data)
}
inline ::sentry::OutboundMessageData* SendMessageByIdRequest::release_data() {
  
  ::sentry::OutboundMessageData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageByIdRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:sentry.SendMessageByIdRequest.data)
  
  ::sentry::OutboundMessageData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageByIdRequest::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentry::OutboundMessageData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::sentry::OutboundMessageData* SendMessageByIdRequest::mutable_data() {
  ::sentry::OutboundMessageData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sentry.SendMessageByIdRequest.data)
  return _msg;
}
inline void SendMessageByIdRequest::set_allocated_data(::sentry::OutboundMessageData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:sentry.SendMessageByIdRequest.data)
}

// .types.H512 peer_id = 2;
inline bool SendMessageByIdRequest::_internal_has_peer_id() const {
  return this != internal_default_instance() && _impl_.peer_id_ != nullptr;
}
inline bool SendMessageByIdRequest::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& SendMessageByIdRequest::_internal_peer_id() const {
  const ::types::H512* p = _impl_.peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& SendMessageByIdRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByIdRequest.peer_id)
  return _internal_peer_id();
}
inline void SendMessageByIdRequest::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  _impl_.peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.SendMessageByIdRequest.peer_id)
}
inline ::types::H512* SendMessageByIdRequest::release_peer_id() {
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H512* SendMessageByIdRequest::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.SendMessageByIdRequest.peer_id)
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* SendMessageByIdRequest::_internal_mutable_peer_id() {
  
  if (_impl_.peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArenaForAllocation());
    _impl_.peer_id_ = p;
  }
  return _impl_.peer_id_;
}
inline ::types::H512* SendMessageByIdRequest::mutable_peer_id() {
  ::types::H512* _msg = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:sentry.SendMessageByIdRequest.peer_id)
  return _msg;
}
inline void SendMessageByIdRequest::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id));
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.SendMessageByIdRequest.peer_id)
}

// -------------------------------------------------------------------

// SendMessageToRandomPeersRequest

// .sentry.OutboundMessageData data = 1;
inline bool SendMessageToRandomPeersRequest::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool SendMessageToRandomPeersRequest::has_data() const {
  return _internal_has_data();
}
inline void SendMessageToRandomPeersRequest::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::sentry::OutboundMessageData& SendMessageToRandomPeersRequest::_internal_data() const {
  const ::sentry::OutboundMessageData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentry::OutboundMessageData&>(
      ::sentry::_OutboundMessageData_default_instance_);
}
inline const ::sentry::OutboundMessageData& SendMessageToRandomPeersRequest::data() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageToRandomPeersRequest.data)
  return _internal_data();
}
inline void SendMessageToRandomPeersRequest::unsafe_arena_set_allocated_data(
    ::sentry::OutboundMessageData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.SendMessageToRandomPeersRequest.data)
}
inline ::sentry::OutboundMessageData* SendMessageToRandomPeersRequest::release_data() {
  
  ::sentry::OutboundMessageData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageToRandomPeersRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:sentry.SendMessageToRandomPeersRequest.data)
  
  ::sentry::OutboundMessageData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageToRandomPeersRequest::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentry::OutboundMessageData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::sentry::OutboundMessageData* SendMessageToRandomPeersRequest::mutable_data() {
  ::sentry::OutboundMessageData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sentry.SendMessageToRandomPeersRequest.data)
  return _msg;
}
inline void SendMessageToRandomPeersRequest::set_allocated_data(::sentry::OutboundMessageData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:sentry.SendMessageToRandomPeersRequest.data)
}

// uint64 max_peers = 2;
inline void SendMessageToRandomPeersRequest::clear_max_peers() {
  _impl_.max_peers_ = uint64_t{0u};
}
inline uint64_t SendMessageToRandomPeersRequest::_internal_max_peers() const {
  return _impl_.max_peers_;
}
inline uint64_t SendMessageToRandomPeersRequest::max_peers() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageToRandomPeersRequest.max_peers)
  return _internal_max_peers();
}
inline void SendMessageToRandomPeersRequest::_internal_set_max_peers(uint64_t value) {
  
  _impl_.max_peers_ = value;
}
inline void SendMessageToRandomPeersRequest::set_max_peers(uint64_t value) {
  _internal_set_max_peers(value);
  // @@protoc_insertion_point(field_set:sentry.SendMessageToRandomPeersRequest.max_peers)
}

// -------------------------------------------------------------------

// SentPeers

// repeated .types.H512 peers = 1;
inline int SentPeers::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int SentPeers::peers_size() const {
  return _internal_peers_size();
}
inline ::types::H512* SentPeers::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:sentry.SentPeers.peers)
  return _impl_.peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 >*
SentPeers::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:sentry.SentPeers.peers)
  return &_impl_.peers_;
}
inline const ::types::H512& SentPeers::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const ::types::H512& SentPeers::peers(int index) const {
  // @@protoc_insertion_point(field_get:sentry.SentPeers.peers)
  return _internal_peers(index);
}
inline ::types::H512* SentPeers::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline ::types::H512* SentPeers::add_peers() {
  ::types::H512* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:sentry.SentPeers.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 >&
SentPeers::peers() const {
  // @@protoc_insertion_point(field_list:sentry.SentPeers.peers)
  return _impl_.peers_;
}

// -------------------------------------------------------------------

// PenalizePeerRequest

// .types.H512 peer_id = 1;
inline bool PenalizePeerRequest::_internal_has_peer_id() const {
  return this != internal_default_instance() && _impl_.peer_id_ != nullptr;
}
inline bool PenalizePeerRequest::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& PenalizePeerRequest::_internal_peer_id() const {
  const ::types::H512* p = _impl_.peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& PenalizePeerRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.PenalizePeerRequest.peer_id)
  return _internal_peer_id();
}
inline void PenalizePeerRequest::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  _impl_.peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.PenalizePeerRequest.peer_id)
}
inline ::types::H512* PenalizePeerRequest::release_peer_id() {
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H512* PenalizePeerRequest::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.PenalizePeerRequest.peer_id)
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* PenalizePeerRequest::_internal_mutable_peer_id() {
  
  if (_impl_.peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArenaForAllocation());
    _impl_.peer_id_ = p;
  }
  return _impl_.peer_id_;
}
inline ::types::H512* PenalizePeerRequest::mutable_peer_id() {
  ::types::H512* _msg = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:sentry.PenalizePeerRequest.peer_id)
  return _msg;
}
inline void PenalizePeerRequest::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id));
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.PenalizePeerRequest.peer_id)
}

// .sentry.PenaltyKind penalty = 2;
inline void PenalizePeerRequest::clear_penalty() {
  _impl_.penalty_ = 0;
}
inline ::sentry::PenaltyKind PenalizePeerRequest::_internal_penalty() const {
  return static_cast< ::sentry::PenaltyKind >(_impl_.penalty_);
}
inline ::sentry::PenaltyKind PenalizePeerRequest::penalty() const {
  // @@protoc_insertion_point(field_get:sentry.PenalizePeerRequest.penalty)
  return _internal_penalty();
}
inline void PenalizePeerRequest::_internal_set_penalty(::sentry::PenaltyKind value) {
  
  _impl_.penalty_ = value;
}
inline void PenalizePeerRequest::set_penalty(::sentry::PenaltyKind value) {
  _internal_set_penalty(value);
  // @@protoc_insertion_point(field_set:sentry.PenalizePeerRequest.penalty)
}

// -------------------------------------------------------------------

// PeerMinBlockRequest

// .types.H512 peer_id = 1;
inline bool PeerMinBlockRequest::_internal_has_peer_id() const {
  return this != internal_default_instance() && _impl_.peer_id_ != nullptr;
}
inline bool PeerMinBlockRequest::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& PeerMinBlockRequest::_internal_peer_id() const {
  const ::types::H512* p = _impl_.peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& PeerMinBlockRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.PeerMinBlockRequest.peer_id)
  return _internal_peer_id();
}
inline void PeerMinBlockRequest::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  _impl_.peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.PeerMinBlockRequest.peer_id)
}
inline ::types::H512* PeerMinBlockRequest::release_peer_id() {
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H512* PeerMinBlockRequest::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.PeerMinBlockRequest.peer_id)
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* PeerMinBlockRequest::_internal_mutable_peer_id() {
  
  if (_impl_.peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArenaForAllocation());
    _impl_.peer_id_ = p;
  }
  return _impl_.peer_id_;
}
inline ::types::H512* PeerMinBlockRequest::mutable_peer_id() {
  ::types::H512* _msg = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:sentry.PeerMinBlockRequest.peer_id)
  return _msg;
}
inline void PeerMinBlockRequest::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id));
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.PeerMinBlockRequest.peer_id)
}

// uint64 min_block = 2;
inline void PeerMinBlockRequest::clear_min_block() {
  _impl_.min_block_ = uint64_t{0u};
}
inline uint64_t PeerMinBlockRequest::_internal_min_block() const {
  return _impl_.min_block_;
}
inline uint64_t PeerMinBlockRequest::min_block() const {
  // @@protoc_insertion_point(field_get:sentry.PeerMinBlockRequest.min_block)
  return _internal_min_block();
}
inline void PeerMinBlockRequest::_internal_set_min_block(uint64_t value) {
  
  _impl_.min_block_ = value;
}
inline void PeerMinBlockRequest::set_min_block(uint64_t value) {
  _internal_set_min_block(value);
  // @@protoc_insertion_point(field_set:sentry.PeerMinBlockRequest.min_block)
}

// -------------------------------------------------------------------

// AddPeerRequest

// string url = 1;
inline void AddPeerRequest::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& AddPeerRequest::url() const {
  // @@protoc_insertion_point(field_get:sentry.AddPeerRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddPeerRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentry.AddPeerRequest.url)
}
inline std::string* AddPeerRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:sentry.AddPeerRequest.url)
  return _s;
}
inline const std::string& AddPeerRequest::_internal_url() const {
  return _impl_.url_.Get();
}
inline void AddPeerRequest::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* AddPeerRequest::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* AddPeerRequest::release_url() {
  // @@protoc_insertion_point(field_release:sentry.AddPeerRequest.url)
  return _impl_.url_.Release();
}
inline void AddPeerRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentry.AddPeerRequest.url)
}

// -------------------------------------------------------------------

// InboundMessage

// .sentry.MessageId id = 1;
inline void InboundMessage::clear_id() {
  _impl_.id_ = 0;
}
inline ::sentry::MessageId InboundMessage::_internal_id() const {
  return static_cast< ::sentry::MessageId >(_impl_.id_);
}
inline ::sentry::MessageId InboundMessage::id() const {
  // @@protoc_insertion_point(field_get:sentry.InboundMessage.id)
  return _internal_id();
}
inline void InboundMessage::_internal_set_id(::sentry::MessageId value) {
  
  _impl_.id_ = value;
}
inline void InboundMessage::set_id(::sentry::MessageId value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sentry.InboundMessage.id)
}

// bytes data = 2;
inline void InboundMessage::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& InboundMessage::data() const {
  // @@protoc_insertion_point(field_get:sentry.InboundMessage.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InboundMessage::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentry.InboundMessage.data)
}
inline std::string* InboundMessage::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sentry.InboundMessage.data)
  return _s;
}
inline const std::string& InboundMessage::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InboundMessage::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InboundMessage::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* InboundMessage::release_data() {
  // @@protoc_insertion_point(field_release:sentry.InboundMessage.data)
  return _impl_.data_.Release();
}
inline void InboundMessage::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentry.InboundMessage.data)
}

// .types.H512 peer_id = 3;
inline bool InboundMessage::_internal_has_peer_id() const {
  return this != internal_default_instance() && _impl_.peer_id_ != nullptr;
}
inline bool InboundMessage::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& InboundMessage::_internal_peer_id() const {
  const ::types::H512* p = _impl_.peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& InboundMessage::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.InboundMessage.peer_id)
  return _internal_peer_id();
}
inline void InboundMessage::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  _impl_.peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.InboundMessage.peer_id)
}
inline ::types::H512* InboundMessage::release_peer_id() {
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H512* InboundMessage::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.InboundMessage.peer_id)
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* InboundMessage::_internal_mutable_peer_id() {
  
  if (_impl_.peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArenaForAllocation());
    _impl_.peer_id_ = p;
  }
  return _impl_.peer_id_;
}
inline ::types::H512* InboundMessage::mutable_peer_id() {
  ::types::H512* _msg = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:sentry.InboundMessage.peer_id)
  return _msg;
}
inline void InboundMessage::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id));
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.InboundMessage.peer_id)
}

// -------------------------------------------------------------------

// Forks

// .types.H256 genesis = 1;
inline bool Forks::_internal_has_genesis() const {
  return this != internal_default_instance() && _impl_.genesis_ != nullptr;
}
inline bool Forks::has_genesis() const {
  return _internal_has_genesis();
}
inline const ::types::H256& Forks::_internal_genesis() const {
  const ::types::H256* p = _impl_.genesis_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Forks::genesis() const {
  // @@protoc_insertion_point(field_get:sentry.Forks.genesis)
  return _internal_genesis();
}
inline void Forks::unsafe_arena_set_allocated_genesis(
    ::types::H256* genesis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.genesis_);
  }
  _impl_.genesis_ = genesis;
  if (genesis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.Forks.genesis)
}
inline ::types::H256* Forks::release_genesis() {
  
  ::types::H256* temp = _impl_.genesis_;
  _impl_.genesis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Forks::unsafe_arena_release_genesis() {
  // @@protoc_insertion_point(field_release:sentry.Forks.genesis)
  
  ::types::H256* temp = _impl_.genesis_;
  _impl_.genesis_ = nullptr;
  return temp;
}
inline ::types::H256* Forks::_internal_mutable_genesis() {
  
  if (_impl_.genesis_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.genesis_ = p;
  }
  return _impl_.genesis_;
}
inline ::types::H256* Forks::mutable_genesis() {
  ::types::H256* _msg = _internal_mutable_genesis();
  // @@protoc_insertion_point(field_mutable:sentry.Forks.genesis)
  return _msg;
}
inline void Forks::set_allocated_genesis(::types::H256* genesis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.genesis_);
  }
  if (genesis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(genesis));
    if (message_arena != submessage_arena) {
      genesis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, genesis, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.genesis_ = genesis;
  // @@protoc_insertion_point(field_set_allocated:sentry.Forks.genesis)
}

// repeated uint64 height_forks = 2;
inline int Forks::_internal_height_forks_size() const {
  return _impl_.height_forks_.size();
}
inline int Forks::height_forks_size() const {
  return _internal_height_forks_size();
}
inline void Forks::clear_height_forks() {
  _impl_.height_forks_.Clear();
}
inline uint64_t Forks::_internal_height_forks(int index) const {
  return _impl_.height_forks_.Get(index);
}
inline uint64_t Forks::height_forks(int index) const {
  // @@protoc_insertion_point(field_get:sentry.Forks.height_forks)
  return _internal_height_forks(index);
}
inline void Forks::set_height_forks(int index, uint64_t value) {
  _impl_.height_forks_.Set(index, value);
  // @@protoc_insertion_point(field_set:sentry.Forks.height_forks)
}
inline void Forks::_internal_add_height_forks(uint64_t value) {
  _impl_.height_forks_.Add(value);
}
inline void Forks::add_height_forks(uint64_t value) {
  _internal_add_height_forks(value);
  // @@protoc_insertion_point(field_add:sentry.Forks.height_forks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Forks::_internal_height_forks() const {
  return _impl_.height_forks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Forks::height_forks() const {
  // @@protoc_insertion_point(field_list:sentry.Forks.height_forks)
  return _internal_height_forks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Forks::_internal_mutable_height_forks() {
  return &_impl_.height_forks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Forks::mutable_height_forks() {
  // @@protoc_insertion_point(field_mutable_list:sentry.Forks.height_forks)
  return _internal_mutable_height_forks();
}

// repeated uint64 time_forks = 3;
inline int Forks::_internal_time_forks_size() const {
  return _impl_.time_forks_.size();
}
inline int Forks::time_forks_size() const {
  return _internal_time_forks_size();
}
inline void Forks::clear_time_forks() {
  _impl_.time_forks_.Clear();
}
inline uint64_t Forks::_internal_time_forks(int index) const {
  return _impl_.time_forks_.Get(index);
}
inline uint64_t Forks::time_forks(int index) const {
  // @@protoc_insertion_point(field_get:sentry.Forks.time_forks)
  return _internal_time_forks(index);
}
inline void Forks::set_time_forks(int index, uint64_t value) {
  _impl_.time_forks_.Set(index, value);
  // @@protoc_insertion_point(field_set:sentry.Forks.time_forks)
}
inline void Forks::_internal_add_time_forks(uint64_t value) {
  _impl_.time_forks_.Add(value);
}
inline void Forks::add_time_forks(uint64_t value) {
  _internal_add_time_forks(value);
  // @@protoc_insertion_point(field_add:sentry.Forks.time_forks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Forks::_internal_time_forks() const {
  return _impl_.time_forks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Forks::time_forks() const {
  // @@protoc_insertion_point(field_list:sentry.Forks.time_forks)
  return _internal_time_forks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Forks::_internal_mutable_time_forks() {
  return &_impl_.time_forks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Forks::mutable_time_forks() {
  // @@protoc_insertion_point(field_mutable_list:sentry.Forks.time_forks)
  return _internal_mutable_time_forks();
}

// -------------------------------------------------------------------

// StatusData

// uint64 network_id = 1;
inline void StatusData::clear_network_id() {
  _impl_.network_id_ = uint64_t{0u};
}
inline uint64_t StatusData::_internal_network_id() const {
  return _impl_.network_id_;
}
inline uint64_t StatusData::network_id() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.network_id)
  return _internal_network_id();
}
inline void StatusData::_internal_set_network_id(uint64_t value) {
  
  _impl_.network_id_ = value;
}
inline void StatusData::set_network_id(uint64_t value) {
  _internal_set_network_id(value);
  // @@protoc_insertion_point(field_set:sentry.StatusData.network_id)
}

// .types.H256 total_difficulty = 2;
inline bool StatusData::_internal_has_total_difficulty() const {
  return this != internal_default_instance() && _impl_.total_difficulty_ != nullptr;
}
inline bool StatusData::has_total_difficulty() const {
  return _internal_has_total_difficulty();
}
inline const ::types::H256& StatusData::_internal_total_difficulty() const {
  const ::types::H256* p = _impl_.total_difficulty_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& StatusData::total_difficulty() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.total_difficulty)
  return _internal_total_difficulty();
}
inline void StatusData::unsafe_arena_set_allocated_total_difficulty(
    ::types::H256* total_difficulty) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.total_difficulty_);
  }
  _impl_.total_difficulty_ = total_difficulty;
  if (total_difficulty) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.StatusData.total_difficulty)
}
inline ::types::H256* StatusData::release_total_difficulty() {
  
  ::types::H256* temp = _impl_.total_difficulty_;
  _impl_.total_difficulty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* StatusData::unsafe_arena_release_total_difficulty() {
  // @@protoc_insertion_point(field_release:sentry.StatusData.total_difficulty)
  
  ::types::H256* temp = _impl_.total_difficulty_;
  _impl_.total_difficulty_ = nullptr;
  return temp;
}
inline ::types::H256* StatusData::_internal_mutable_total_difficulty() {
  
  if (_impl_.total_difficulty_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.total_difficulty_ = p;
  }
  return _impl_.total_difficulty_;
}
inline ::types::H256* StatusData::mutable_total_difficulty() {
  ::types::H256* _msg = _internal_mutable_total_difficulty();
  // @@protoc_insertion_point(field_mutable:sentry.StatusData.total_difficulty)
  return _msg;
}
inline void StatusData::set_allocated_total_difficulty(::types::H256* total_difficulty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.total_difficulty_);
  }
  if (total_difficulty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_difficulty));
    if (message_arena != submessage_arena) {
      total_difficulty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, total_difficulty, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.total_difficulty_ = total_difficulty;
  // @@protoc_insertion_point(field_set_allocated:sentry.StatusData.total_difficulty)
}

// .types.H256 best_hash = 3;
inline bool StatusData::_internal_has_best_hash() const {
  return this != internal_default_instance() && _impl_.best_hash_ != nullptr;
}
inline bool StatusData::has_best_hash() const {
  return _internal_has_best_hash();
}
inline const ::types::H256& StatusData::_internal_best_hash() const {
  const ::types::H256* p = _impl_.best_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& StatusData::best_hash() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.best_hash)
  return _internal_best_hash();
}
inline void StatusData::unsafe_arena_set_allocated_best_hash(
    ::types::H256* best_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.best_hash_);
  }
  _impl_.best_hash_ = best_hash;
  if (best_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.StatusData.best_hash)
}
inline ::types::H256* StatusData::release_best_hash() {
  
  ::types::H256* temp = _impl_.best_hash_;
  _impl_.best_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* StatusData::unsafe_arena_release_best_hash() {
  // @@protoc_insertion_point(field_release:sentry.StatusData.best_hash)
  
  ::types::H256* temp = _impl_.best_hash_;
  _impl_.best_hash_ = nullptr;
  return temp;
}
inline ::types::H256* StatusData::_internal_mutable_best_hash() {
  
  if (_impl_.best_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.best_hash_ = p;
  }
  return _impl_.best_hash_;
}
inline ::types::H256* StatusData::mutable_best_hash() {
  ::types::H256* _msg = _internal_mutable_best_hash();
  // @@protoc_insertion_point(field_mutable:sentry.StatusData.best_hash)
  return _msg;
}
inline void StatusData::set_allocated_best_hash(::types::H256* best_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.best_hash_);
  }
  if (best_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(best_hash));
    if (message_arena != submessage_arena) {
      best_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, best_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.best_hash_ = best_hash;
  // @@protoc_insertion_point(field_set_allocated:sentry.StatusData.best_hash)
}

// .sentry.Forks fork_data = 4;
inline bool StatusData::_internal_has_fork_data() const {
  return this != internal_default_instance() && _impl_.fork_data_ != nullptr;
}
inline bool StatusData::has_fork_data() const {
  return _internal_has_fork_data();
}
inline void StatusData::clear_fork_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.fork_data_ != nullptr) {
    delete _impl_.fork_data_;
  }
  _impl_.fork_data_ = nullptr;
}
inline const ::sentry::Forks& StatusData::_internal_fork_data() const {
  const ::sentry::Forks* p = _impl_.fork_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentry::Forks&>(
      ::sentry::_Forks_default_instance_);
}
inline const ::sentry::Forks& StatusData::fork_data() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.fork_data)
  return _internal_fork_data();
}
inline void StatusData::unsafe_arena_set_allocated_fork_data(
    ::sentry::Forks* fork_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fork_data_);
  }
  _impl_.fork_data_ = fork_data;
  if (fork_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.StatusData.fork_data)
}
inline ::sentry::Forks* StatusData::release_fork_data() {
  
  ::sentry::Forks* temp = _impl_.fork_data_;
  _impl_.fork_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentry::Forks* StatusData::unsafe_arena_release_fork_data() {
  // @@protoc_insertion_point(field_release:sentry.StatusData.fork_data)
  
  ::sentry::Forks* temp = _impl_.fork_data_;
  _impl_.fork_data_ = nullptr;
  return temp;
}
inline ::sentry::Forks* StatusData::_internal_mutable_fork_data() {
  
  if (_impl_.fork_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentry::Forks>(GetArenaForAllocation());
    _impl_.fork_data_ = p;
  }
  return _impl_.fork_data_;
}
inline ::sentry::Forks* StatusData::mutable_fork_data() {
  ::sentry::Forks* _msg = _internal_mutable_fork_data();
  // @@protoc_insertion_point(field_mutable:sentry.StatusData.fork_data)
  return _msg;
}
inline void StatusData::set_allocated_fork_data(::sentry::Forks* fork_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fork_data_;
  }
  if (fork_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fork_data);
    if (message_arena != submessage_arena) {
      fork_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fork_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fork_data_ = fork_data;
  // @@protoc_insertion_point(field_set_allocated:sentry.StatusData.fork_data)
}

// uint64 max_block_height = 5;
inline void StatusData::clear_max_block_height() {
  _impl_.max_block_height_ = uint64_t{0u};
}
inline uint64_t StatusData::_internal_max_block_height() const {
  return _impl_.max_block_height_;
}
inline uint64_t StatusData::max_block_height() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.max_block_height)
  return _internal_max_block_height();
}
inline void StatusData::_internal_set_max_block_height(uint64_t value) {
  
  _impl_.max_block_height_ = value;
}
inline void StatusData::set_max_block_height(uint64_t value) {
  _internal_set_max_block_height(value);
  // @@protoc_insertion_point(field_set:sentry.StatusData.max_block_height)
}

// uint64 max_block_time = 6;
inline void StatusData::clear_max_block_time() {
  _impl_.max_block_time_ = uint64_t{0u};
}
inline uint64_t StatusData::_internal_max_block_time() const {
  return _impl_.max_block_time_;
}
inline uint64_t StatusData::max_block_time() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.max_block_time)
  return _internal_max_block_time();
}
inline void StatusData::_internal_set_max_block_time(uint64_t value) {
  
  _impl_.max_block_time_ = value;
}
inline void StatusData::set_max_block_time(uint64_t value) {
  _internal_set_max_block_time(value);
  // @@protoc_insertion_point(field_set:sentry.StatusData.max_block_time)
}

// -------------------------------------------------------------------

// SetStatusReply

// -------------------------------------------------------------------

// HandShakeReply

// .sentry.Protocol protocol = 1;
inline void HandShakeReply::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline ::sentry::Protocol HandShakeReply::_internal_protocol() const {
  return static_cast< ::sentry::Protocol >(_impl_.protocol_);
}
inline ::sentry::Protocol HandShakeReply::protocol() const {
  // @@protoc_insertion_point(field_get:sentry.HandShakeReply.protocol)
  return _internal_protocol();
}
inline void HandShakeReply::_internal_set_protocol(::sentry::Protocol value) {
  
  _impl_.protocol_ = value;
}
inline void HandShakeReply::set_protocol(::sentry::Protocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:sentry.HandShakeReply.protocol)
}

// -------------------------------------------------------------------

// MessagesRequest

// repeated .sentry.MessageId ids = 1;
inline int MessagesRequest::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int MessagesRequest::ids_size() const {
  return _internal_ids_size();
}
inline void MessagesRequest::clear_ids() {
  _impl_.ids_.Clear();
}
inline ::sentry::MessageId MessagesRequest::_internal_ids(int index) const {
  return static_cast< ::sentry::MessageId >(_impl_.ids_.Get(index));
}
inline ::sentry::MessageId MessagesRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:sentry.MessagesRequest.ids)
  return _internal_ids(index);
}
inline void MessagesRequest::set_ids(int index, ::sentry::MessageId value) {
  _impl_.ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:sentry.MessagesRequest.ids)
}
inline void MessagesRequest::_internal_add_ids(::sentry::MessageId value) {
  _impl_.ids_.Add(value);
}
inline void MessagesRequest::add_ids(::sentry::MessageId value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:sentry.MessagesRequest.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
MessagesRequest::ids() const {
  // @@protoc_insertion_point(field_list:sentry.MessagesRequest.ids)
  return _impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MessagesRequest::_internal_mutable_ids() {
  return &_impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MessagesRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:sentry.MessagesRequest.ids)
  return _internal_mutable_ids();
}

// -------------------------------------------------------------------

// PeersReply

// repeated .types.PeerInfo peers = 1;
inline int PeersReply::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int PeersReply::peers_size() const {
  return _internal_peers_size();
}
inline ::types::PeerInfo* PeersReply::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:sentry.PeersReply.peers)
  return _impl_.peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo >*
PeersReply::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:sentry.PeersReply.peers)
  return &_impl_.peers_;
}
inline const ::types::PeerInfo& PeersReply::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const ::types::PeerInfo& PeersReply::peers(int index) const {
  // @@protoc_insertion_point(field_get:sentry.PeersReply.peers)
  return _internal_peers(index);
}
inline ::types::PeerInfo* PeersReply::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline ::types::PeerInfo* PeersReply::add_peers() {
  ::types::PeerInfo* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:sentry.PeersReply.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PeerInfo >&
PeersReply::peers() const {
  // @@protoc_insertion_point(field_list:sentry.PeersReply.peers)
  return _impl_.peers_;
}

// -------------------------------------------------------------------

// PeerCountRequest

// -------------------------------------------------------------------

// PeerCountPerProtocol

// .sentry.Protocol protocol = 1;
inline void PeerCountPerProtocol::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline ::sentry::Protocol PeerCountPerProtocol::_internal_protocol() const {
  return static_cast< ::sentry::Protocol >(_impl_.protocol_);
}
inline ::sentry::Protocol PeerCountPerProtocol::protocol() const {
  // @@protoc_insertion_point(field_get:sentry.PeerCountPerProtocol.protocol)
  return _internal_protocol();
}
inline void PeerCountPerProtocol::_internal_set_protocol(::sentry::Protocol value) {
  
  _impl_.protocol_ = value;
}
inline void PeerCountPerProtocol::set_protocol(::sentry::Protocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:sentry.PeerCountPerProtocol.protocol)
}

// uint64 count = 2;
inline void PeerCountPerProtocol::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t PeerCountPerProtocol::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t PeerCountPerProtocol::count() const {
  // @@protoc_insertion_point(field_get:sentry.PeerCountPerProtocol.count)
  return _internal_count();
}
inline void PeerCountPerProtocol::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void PeerCountPerProtocol::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:sentry.PeerCountPerProtocol.count)
}

// -------------------------------------------------------------------

// PeerCountReply

// uint64 count = 1;
inline void PeerCountReply::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t PeerCountReply::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t PeerCountReply::count() const {
  // @@protoc_insertion_point(field_get:sentry.PeerCountReply.count)
  return _internal_count();
}
inline void PeerCountReply::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void PeerCountReply::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:sentry.PeerCountReply.count)
}

// repeated .sentry.PeerCountPerProtocol counts_per_protocol = 2;
inline int PeerCountReply::_internal_counts_per_protocol_size() const {
  return _impl_.counts_per_protocol_.size();
}
inline int PeerCountReply::counts_per_protocol_size() const {
  return _internal_counts_per_protocol_size();
}
inline void PeerCountReply::clear_counts_per_protocol() {
  _impl_.counts_per_protocol_.Clear();
}
inline ::sentry::PeerCountPerProtocol* PeerCountReply::mutable_counts_per_protocol(int index) {
  // @@protoc_insertion_point(field_mutable:sentry.PeerCountReply.counts_per_protocol)
  return _impl_.counts_per_protocol_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentry::PeerCountPerProtocol >*
PeerCountReply::mutable_counts_per_protocol() {
  // @@protoc_insertion_point(field_mutable_list:sentry.PeerCountReply.counts_per_protocol)
  return &_impl_.counts_per_protocol_;
}
inline const ::sentry::PeerCountPerProtocol& PeerCountReply::_internal_counts_per_protocol(int index) const {
  return _impl_.counts_per_protocol_.Get(index);
}
inline const ::sentry::PeerCountPerProtocol& PeerCountReply::counts_per_protocol(int index) const {
  // @@protoc_insertion_point(field_get:sentry.PeerCountReply.counts_per_protocol)
  return _internal_counts_per_protocol(index);
}
inline ::sentry::PeerCountPerProtocol* PeerCountReply::_internal_add_counts_per_protocol() {
  return _impl_.counts_per_protocol_.Add();
}
inline ::sentry::PeerCountPerProtocol* PeerCountReply::add_counts_per_protocol() {
  ::sentry::PeerCountPerProtocol* _add = _internal_add_counts_per_protocol();
  // @@protoc_insertion_point(field_add:sentry.PeerCountReply.counts_per_protocol)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentry::PeerCountPerProtocol >&
PeerCountReply::counts_per_protocol() const {
  // @@protoc_insertion_point(field_list:sentry.PeerCountReply.counts_per_protocol)
  return _impl_.counts_per_protocol_;
}

// -------------------------------------------------------------------

// PeerByIdRequest

// .types.H512 peer_id = 1;
inline bool PeerByIdRequest::_internal_has_peer_id() const {
  return this != internal_default_instance() && _impl_.peer_id_ != nullptr;
}
inline bool PeerByIdRequest::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& PeerByIdRequest::_internal_peer_id() const {
  const ::types::H512* p = _impl_.peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& PeerByIdRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.PeerByIdRequest.peer_id)
  return _internal_peer_id();
}
inline void PeerByIdRequest::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  _impl_.peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.PeerByIdRequest.peer_id)
}
inline ::types::H512* PeerByIdRequest::release_peer_id() {
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H512* PeerByIdRequest::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.PeerByIdRequest.peer_id)
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* PeerByIdRequest::_internal_mutable_peer_id() {
  
  if (_impl_.peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArenaForAllocation());
    _impl_.peer_id_ = p;
  }
  return _impl_.peer_id_;
}
inline ::types::H512* PeerByIdRequest::mutable_peer_id() {
  ::types::H512* _msg = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:sentry.PeerByIdRequest.peer_id)
  return _msg;
}
inline void PeerByIdRequest::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id));
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.PeerByIdRequest.peer_id)
}

// -------------------------------------------------------------------

// PeerByIdReply

// optional .types.PeerInfo peer = 1;
inline bool PeerByIdReply::_internal_has_peer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.peer_ != nullptr);
  return value;
}
inline bool PeerByIdReply::has_peer() const {
  return _internal_has_peer();
}
inline const ::types::PeerInfo& PeerByIdReply::_internal_peer() const {
  const ::types::PeerInfo* p = _impl_.peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::PeerInfo&>(
      ::types::_PeerInfo_default_instance_);
}
inline const ::types::PeerInfo& PeerByIdReply::peer() const {
  // @@protoc_insertion_point(field_get:sentry.PeerByIdReply.peer)
  return _internal_peer();
}
inline void PeerByIdReply::unsafe_arena_set_allocated_peer(
    ::types::PeerInfo* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  _impl_.peer_ = peer;
  if (peer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.PeerByIdReply.peer)
}
inline ::types::PeerInfo* PeerByIdReply::release_peer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::PeerInfo* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::PeerInfo* PeerByIdReply::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:sentry.PeerByIdReply.peer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::PeerInfo* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
  return temp;
}
inline ::types::PeerInfo* PeerByIdReply::_internal_mutable_peer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::PeerInfo>(GetArenaForAllocation());
    _impl_.peer_ = p;
  }
  return _impl_.peer_;
}
inline ::types::PeerInfo* PeerByIdReply::mutable_peer() {
  ::types::PeerInfo* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:sentry.PeerByIdReply.peer)
  return _msg;
}
inline void PeerByIdReply::set_allocated_peer(::types::PeerInfo* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer));
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:sentry.PeerByIdReply.peer)
}

// -------------------------------------------------------------------

// PeerEventsRequest

// -------------------------------------------------------------------

// PeerEvent

// .types.H512 peer_id = 1;
inline bool PeerEvent::_internal_has_peer_id() const {
  return this != internal_default_instance() && _impl_.peer_id_ != nullptr;
}
inline bool PeerEvent::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& PeerEvent::_internal_peer_id() const {
  const ::types::H512* p = _impl_.peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& PeerEvent::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.PeerEvent.peer_id)
  return _internal_peer_id();
}
inline void PeerEvent::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  _impl_.peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.PeerEvent.peer_id)
}
inline ::types::H512* PeerEvent::release_peer_id() {
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H512* PeerEvent::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.PeerEvent.peer_id)
  
  ::types::H512* temp = _impl_.peer_id_;
  _impl_.peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* PeerEvent::_internal_mutable_peer_id() {
  
  if (_impl_.peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArenaForAllocation());
    _impl_.peer_id_ = p;
  }
  return _impl_.peer_id_;
}
inline ::types::H512* PeerEvent::mutable_peer_id() {
  ::types::H512* _msg = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:sentry.PeerEvent.peer_id)
  return _msg;
}
inline void PeerEvent::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id));
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.PeerEvent.peer_id)
}

// .sentry.PeerEvent.PeerEventId event_id = 2;
inline void PeerEvent::clear_event_id() {
  _impl_.event_id_ = 0;
}
inline ::sentry::PeerEvent_PeerEventId PeerEvent::_internal_event_id() const {
  return static_cast< ::sentry::PeerEvent_PeerEventId >(_impl_.event_id_);
}
inline ::sentry::PeerEvent_PeerEventId PeerEvent::event_id() const {
  // @@protoc_insertion_point(field_get:sentry.PeerEvent.event_id)
  return _internal_event_id();
}
inline void PeerEvent::_internal_set_event_id(::sentry::PeerEvent_PeerEventId value) {
  
  _impl_.event_id_ = value;
}
inline void PeerEvent::set_event_id(::sentry::PeerEvent_PeerEventId value) {
  _internal_set_event_id(value);
  // @@protoc_insertion_point(field_set:sentry.PeerEvent.event_id)
}

// -------------------------------------------------------------------

// AddPeerReply

// bool success = 1;
inline void AddPeerReply::clear_success() {
  _impl_.success_ = false;
}
inline bool AddPeerReply::_internal_success() const {
  return _impl_.success_;
}
inline bool AddPeerReply::success() const {
  // @@protoc_insertion_point(field_get:sentry.AddPeerReply.success)
  return _internal_success();
}
inline void AddPeerReply::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void AddPeerReply::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sentry.AddPeerReply.success)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sentry

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sentry::PeerEvent_PeerEventId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentry::PeerEvent_PeerEventId>() {
  return ::sentry::PeerEvent_PeerEventId_descriptor();
}
template <> struct is_proto_enum< ::sentry::MessageId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentry::MessageId>() {
  return ::sentry::MessageId_descriptor();
}
template <> struct is_proto_enum< ::sentry::PenaltyKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentry::PenaltyKind>() {
  return ::sentry::PenaltyKind_descriptor();
}
template <> struct is_proto_enum< ::sentry::Protocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentry::Protocol>() {
  return ::sentry::Protocol_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_p2psentry_2fsentry_2eproto
