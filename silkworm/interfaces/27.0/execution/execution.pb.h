// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: execution/execution.proto
// Protobuf C++ Version: 5.27.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_execution_2fexecution_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_execution_2fexecution_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_execution_2fexecution_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_execution_2fexecution_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_execution_2fexecution_2eproto;
namespace execution {
class AssembleBlockRequest;
struct AssembleBlockRequestDefaultTypeInternal;
extern AssembleBlockRequestDefaultTypeInternal _AssembleBlockRequest_default_instance_;
class AssembleBlockResponse;
struct AssembleBlockResponseDefaultTypeInternal;
extern AssembleBlockResponseDefaultTypeInternal _AssembleBlockResponse_default_instance_;
class AssembledBlockData;
struct AssembledBlockDataDefaultTypeInternal;
extern AssembledBlockDataDefaultTypeInternal _AssembledBlockData_default_instance_;
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockBody;
struct BlockBodyDefaultTypeInternal;
extern BlockBodyDefaultTypeInternal _BlockBody_default_instance_;
class ForkChoice;
struct ForkChoiceDefaultTypeInternal;
extern ForkChoiceDefaultTypeInternal _ForkChoice_default_instance_;
class ForkChoiceReceipt;
struct ForkChoiceReceiptDefaultTypeInternal;
extern ForkChoiceReceiptDefaultTypeInternal _ForkChoiceReceipt_default_instance_;
class FrozenBlocksResponse;
struct FrozenBlocksResponseDefaultTypeInternal;
extern FrozenBlocksResponseDefaultTypeInternal _FrozenBlocksResponse_default_instance_;
class GetAssembledBlockRequest;
struct GetAssembledBlockRequestDefaultTypeInternal;
extern GetAssembledBlockRequestDefaultTypeInternal _GetAssembledBlockRequest_default_instance_;
class GetAssembledBlockResponse;
struct GetAssembledBlockResponseDefaultTypeInternal;
extern GetAssembledBlockResponseDefaultTypeInternal _GetAssembledBlockResponse_default_instance_;
class GetBodiesBatchResponse;
struct GetBodiesBatchResponseDefaultTypeInternal;
extern GetBodiesBatchResponseDefaultTypeInternal _GetBodiesBatchResponse_default_instance_;
class GetBodiesByHashesRequest;
struct GetBodiesByHashesRequestDefaultTypeInternal;
extern GetBodiesByHashesRequestDefaultTypeInternal _GetBodiesByHashesRequest_default_instance_;
class GetBodiesByRangeRequest;
struct GetBodiesByRangeRequestDefaultTypeInternal;
extern GetBodiesByRangeRequestDefaultTypeInternal _GetBodiesByRangeRequest_default_instance_;
class GetBodyResponse;
struct GetBodyResponseDefaultTypeInternal;
extern GetBodyResponseDefaultTypeInternal _GetBodyResponse_default_instance_;
class GetHeaderHashNumberResponse;
struct GetHeaderHashNumberResponseDefaultTypeInternal;
extern GetHeaderHashNumberResponseDefaultTypeInternal _GetHeaderHashNumberResponse_default_instance_;
class GetHeaderResponse;
struct GetHeaderResponseDefaultTypeInternal;
extern GetHeaderResponseDefaultTypeInternal _GetHeaderResponse_default_instance_;
class GetSegmentRequest;
struct GetSegmentRequestDefaultTypeInternal;
extern GetSegmentRequestDefaultTypeInternal _GetSegmentRequest_default_instance_;
class GetTDResponse;
struct GetTDResponseDefaultTypeInternal;
extern GetTDResponseDefaultTypeInternal _GetTDResponse_default_instance_;
class HasBlockResponse;
struct HasBlockResponseDefaultTypeInternal;
extern HasBlockResponseDefaultTypeInternal _HasBlockResponse_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class InsertBlocksRequest;
struct InsertBlocksRequestDefaultTypeInternal;
extern InsertBlocksRequestDefaultTypeInternal _InsertBlocksRequest_default_instance_;
class InsertionResult;
struct InsertionResultDefaultTypeInternal;
extern InsertionResultDefaultTypeInternal _InsertionResult_default_instance_;
class IsCanonicalResponse;
struct IsCanonicalResponseDefaultTypeInternal;
extern IsCanonicalResponseDefaultTypeInternal _IsCanonicalResponse_default_instance_;
class ReadyResponse;
struct ReadyResponseDefaultTypeInternal;
extern ReadyResponseDefaultTypeInternal _ReadyResponse_default_instance_;
class ValidationReceipt;
struct ValidationReceiptDefaultTypeInternal;
extern ValidationReceiptDefaultTypeInternal _ValidationReceipt_default_instance_;
class ValidationRequest;
struct ValidationRequestDefaultTypeInternal;
extern ValidationRequestDefaultTypeInternal _ValidationRequest_default_instance_;
}  // namespace execution
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace execution {
enum ExecutionStatus : int {
  Success = 0,
  BadBlock = 1,
  TooFarAway = 2,
  MissingSegment = 3,
  InvalidForkchoice = 4,
  Busy = 5,
  ExecutionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExecutionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExecutionStatus_IsValid(int value);
extern const uint32_t ExecutionStatus_internal_data_[];
constexpr ExecutionStatus ExecutionStatus_MIN = static_cast<ExecutionStatus>(0);
constexpr ExecutionStatus ExecutionStatus_MAX = static_cast<ExecutionStatus>(5);
constexpr int ExecutionStatus_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ExecutionStatus_descriptor();
template <typename T>
const std::string& ExecutionStatus_Name(T value) {
  static_assert(std::is_same<T, ExecutionStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExecutionStatus_Name().");
  return ExecutionStatus_Name(static_cast<ExecutionStatus>(value));
}
template <>
inline const std::string& ExecutionStatus_Name(ExecutionStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExecutionStatus_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ExecutionStatus_Parse(absl::string_view name, ExecutionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecutionStatus>(
      ExecutionStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ReadyResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.ReadyResponse) */ {
 public:
  inline ReadyResponse() : ReadyResponse(nullptr) {}
  ~ReadyResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadyResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadyResponse(const ReadyResponse& from) : ReadyResponse(nullptr, from) {}
  inline ReadyResponse(ReadyResponse&& from) noexcept
      : ReadyResponse(nullptr, std::move(from)) {}
  inline ReadyResponse& operator=(const ReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadyResponse& operator=(ReadyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadyResponse* internal_default_instance() {
    return reinterpret_cast<const ReadyResponse*>(
        &_ReadyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ReadyResponse& a, ReadyResponse& b) { a.Swap(&b); }
  inline void Swap(ReadyResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadyResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadyResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReadyResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadyResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadyResponse& from) { ReadyResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReadyResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.ReadyResponse"; }

 protected:
  explicit ReadyResponse(::google::protobuf::Arena* arena);
  ReadyResponse(::google::protobuf::Arena* arena, const ReadyResponse& from);
  ReadyResponse(::google::protobuf::Arena* arena, ReadyResponse&& from) noexcept
      : ReadyResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReadyFieldNumber = 1,
  };
  // bool ready = 1;
  void clear_ready() ;
  bool ready() const;
  void set_ready(bool value);

  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);

  public:
  // @@protoc_insertion_point(class_scope:execution.ReadyResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ReadyResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadyResponse& from_msg);
    bool ready_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class IsCanonicalResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.IsCanonicalResponse) */ {
 public:
  inline IsCanonicalResponse() : IsCanonicalResponse(nullptr) {}
  ~IsCanonicalResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IsCanonicalResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline IsCanonicalResponse(const IsCanonicalResponse& from) : IsCanonicalResponse(nullptr, from) {}
  inline IsCanonicalResponse(IsCanonicalResponse&& from) noexcept
      : IsCanonicalResponse(nullptr, std::move(from)) {}
  inline IsCanonicalResponse& operator=(const IsCanonicalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsCanonicalResponse& operator=(IsCanonicalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsCanonicalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsCanonicalResponse* internal_default_instance() {
    return reinterpret_cast<const IsCanonicalResponse*>(
        &_IsCanonicalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(IsCanonicalResponse& a, IsCanonicalResponse& b) { a.Swap(&b); }
  inline void Swap(IsCanonicalResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsCanonicalResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsCanonicalResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IsCanonicalResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IsCanonicalResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IsCanonicalResponse& from) { IsCanonicalResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IsCanonicalResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.IsCanonicalResponse"; }

 protected:
  explicit IsCanonicalResponse(::google::protobuf::Arena* arena);
  IsCanonicalResponse(::google::protobuf::Arena* arena, const IsCanonicalResponse& from);
  IsCanonicalResponse(::google::protobuf::Arena* arena, IsCanonicalResponse&& from) noexcept
      : IsCanonicalResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCanonicalFieldNumber = 1,
  };
  // bool canonical = 1;
  void clear_canonical() ;
  bool canonical() const;
  void set_canonical(bool value);

  private:
  bool _internal_canonical() const;
  void _internal_set_canonical(bool value);

  public:
  // @@protoc_insertion_point(class_scope:execution.IsCanonicalResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_IsCanonicalResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IsCanonicalResponse& from_msg);
    bool canonical_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class InsertionResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.InsertionResult) */ {
 public:
  inline InsertionResult() : InsertionResult(nullptr) {}
  ~InsertionResult() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InsertionResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline InsertionResult(const InsertionResult& from) : InsertionResult(nullptr, from) {}
  inline InsertionResult(InsertionResult&& from) noexcept
      : InsertionResult(nullptr, std::move(from)) {}
  inline InsertionResult& operator=(const InsertionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertionResult& operator=(InsertionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertionResult* internal_default_instance() {
    return reinterpret_cast<const InsertionResult*>(
        &_InsertionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(InsertionResult& a, InsertionResult& b) { a.Swap(&b); }
  inline void Swap(InsertionResult* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertionResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertionResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InsertionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InsertionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InsertionResult& from) { InsertionResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InsertionResult* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.InsertionResult"; }

 protected:
  explicit InsertionResult(::google::protobuf::Arena* arena);
  InsertionResult(::google::protobuf::Arena* arena, const InsertionResult& from);
  InsertionResult(::google::protobuf::Arena* arena, InsertionResult&& from) noexcept
      : InsertionResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // .execution.ExecutionStatus result = 1;
  void clear_result() ;
  ::execution::ExecutionStatus result() const;
  void set_result(::execution::ExecutionStatus value);

  private:
  ::execution::ExecutionStatus _internal_result() const;
  void _internal_set_result(::execution::ExecutionStatus value);

  public:
  // @@protoc_insertion_point(class_scope:execution.InsertionResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InsertionResult_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InsertionResult& from_msg);
    int result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class HasBlockResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.HasBlockResponse) */ {
 public:
  inline HasBlockResponse() : HasBlockResponse(nullptr) {}
  ~HasBlockResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HasBlockResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline HasBlockResponse(const HasBlockResponse& from) : HasBlockResponse(nullptr, from) {}
  inline HasBlockResponse(HasBlockResponse&& from) noexcept
      : HasBlockResponse(nullptr, std::move(from)) {}
  inline HasBlockResponse& operator=(const HasBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HasBlockResponse& operator=(HasBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HasBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HasBlockResponse* internal_default_instance() {
    return reinterpret_cast<const HasBlockResponse*>(
        &_HasBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(HasBlockResponse& a, HasBlockResponse& b) { a.Swap(&b); }
  inline void Swap(HasBlockResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HasBlockResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HasBlockResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HasBlockResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HasBlockResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HasBlockResponse& from) { HasBlockResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HasBlockResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.HasBlockResponse"; }

 protected:
  explicit HasBlockResponse(::google::protobuf::Arena* arena);
  HasBlockResponse(::google::protobuf::Arena* arena, const HasBlockResponse& from);
  HasBlockResponse(::google::protobuf::Arena* arena, HasBlockResponse&& from) noexcept
      : HasBlockResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHasBlockFieldNumber = 1,
  };
  // bool has_block = 1;
  void clear_has_block() ;
  bool has_block() const;
  void set_has_block(bool value);

  private:
  bool _internal_has_block() const;
  void _internal_set_has_block(bool value);

  public:
  // @@protoc_insertion_point(class_scope:execution.HasBlockResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HasBlockResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HasBlockResponse& from_msg);
    bool has_block_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetHeaderHashNumberResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetHeaderHashNumberResponse) */ {
 public:
  inline GetHeaderHashNumberResponse() : GetHeaderHashNumberResponse(nullptr) {}
  ~GetHeaderHashNumberResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetHeaderHashNumberResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetHeaderHashNumberResponse(const GetHeaderHashNumberResponse& from) : GetHeaderHashNumberResponse(nullptr, from) {}
  inline GetHeaderHashNumberResponse(GetHeaderHashNumberResponse&& from) noexcept
      : GetHeaderHashNumberResponse(nullptr, std::move(from)) {}
  inline GetHeaderHashNumberResponse& operator=(const GetHeaderHashNumberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHeaderHashNumberResponse& operator=(GetHeaderHashNumberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHeaderHashNumberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHeaderHashNumberResponse* internal_default_instance() {
    return reinterpret_cast<const GetHeaderHashNumberResponse*>(
        &_GetHeaderHashNumberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetHeaderHashNumberResponse& a, GetHeaderHashNumberResponse& b) { a.Swap(&b); }
  inline void Swap(GetHeaderHashNumberResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHeaderHashNumberResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHeaderHashNumberResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetHeaderHashNumberResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetHeaderHashNumberResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetHeaderHashNumberResponse& from) { GetHeaderHashNumberResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetHeaderHashNumberResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetHeaderHashNumberResponse"; }

 protected:
  explicit GetHeaderHashNumberResponse(::google::protobuf::Arena* arena);
  GetHeaderHashNumberResponse(::google::protobuf::Arena* arena, const GetHeaderHashNumberResponse& from);
  GetHeaderHashNumberResponse(::google::protobuf::Arena* arena, GetHeaderHashNumberResponse&& from) noexcept
      : GetHeaderHashNumberResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockNumberFieldNumber = 1,
  };
  // optional uint64 block_number = 1;
  bool has_block_number() const;
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.GetHeaderHashNumberResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetHeaderHashNumberResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetHeaderHashNumberResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t block_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetBodiesByRangeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetBodiesByRangeRequest) */ {
 public:
  inline GetBodiesByRangeRequest() : GetBodiesByRangeRequest(nullptr) {}
  ~GetBodiesByRangeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBodiesByRangeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBodiesByRangeRequest(const GetBodiesByRangeRequest& from) : GetBodiesByRangeRequest(nullptr, from) {}
  inline GetBodiesByRangeRequest(GetBodiesByRangeRequest&& from) noexcept
      : GetBodiesByRangeRequest(nullptr, std::move(from)) {}
  inline GetBodiesByRangeRequest& operator=(const GetBodiesByRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBodiesByRangeRequest& operator=(GetBodiesByRangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBodiesByRangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBodiesByRangeRequest* internal_default_instance() {
    return reinterpret_cast<const GetBodiesByRangeRequest*>(
        &_GetBodiesByRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(GetBodiesByRangeRequest& a, GetBodiesByRangeRequest& b) { a.Swap(&b); }
  inline void Swap(GetBodiesByRangeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBodiesByRangeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBodiesByRangeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetBodiesByRangeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBodiesByRangeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBodiesByRangeRequest& from) { GetBodiesByRangeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetBodiesByRangeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetBodiesByRangeRequest"; }

 protected:
  explicit GetBodiesByRangeRequest(::google::protobuf::Arena* arena);
  GetBodiesByRangeRequest(::google::protobuf::Arena* arena, const GetBodiesByRangeRequest& from);
  GetBodiesByRangeRequest(::google::protobuf::Arena* arena, GetBodiesByRangeRequest&& from) noexcept
      : GetBodiesByRangeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // uint64 start = 1;
  void clear_start() ;
  ::uint64_t start() const;
  void set_start(::uint64_t value);

  private:
  ::uint64_t _internal_start() const;
  void _internal_set_start(::uint64_t value);

  public:
  // uint64 count = 2;
  void clear_count() ;
  ::uint64_t count() const;
  void set_count(::uint64_t value);

  private:
  ::uint64_t _internal_count() const;
  void _internal_set_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.GetBodiesByRangeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetBodiesByRangeRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetBodiesByRangeRequest& from_msg);
    ::uint64_t start_;
    ::uint64_t count_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetAssembledBlockRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetAssembledBlockRequest) */ {
 public:
  inline GetAssembledBlockRequest() : GetAssembledBlockRequest(nullptr) {}
  ~GetAssembledBlockRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetAssembledBlockRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetAssembledBlockRequest(const GetAssembledBlockRequest& from) : GetAssembledBlockRequest(nullptr, from) {}
  inline GetAssembledBlockRequest(GetAssembledBlockRequest&& from) noexcept
      : GetAssembledBlockRequest(nullptr, std::move(from)) {}
  inline GetAssembledBlockRequest& operator=(const GetAssembledBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAssembledBlockRequest& operator=(GetAssembledBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAssembledBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAssembledBlockRequest* internal_default_instance() {
    return reinterpret_cast<const GetAssembledBlockRequest*>(
        &_GetAssembledBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(GetAssembledBlockRequest& a, GetAssembledBlockRequest& b) { a.Swap(&b); }
  inline void Swap(GetAssembledBlockRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAssembledBlockRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAssembledBlockRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetAssembledBlockRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAssembledBlockRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetAssembledBlockRequest& from) { GetAssembledBlockRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetAssembledBlockRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetAssembledBlockRequest"; }

 protected:
  explicit GetAssembledBlockRequest(::google::protobuf::Arena* arena);
  GetAssembledBlockRequest(::google::protobuf::Arena* arena, const GetAssembledBlockRequest& from);
  GetAssembledBlockRequest(::google::protobuf::Arena* arena, GetAssembledBlockRequest&& from) noexcept
      : GetAssembledBlockRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.GetAssembledBlockRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetAssembledBlockRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetAssembledBlockRequest& from_msg);
    ::uint64_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class FrozenBlocksResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.FrozenBlocksResponse) */ {
 public:
  inline FrozenBlocksResponse() : FrozenBlocksResponse(nullptr) {}
  ~FrozenBlocksResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FrozenBlocksResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline FrozenBlocksResponse(const FrozenBlocksResponse& from) : FrozenBlocksResponse(nullptr, from) {}
  inline FrozenBlocksResponse(FrozenBlocksResponse&& from) noexcept
      : FrozenBlocksResponse(nullptr, std::move(from)) {}
  inline FrozenBlocksResponse& operator=(const FrozenBlocksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrozenBlocksResponse& operator=(FrozenBlocksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrozenBlocksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrozenBlocksResponse* internal_default_instance() {
    return reinterpret_cast<const FrozenBlocksResponse*>(
        &_FrozenBlocksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(FrozenBlocksResponse& a, FrozenBlocksResponse& b) { a.Swap(&b); }
  inline void Swap(FrozenBlocksResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrozenBlocksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrozenBlocksResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FrozenBlocksResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FrozenBlocksResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FrozenBlocksResponse& from) { FrozenBlocksResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FrozenBlocksResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.FrozenBlocksResponse"; }

 protected:
  explicit FrozenBlocksResponse(::google::protobuf::Arena* arena);
  FrozenBlocksResponse(::google::protobuf::Arena* arena, const FrozenBlocksResponse& from);
  FrozenBlocksResponse(::google::protobuf::Arena* arena, FrozenBlocksResponse&& from) noexcept
      : FrozenBlocksResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFrozenBlocksFieldNumber = 1,
    kHasGapFieldNumber = 2,
  };
  // uint64 frozen_blocks = 1;
  void clear_frozen_blocks() ;
  ::uint64_t frozen_blocks() const;
  void set_frozen_blocks(::uint64_t value);

  private:
  ::uint64_t _internal_frozen_blocks() const;
  void _internal_set_frozen_blocks(::uint64_t value);

  public:
  // bool has_gap = 2;
  void clear_has_gap() ;
  bool has_gap() const;
  void set_has_gap(bool value);

  private:
  bool _internal_has_gap() const;
  void _internal_set_has_gap(bool value);

  public:
  // @@protoc_insertion_point(class_scope:execution.FrozenBlocksResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FrozenBlocksResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FrozenBlocksResponse& from_msg);
    ::uint64_t frozen_blocks_;
    bool has_gap_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class AssembleBlockResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.AssembleBlockResponse) */ {
 public:
  inline AssembleBlockResponse() : AssembleBlockResponse(nullptr) {}
  ~AssembleBlockResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssembleBlockResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssembleBlockResponse(const AssembleBlockResponse& from) : AssembleBlockResponse(nullptr, from) {}
  inline AssembleBlockResponse(AssembleBlockResponse&& from) noexcept
      : AssembleBlockResponse(nullptr, std::move(from)) {}
  inline AssembleBlockResponse& operator=(const AssembleBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssembleBlockResponse& operator=(AssembleBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssembleBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssembleBlockResponse* internal_default_instance() {
    return reinterpret_cast<const AssembleBlockResponse*>(
        &_AssembleBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(AssembleBlockResponse& a, AssembleBlockResponse& b) { a.Swap(&b); }
  inline void Swap(AssembleBlockResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssembleBlockResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssembleBlockResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AssembleBlockResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssembleBlockResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssembleBlockResponse& from) { AssembleBlockResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssembleBlockResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.AssembleBlockResponse"; }

 protected:
  explicit AssembleBlockResponse(::google::protobuf::Arena* arena);
  AssembleBlockResponse(::google::protobuf::Arena* arena, const AssembleBlockResponse& from);
  AssembleBlockResponse(::google::protobuf::Arena* arena, AssembleBlockResponse&& from) noexcept
      : AssembleBlockResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kBusyFieldNumber = 2,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // bool busy = 2;
  void clear_busy() ;
  bool busy() const;
  void set_busy(bool value);

  private:
  bool _internal_busy() const;
  void _internal_set_busy(bool value);

  public:
  // @@protoc_insertion_point(class_scope:execution.AssembleBlockResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AssembleBlockResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssembleBlockResponse& from_msg);
    ::uint64_t id_;
    bool busy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ValidationRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.ValidationRequest) */ {
 public:
  inline ValidationRequest() : ValidationRequest(nullptr) {}
  ~ValidationRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidationRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ValidationRequest(const ValidationRequest& from) : ValidationRequest(nullptr, from) {}
  inline ValidationRequest(ValidationRequest&& from) noexcept
      : ValidationRequest(nullptr, std::move(from)) {}
  inline ValidationRequest& operator=(const ValidationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidationRequest& operator=(ValidationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidationRequest* internal_default_instance() {
    return reinterpret_cast<const ValidationRequest*>(
        &_ValidationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ValidationRequest& a, ValidationRequest& b) { a.Swap(&b); }
  inline void Swap(ValidationRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ValidationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValidationRequest& from) { ValidationRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValidationRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.ValidationRequest"; }

 protected:
  explicit ValidationRequest(::google::protobuf::Arena* arena);
  ValidationRequest(::google::protobuf::Arena* arena, const ValidationRequest& from);
  ValidationRequest(::google::protobuf::Arena* arena, ValidationRequest&& from) noexcept
      : ValidationRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHashFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // .types.H256 hash = 1;
  bool has_hash() const;
  void clear_hash() ;
  const ::types::H256& hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_hash();
  ::types::H256* mutable_hash();
  void set_allocated_hash(::types::H256* value);
  void unsafe_arena_set_allocated_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_hash();

  private:
  const ::types::H256& _internal_hash() const;
  ::types::H256* _internal_mutable_hash();

  public:
  // uint64 number = 2;
  void clear_number() ;
  ::uint64_t number() const;
  void set_number(::uint64_t value);

  private:
  ::uint64_t _internal_number() const;
  void _internal_set_number(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.ValidationRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ValidationRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ValidationRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H256* hash_;
    ::uint64_t number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ValidationReceipt final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.ValidationReceipt) */ {
 public:
  inline ValidationReceipt() : ValidationReceipt(nullptr) {}
  ~ValidationReceipt() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidationReceipt(
      ::google::protobuf::internal::ConstantInitialized);

  inline ValidationReceipt(const ValidationReceipt& from) : ValidationReceipt(nullptr, from) {}
  inline ValidationReceipt(ValidationReceipt&& from) noexcept
      : ValidationReceipt(nullptr, std::move(from)) {}
  inline ValidationReceipt& operator=(const ValidationReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidationReceipt& operator=(ValidationReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidationReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidationReceipt* internal_default_instance() {
    return reinterpret_cast<const ValidationReceipt*>(
        &_ValidationReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ValidationReceipt& a, ValidationReceipt& b) { a.Swap(&b); }
  inline void Swap(ValidationReceipt* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidationReceipt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidationReceipt* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ValidationReceipt>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidationReceipt& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValidationReceipt& from) { ValidationReceipt::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValidationReceipt* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.ValidationReceipt"; }

 protected:
  explicit ValidationReceipt(::google::protobuf::Arena* arena);
  ValidationReceipt(::google::protobuf::Arena* arena, const ValidationReceipt& from);
  ValidationReceipt(::google::protobuf::Arena* arena, ValidationReceipt&& from) noexcept
      : ValidationReceipt(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValidationErrorFieldNumber = 3,
    kLatestValidHashFieldNumber = 2,
    kValidationStatusFieldNumber = 1,
  };
  // string validation_error = 3;
  void clear_validation_error() ;
  const std::string& validation_error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validation_error(Arg_&& arg, Args_... args);
  std::string* mutable_validation_error();
  PROTOBUF_NODISCARD std::string* release_validation_error();
  void set_allocated_validation_error(std::string* value);

  private:
  const std::string& _internal_validation_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validation_error(
      const std::string& value);
  std::string* _internal_mutable_validation_error();

  public:
  // .types.H256 latest_valid_hash = 2;
  bool has_latest_valid_hash() const;
  void clear_latest_valid_hash() ;
  const ::types::H256& latest_valid_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_latest_valid_hash();
  ::types::H256* mutable_latest_valid_hash();
  void set_allocated_latest_valid_hash(::types::H256* value);
  void unsafe_arena_set_allocated_latest_valid_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_latest_valid_hash();

  private:
  const ::types::H256& _internal_latest_valid_hash() const;
  ::types::H256* _internal_mutable_latest_valid_hash();

  public:
  // .execution.ExecutionStatus validation_status = 1;
  void clear_validation_status() ;
  ::execution::ExecutionStatus validation_status() const;
  void set_validation_status(::execution::ExecutionStatus value);

  private:
  ::execution::ExecutionStatus _internal_validation_status() const;
  void _internal_set_validation_status(::execution::ExecutionStatus value);

  public:
  // @@protoc_insertion_point(class_scope:execution.ValidationReceipt)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      52, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ValidationReceipt_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ValidationReceipt& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr validation_error_;
    ::types::H256* latest_valid_hash_;
    int validation_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetTDResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetTDResponse) */ {
 public:
  inline GetTDResponse() : GetTDResponse(nullptr) {}
  ~GetTDResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTDResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTDResponse(const GetTDResponse& from) : GetTDResponse(nullptr, from) {}
  inline GetTDResponse(GetTDResponse&& from) noexcept
      : GetTDResponse(nullptr, std::move(from)) {}
  inline GetTDResponse& operator=(const GetTDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTDResponse& operator=(GetTDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTDResponse* internal_default_instance() {
    return reinterpret_cast<const GetTDResponse*>(
        &_GetTDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(GetTDResponse& a, GetTDResponse& b) { a.Swap(&b); }
  inline void Swap(GetTDResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTDResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTDResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetTDResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTDResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTDResponse& from) { GetTDResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTDResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetTDResponse"; }

 protected:
  explicit GetTDResponse(::google::protobuf::Arena* arena);
  GetTDResponse(::google::protobuf::Arena* arena, const GetTDResponse& from);
  GetTDResponse(::google::protobuf::Arena* arena, GetTDResponse&& from) noexcept
      : GetTDResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTdFieldNumber = 1,
  };
  // optional .types.H256 td = 1;
  bool has_td() const;
  void clear_td() ;
  const ::types::H256& td() const;
  PROTOBUF_NODISCARD ::types::H256* release_td();
  ::types::H256* mutable_td();
  void set_allocated_td(::types::H256* value);
  void unsafe_arena_set_allocated_td(::types::H256* value);
  ::types::H256* unsafe_arena_release_td();

  private:
  const ::types::H256& _internal_td() const;
  ::types::H256* _internal_mutable_td();

  public:
  // @@protoc_insertion_point(class_scope:execution.GetTDResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetTDResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTDResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H256* td_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetSegmentRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetSegmentRequest) */ {
 public:
  inline GetSegmentRequest() : GetSegmentRequest(nullptr) {}
  ~GetSegmentRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSegmentRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetSegmentRequest(const GetSegmentRequest& from) : GetSegmentRequest(nullptr, from) {}
  inline GetSegmentRequest(GetSegmentRequest&& from) noexcept
      : GetSegmentRequest(nullptr, std::move(from)) {}
  inline GetSegmentRequest& operator=(const GetSegmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSegmentRequest& operator=(GetSegmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSegmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSegmentRequest* internal_default_instance() {
    return reinterpret_cast<const GetSegmentRequest*>(
        &_GetSegmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GetSegmentRequest& a, GetSegmentRequest& b) { a.Swap(&b); }
  inline void Swap(GetSegmentRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSegmentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSegmentRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetSegmentRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSegmentRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetSegmentRequest& from) { GetSegmentRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetSegmentRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetSegmentRequest"; }

 protected:
  explicit GetSegmentRequest(::google::protobuf::Arena* arena);
  GetSegmentRequest(::google::protobuf::Arena* arena, const GetSegmentRequest& from);
  GetSegmentRequest(::google::protobuf::Arena* arena, GetSegmentRequest&& from) noexcept
      : GetSegmentRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockHashFieldNumber = 2,
    kBlockNumberFieldNumber = 1,
  };
  // optional .types.H256 block_hash = 2;
  bool has_block_hash() const;
  void clear_block_hash() ;
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* value);
  void unsafe_arena_set_allocated_block_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_block_hash();

  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();

  public:
  // optional uint64 block_number = 1;
  bool has_block_number() const;
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.GetSegmentRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetSegmentRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetSegmentRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H256* block_hash_;
    ::uint64_t block_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetBodiesByHashesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetBodiesByHashesRequest) */ {
 public:
  inline GetBodiesByHashesRequest() : GetBodiesByHashesRequest(nullptr) {}
  ~GetBodiesByHashesRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBodiesByHashesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBodiesByHashesRequest(const GetBodiesByHashesRequest& from) : GetBodiesByHashesRequest(nullptr, from) {}
  inline GetBodiesByHashesRequest(GetBodiesByHashesRequest&& from) noexcept
      : GetBodiesByHashesRequest(nullptr, std::move(from)) {}
  inline GetBodiesByHashesRequest& operator=(const GetBodiesByHashesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBodiesByHashesRequest& operator=(GetBodiesByHashesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBodiesByHashesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBodiesByHashesRequest* internal_default_instance() {
    return reinterpret_cast<const GetBodiesByHashesRequest*>(
        &_GetBodiesByHashesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(GetBodiesByHashesRequest& a, GetBodiesByHashesRequest& b) { a.Swap(&b); }
  inline void Swap(GetBodiesByHashesRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBodiesByHashesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBodiesByHashesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetBodiesByHashesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBodiesByHashesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBodiesByHashesRequest& from) { GetBodiesByHashesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetBodiesByHashesRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetBodiesByHashesRequest"; }

 protected:
  explicit GetBodiesByHashesRequest(::google::protobuf::Arena* arena);
  GetBodiesByHashesRequest(::google::protobuf::Arena* arena, const GetBodiesByHashesRequest& from);
  GetBodiesByHashesRequest(::google::protobuf::Arena* arena, GetBodiesByHashesRequest&& from) noexcept
      : GetBodiesByHashesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHashesFieldNumber = 1,
  };
  // repeated .types.H256 hashes = 1;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;

  public:
  void clear_hashes() ;
  ::types::H256* mutable_hashes(int index);
  ::google::protobuf::RepeatedPtrField<::types::H256>* mutable_hashes();

  private:
  const ::google::protobuf::RepeatedPtrField<::types::H256>& _internal_hashes() const;
  ::google::protobuf::RepeatedPtrField<::types::H256>* _internal_mutable_hashes();
  public:
  const ::types::H256& hashes(int index) const;
  ::types::H256* add_hashes();
  const ::google::protobuf::RepeatedPtrField<::types::H256>& hashes() const;
  // @@protoc_insertion_point(class_scope:execution.GetBodiesByHashesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetBodiesByHashesRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetBodiesByHashesRequest& from_msg);
    ::google::protobuf::RepeatedPtrField< ::types::H256 > hashes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ForkChoiceReceipt final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.ForkChoiceReceipt) */ {
 public:
  inline ForkChoiceReceipt() : ForkChoiceReceipt(nullptr) {}
  ~ForkChoiceReceipt() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ForkChoiceReceipt(
      ::google::protobuf::internal::ConstantInitialized);

  inline ForkChoiceReceipt(const ForkChoiceReceipt& from) : ForkChoiceReceipt(nullptr, from) {}
  inline ForkChoiceReceipt(ForkChoiceReceipt&& from) noexcept
      : ForkChoiceReceipt(nullptr, std::move(from)) {}
  inline ForkChoiceReceipt& operator=(const ForkChoiceReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForkChoiceReceipt& operator=(ForkChoiceReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForkChoiceReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForkChoiceReceipt* internal_default_instance() {
    return reinterpret_cast<const ForkChoiceReceipt*>(
        &_ForkChoiceReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ForkChoiceReceipt& a, ForkChoiceReceipt& b) { a.Swap(&b); }
  inline void Swap(ForkChoiceReceipt* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForkChoiceReceipt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForkChoiceReceipt* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ForkChoiceReceipt>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ForkChoiceReceipt& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ForkChoiceReceipt& from) { ForkChoiceReceipt::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ForkChoiceReceipt* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.ForkChoiceReceipt"; }

 protected:
  explicit ForkChoiceReceipt(::google::protobuf::Arena* arena);
  ForkChoiceReceipt(::google::protobuf::Arena* arena, const ForkChoiceReceipt& from);
  ForkChoiceReceipt(::google::protobuf::Arena* arena, ForkChoiceReceipt&& from) noexcept
      : ForkChoiceReceipt(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValidationErrorFieldNumber = 3,
    kLatestValidHashFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string validation_error = 3;
  void clear_validation_error() ;
  const std::string& validation_error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validation_error(Arg_&& arg, Args_... args);
  std::string* mutable_validation_error();
  PROTOBUF_NODISCARD std::string* release_validation_error();
  void set_allocated_validation_error(std::string* value);

  private:
  const std::string& _internal_validation_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validation_error(
      const std::string& value);
  std::string* _internal_mutable_validation_error();

  public:
  // .types.H256 latest_valid_hash = 2;
  bool has_latest_valid_hash() const;
  void clear_latest_valid_hash() ;
  const ::types::H256& latest_valid_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_latest_valid_hash();
  ::types::H256* mutable_latest_valid_hash();
  void set_allocated_latest_valid_hash(::types::H256* value);
  void unsafe_arena_set_allocated_latest_valid_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_latest_valid_hash();

  private:
  const ::types::H256& _internal_latest_valid_hash() const;
  ::types::H256* _internal_mutable_latest_valid_hash();

  public:
  // .execution.ExecutionStatus status = 1;
  void clear_status() ;
  ::execution::ExecutionStatus status() const;
  void set_status(::execution::ExecutionStatus value);

  private:
  ::execution::ExecutionStatus _internal_status() const;
  void _internal_set_status(::execution::ExecutionStatus value);

  public:
  // @@protoc_insertion_point(class_scope:execution.ForkChoiceReceipt)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      52, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ForkChoiceReceipt_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ForkChoiceReceipt& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr validation_error_;
    ::types::H256* latest_valid_hash_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class ForkChoice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.ForkChoice) */ {
 public:
  inline ForkChoice() : ForkChoice(nullptr) {}
  ~ForkChoice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ForkChoice(
      ::google::protobuf::internal::ConstantInitialized);

  inline ForkChoice(const ForkChoice& from) : ForkChoice(nullptr, from) {}
  inline ForkChoice(ForkChoice&& from) noexcept
      : ForkChoice(nullptr, std::move(from)) {}
  inline ForkChoice& operator=(const ForkChoice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForkChoice& operator=(ForkChoice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForkChoice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForkChoice* internal_default_instance() {
    return reinterpret_cast<const ForkChoice*>(
        &_ForkChoice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ForkChoice& a, ForkChoice& b) { a.Swap(&b); }
  inline void Swap(ForkChoice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForkChoice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForkChoice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ForkChoice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ForkChoice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ForkChoice& from) { ForkChoice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ForkChoice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.ForkChoice"; }

 protected:
  explicit ForkChoice(::google::protobuf::Arena* arena);
  ForkChoice(::google::protobuf::Arena* arena, const ForkChoice& from);
  ForkChoice(::google::protobuf::Arena* arena, ForkChoice&& from) noexcept
      : ForkChoice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeadBlockHashFieldNumber = 1,
    kFinalizedBlockHashFieldNumber = 3,
    kSafeBlockHashFieldNumber = 4,
    kTimeoutFieldNumber = 2,
  };
  // .types.H256 head_block_hash = 1;
  bool has_head_block_hash() const;
  void clear_head_block_hash() ;
  const ::types::H256& head_block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_head_block_hash();
  ::types::H256* mutable_head_block_hash();
  void set_allocated_head_block_hash(::types::H256* value);
  void unsafe_arena_set_allocated_head_block_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_head_block_hash();

  private:
  const ::types::H256& _internal_head_block_hash() const;
  ::types::H256* _internal_mutable_head_block_hash();

  public:
  // optional .types.H256 finalized_block_hash = 3;
  bool has_finalized_block_hash() const;
  void clear_finalized_block_hash() ;
  const ::types::H256& finalized_block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_finalized_block_hash();
  ::types::H256* mutable_finalized_block_hash();
  void set_allocated_finalized_block_hash(::types::H256* value);
  void unsafe_arena_set_allocated_finalized_block_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_finalized_block_hash();

  private:
  const ::types::H256& _internal_finalized_block_hash() const;
  ::types::H256* _internal_mutable_finalized_block_hash();

  public:
  // optional .types.H256 safe_block_hash = 4;
  bool has_safe_block_hash() const;
  void clear_safe_block_hash() ;
  const ::types::H256& safe_block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_safe_block_hash();
  ::types::H256* mutable_safe_block_hash();
  void set_allocated_safe_block_hash(::types::H256* value);
  void unsafe_arena_set_allocated_safe_block_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_safe_block_hash();

  private:
  const ::types::H256& _internal_safe_block_hash() const;
  ::types::H256* _internal_mutable_safe_block_hash();

  public:
  // uint64 timeout = 2;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.ForkChoice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ForkChoice_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ForkChoice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H256* head_block_hash_;
    ::types::H256* finalized_block_hash_;
    ::types::H256* safe_block_hash_;
    ::uint64_t timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class AssembleBlockRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.AssembleBlockRequest) */ {
 public:
  inline AssembleBlockRequest() : AssembleBlockRequest(nullptr) {}
  ~AssembleBlockRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssembleBlockRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssembleBlockRequest(const AssembleBlockRequest& from) : AssembleBlockRequest(nullptr, from) {}
  inline AssembleBlockRequest(AssembleBlockRequest&& from) noexcept
      : AssembleBlockRequest(nullptr, std::move(from)) {}
  inline AssembleBlockRequest& operator=(const AssembleBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssembleBlockRequest& operator=(AssembleBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssembleBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssembleBlockRequest* internal_default_instance() {
    return reinterpret_cast<const AssembleBlockRequest*>(
        &_AssembleBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(AssembleBlockRequest& a, AssembleBlockRequest& b) { a.Swap(&b); }
  inline void Swap(AssembleBlockRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssembleBlockRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssembleBlockRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AssembleBlockRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssembleBlockRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssembleBlockRequest& from) { AssembleBlockRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssembleBlockRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.AssembleBlockRequest"; }

 protected:
  explicit AssembleBlockRequest(::google::protobuf::Arena* arena);
  AssembleBlockRequest(::google::protobuf::Arena* arena, const AssembleBlockRequest& from);
  AssembleBlockRequest(::google::protobuf::Arena* arena, AssembleBlockRequest&& from) noexcept
      : AssembleBlockRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWithdrawalsFieldNumber = 5,
    kParentHashFieldNumber = 1,
    kPrevRandaoFieldNumber = 3,
    kSuggestedFeeRecipientFieldNumber = 4,
    kParentBeaconBlockRootFieldNumber = 6,
    kTimestampFieldNumber = 2,
  };
  // repeated .types.Withdrawal withdrawals = 5;
  int withdrawals_size() const;
  private:
  int _internal_withdrawals_size() const;

  public:
  void clear_withdrawals() ;
  ::types::Withdrawal* mutable_withdrawals(int index);
  ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* mutable_withdrawals();

  private:
  const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& _internal_withdrawals() const;
  ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* _internal_mutable_withdrawals();
  public:
  const ::types::Withdrawal& withdrawals(int index) const;
  ::types::Withdrawal* add_withdrawals();
  const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& withdrawals() const;
  // .types.H256 parent_hash = 1;
  bool has_parent_hash() const;
  void clear_parent_hash() ;
  const ::types::H256& parent_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_parent_hash();
  ::types::H256* mutable_parent_hash();
  void set_allocated_parent_hash(::types::H256* value);
  void unsafe_arena_set_allocated_parent_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_parent_hash();

  private:
  const ::types::H256& _internal_parent_hash() const;
  ::types::H256* _internal_mutable_parent_hash();

  public:
  // .types.H256 prev_randao = 3;
  bool has_prev_randao() const;
  void clear_prev_randao() ;
  const ::types::H256& prev_randao() const;
  PROTOBUF_NODISCARD ::types::H256* release_prev_randao();
  ::types::H256* mutable_prev_randao();
  void set_allocated_prev_randao(::types::H256* value);
  void unsafe_arena_set_allocated_prev_randao(::types::H256* value);
  ::types::H256* unsafe_arena_release_prev_randao();

  private:
  const ::types::H256& _internal_prev_randao() const;
  ::types::H256* _internal_mutable_prev_randao();

  public:
  // .types.H160 suggested_fee_recipient = 4;
  bool has_suggested_fee_recipient() const;
  void clear_suggested_fee_recipient() ;
  const ::types::H160& suggested_fee_recipient() const;
  PROTOBUF_NODISCARD ::types::H160* release_suggested_fee_recipient();
  ::types::H160* mutable_suggested_fee_recipient();
  void set_allocated_suggested_fee_recipient(::types::H160* value);
  void unsafe_arena_set_allocated_suggested_fee_recipient(::types::H160* value);
  ::types::H160* unsafe_arena_release_suggested_fee_recipient();

  private:
  const ::types::H160& _internal_suggested_fee_recipient() const;
  ::types::H160* _internal_mutable_suggested_fee_recipient();

  public:
  // optional .types.H256 parent_beacon_block_root = 6;
  bool has_parent_beacon_block_root() const;
  void clear_parent_beacon_block_root() ;
  const ::types::H256& parent_beacon_block_root() const;
  PROTOBUF_NODISCARD ::types::H256* release_parent_beacon_block_root();
  ::types::H256* mutable_parent_beacon_block_root();
  void set_allocated_parent_beacon_block_root(::types::H256* value);
  void unsafe_arena_set_allocated_parent_beacon_block_root(::types::H256* value);
  ::types::H256* unsafe_arena_release_parent_beacon_block_root();

  private:
  const ::types::H256& _internal_parent_beacon_block_root() const;
  ::types::H256* _internal_mutable_parent_beacon_block_root();

  public:
  // uint64 timestamp = 2;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.AssembleBlockRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AssembleBlockRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssembleBlockRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::types::Withdrawal > withdrawals_;
    ::types::H256* parent_hash_;
    ::types::H256* prev_randao_;
    ::types::H160* suggested_fee_recipient_;
    ::types::H256* parent_beacon_block_root_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class Header final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Header(
      ::google::protobuf::internal::ConstantInitialized);

  inline Header(const Header& from) : Header(nullptr, from) {}
  inline Header(Header&& from) noexcept
      : Header(nullptr, std::move(from)) {}
  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
        &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Header& a, Header& b) { a.Swap(&b); }
  inline void Swap(Header* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Header>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Header& from) { Header::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Header* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.Header"; }

 protected:
  explicit Header(::google::protobuf::Arena* arena);
  Header(::google::protobuf::Arena* arena, const Header& from);
  Header(::google::protobuf::Arena* arena, Header&& from) noexcept
      : Header(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtraDataFieldNumber = 12,
    kAuraSealFieldNumber = 24,
    kParentHashFieldNumber = 1,
    kCoinbaseFieldNumber = 2,
    kStateRootFieldNumber = 3,
    kReceiptRootFieldNumber = 4,
    kLogsBloomFieldNumber = 5,
    kPrevRandaoFieldNumber = 6,
    kDifficultyFieldNumber = 13,
    kBlockHashFieldNumber = 14,
    kOmmerHashFieldNumber = 15,
    kTransactionHashFieldNumber = 16,
    kBaseFeePerGasFieldNumber = 17,
    kWithdrawalHashFieldNumber = 18,
    kParentBeaconBlockRootFieldNumber = 21,
    kRequestsHashFieldNumber = 22,
    kBlockNumberFieldNumber = 7,
    kGasLimitFieldNumber = 8,
    kGasUsedFieldNumber = 9,
    kTimestampFieldNumber = 10,
    kNonceFieldNumber = 11,
    kBlobGasUsedFieldNumber = 19,
    kExcessBlobGasFieldNumber = 20,
    kAuraStepFieldNumber = 23,
  };
  // bytes extra_data = 12;
  void clear_extra_data() ;
  const std::string& extra_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extra_data(Arg_&& arg, Args_... args);
  std::string* mutable_extra_data();
  PROTOBUF_NODISCARD std::string* release_extra_data();
  void set_allocated_extra_data(std::string* value);

  private:
  const std::string& _internal_extra_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_data(
      const std::string& value);
  std::string* _internal_mutable_extra_data();

  public:
  // optional bytes aura_seal = 24;
  bool has_aura_seal() const;
  void clear_aura_seal() ;
  const std::string& aura_seal() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aura_seal(Arg_&& arg, Args_... args);
  std::string* mutable_aura_seal();
  PROTOBUF_NODISCARD std::string* release_aura_seal();
  void set_allocated_aura_seal(std::string* value);

  private:
  const std::string& _internal_aura_seal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aura_seal(
      const std::string& value);
  std::string* _internal_mutable_aura_seal();

  public:
  // .types.H256 parent_hash = 1;
  bool has_parent_hash() const;
  void clear_parent_hash() ;
  const ::types::H256& parent_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_parent_hash();
  ::types::H256* mutable_parent_hash();
  void set_allocated_parent_hash(::types::H256* value);
  void unsafe_arena_set_allocated_parent_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_parent_hash();

  private:
  const ::types::H256& _internal_parent_hash() const;
  ::types::H256* _internal_mutable_parent_hash();

  public:
  // .types.H160 coinbase = 2;
  bool has_coinbase() const;
  void clear_coinbase() ;
  const ::types::H160& coinbase() const;
  PROTOBUF_NODISCARD ::types::H160* release_coinbase();
  ::types::H160* mutable_coinbase();
  void set_allocated_coinbase(::types::H160* value);
  void unsafe_arena_set_allocated_coinbase(::types::H160* value);
  ::types::H160* unsafe_arena_release_coinbase();

  private:
  const ::types::H160& _internal_coinbase() const;
  ::types::H160* _internal_mutable_coinbase();

  public:
  // .types.H256 state_root = 3;
  bool has_state_root() const;
  void clear_state_root() ;
  const ::types::H256& state_root() const;
  PROTOBUF_NODISCARD ::types::H256* release_state_root();
  ::types::H256* mutable_state_root();
  void set_allocated_state_root(::types::H256* value);
  void unsafe_arena_set_allocated_state_root(::types::H256* value);
  ::types::H256* unsafe_arena_release_state_root();

  private:
  const ::types::H256& _internal_state_root() const;
  ::types::H256* _internal_mutable_state_root();

  public:
  // .types.H256 receipt_root = 4;
  bool has_receipt_root() const;
  void clear_receipt_root() ;
  const ::types::H256& receipt_root() const;
  PROTOBUF_NODISCARD ::types::H256* release_receipt_root();
  ::types::H256* mutable_receipt_root();
  void set_allocated_receipt_root(::types::H256* value);
  void unsafe_arena_set_allocated_receipt_root(::types::H256* value);
  ::types::H256* unsafe_arena_release_receipt_root();

  private:
  const ::types::H256& _internal_receipt_root() const;
  ::types::H256* _internal_mutable_receipt_root();

  public:
  // .types.H2048 logs_bloom = 5;
  bool has_logs_bloom() const;
  void clear_logs_bloom() ;
  const ::types::H2048& logs_bloom() const;
  PROTOBUF_NODISCARD ::types::H2048* release_logs_bloom();
  ::types::H2048* mutable_logs_bloom();
  void set_allocated_logs_bloom(::types::H2048* value);
  void unsafe_arena_set_allocated_logs_bloom(::types::H2048* value);
  ::types::H2048* unsafe_arena_release_logs_bloom();

  private:
  const ::types::H2048& _internal_logs_bloom() const;
  ::types::H2048* _internal_mutable_logs_bloom();

  public:
  // .types.H256 prev_randao = 6;
  bool has_prev_randao() const;
  void clear_prev_randao() ;
  const ::types::H256& prev_randao() const;
  PROTOBUF_NODISCARD ::types::H256* release_prev_randao();
  ::types::H256* mutable_prev_randao();
  void set_allocated_prev_randao(::types::H256* value);
  void unsafe_arena_set_allocated_prev_randao(::types::H256* value);
  ::types::H256* unsafe_arena_release_prev_randao();

  private:
  const ::types::H256& _internal_prev_randao() const;
  ::types::H256* _internal_mutable_prev_randao();

  public:
  // .types.H256 difficulty = 13;
  bool has_difficulty() const;
  void clear_difficulty() ;
  const ::types::H256& difficulty() const;
  PROTOBUF_NODISCARD ::types::H256* release_difficulty();
  ::types::H256* mutable_difficulty();
  void set_allocated_difficulty(::types::H256* value);
  void unsafe_arena_set_allocated_difficulty(::types::H256* value);
  ::types::H256* unsafe_arena_release_difficulty();

  private:
  const ::types::H256& _internal_difficulty() const;
  ::types::H256* _internal_mutable_difficulty();

  public:
  // .types.H256 block_hash = 14;
  bool has_block_hash() const;
  void clear_block_hash() ;
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* value);
  void unsafe_arena_set_allocated_block_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_block_hash();

  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();

  public:
  // .types.H256 ommer_hash = 15;
  bool has_ommer_hash() const;
  void clear_ommer_hash() ;
  const ::types::H256& ommer_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_ommer_hash();
  ::types::H256* mutable_ommer_hash();
  void set_allocated_ommer_hash(::types::H256* value);
  void unsafe_arena_set_allocated_ommer_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_ommer_hash();

  private:
  const ::types::H256& _internal_ommer_hash() const;
  ::types::H256* _internal_mutable_ommer_hash();

  public:
  // .types.H256 transaction_hash = 16;
  bool has_transaction_hash() const;
  void clear_transaction_hash() ;
  const ::types::H256& transaction_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_transaction_hash();
  ::types::H256* mutable_transaction_hash();
  void set_allocated_transaction_hash(::types::H256* value);
  void unsafe_arena_set_allocated_transaction_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_transaction_hash();

  private:
  const ::types::H256& _internal_transaction_hash() const;
  ::types::H256* _internal_mutable_transaction_hash();

  public:
  // optional .types.H256 base_fee_per_gas = 17;
  bool has_base_fee_per_gas() const;
  void clear_base_fee_per_gas() ;
  const ::types::H256& base_fee_per_gas() const;
  PROTOBUF_NODISCARD ::types::H256* release_base_fee_per_gas();
  ::types::H256* mutable_base_fee_per_gas();
  void set_allocated_base_fee_per_gas(::types::H256* value);
  void unsafe_arena_set_allocated_base_fee_per_gas(::types::H256* value);
  ::types::H256* unsafe_arena_release_base_fee_per_gas();

  private:
  const ::types::H256& _internal_base_fee_per_gas() const;
  ::types::H256* _internal_mutable_base_fee_per_gas();

  public:
  // optional .types.H256 withdrawal_hash = 18;
  bool has_withdrawal_hash() const;
  void clear_withdrawal_hash() ;
  const ::types::H256& withdrawal_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_withdrawal_hash();
  ::types::H256* mutable_withdrawal_hash();
  void set_allocated_withdrawal_hash(::types::H256* value);
  void unsafe_arena_set_allocated_withdrawal_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_withdrawal_hash();

  private:
  const ::types::H256& _internal_withdrawal_hash() const;
  ::types::H256* _internal_mutable_withdrawal_hash();

  public:
  // optional .types.H256 parent_beacon_block_root = 21;
  bool has_parent_beacon_block_root() const;
  void clear_parent_beacon_block_root() ;
  const ::types::H256& parent_beacon_block_root() const;
  PROTOBUF_NODISCARD ::types::H256* release_parent_beacon_block_root();
  ::types::H256* mutable_parent_beacon_block_root();
  void set_allocated_parent_beacon_block_root(::types::H256* value);
  void unsafe_arena_set_allocated_parent_beacon_block_root(::types::H256* value);
  ::types::H256* unsafe_arena_release_parent_beacon_block_root();

  private:
  const ::types::H256& _internal_parent_beacon_block_root() const;
  ::types::H256* _internal_mutable_parent_beacon_block_root();

  public:
  // optional .types.H256 requests_hash = 22;
  bool has_requests_hash() const;
  void clear_requests_hash() ;
  const ::types::H256& requests_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_requests_hash();
  ::types::H256* mutable_requests_hash();
  void set_allocated_requests_hash(::types::H256* value);
  void unsafe_arena_set_allocated_requests_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_requests_hash();

  private:
  const ::types::H256& _internal_requests_hash() const;
  ::types::H256* _internal_mutable_requests_hash();

  public:
  // uint64 block_number = 7;
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // uint64 gas_limit = 8;
  void clear_gas_limit() ;
  ::uint64_t gas_limit() const;
  void set_gas_limit(::uint64_t value);

  private:
  ::uint64_t _internal_gas_limit() const;
  void _internal_set_gas_limit(::uint64_t value);

  public:
  // uint64 gas_used = 9;
  void clear_gas_used() ;
  ::uint64_t gas_used() const;
  void set_gas_used(::uint64_t value);

  private:
  ::uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(::uint64_t value);

  public:
  // uint64 timestamp = 10;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint64 nonce = 11;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // optional uint64 blob_gas_used = 19;
  bool has_blob_gas_used() const;
  void clear_blob_gas_used() ;
  ::uint64_t blob_gas_used() const;
  void set_blob_gas_used(::uint64_t value);

  private:
  ::uint64_t _internal_blob_gas_used() const;
  void _internal_set_blob_gas_used(::uint64_t value);

  public:
  // optional uint64 excess_blob_gas = 20;
  bool has_excess_blob_gas() const;
  void clear_excess_blob_gas() ;
  ::uint64_t excess_blob_gas() const;
  void set_excess_blob_gas(::uint64_t value);

  private:
  ::uint64_t _internal_excess_blob_gas() const;
  void _internal_set_excess_blob_gas(::uint64_t value);

  public:
  // optional uint64 aura_step = 23;
  bool has_aura_step() const;
  void clear_aura_step() ;
  ::uint64_t aura_step() const;
  void set_aura_step(::uint64_t value);

  private:
  ::uint64_t _internal_aura_step() const;
  void _internal_set_aura_step(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.Header)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 24, 14,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Header_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Header& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr extra_data_;
    ::google::protobuf::internal::ArenaStringPtr aura_seal_;
    ::types::H256* parent_hash_;
    ::types::H160* coinbase_;
    ::types::H256* state_root_;
    ::types::H256* receipt_root_;
    ::types::H2048* logs_bloom_;
    ::types::H256* prev_randao_;
    ::types::H256* difficulty_;
    ::types::H256* block_hash_;
    ::types::H256* ommer_hash_;
    ::types::H256* transaction_hash_;
    ::types::H256* base_fee_per_gas_;
    ::types::H256* withdrawal_hash_;
    ::types::H256* parent_beacon_block_root_;
    ::types::H256* requests_hash_;
    ::uint64_t block_number_;
    ::uint64_t gas_limit_;
    ::uint64_t gas_used_;
    ::uint64_t timestamp_;
    ::uint64_t nonce_;
    ::uint64_t blob_gas_used_;
    ::uint64_t excess_blob_gas_;
    ::uint64_t aura_step_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetHeaderResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetHeaderResponse) */ {
 public:
  inline GetHeaderResponse() : GetHeaderResponse(nullptr) {}
  ~GetHeaderResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetHeaderResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetHeaderResponse(const GetHeaderResponse& from) : GetHeaderResponse(nullptr, from) {}
  inline GetHeaderResponse(GetHeaderResponse&& from) noexcept
      : GetHeaderResponse(nullptr, std::move(from)) {}
  inline GetHeaderResponse& operator=(const GetHeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHeaderResponse& operator=(GetHeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHeaderResponse* internal_default_instance() {
    return reinterpret_cast<const GetHeaderResponse*>(
        &_GetHeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GetHeaderResponse& a, GetHeaderResponse& b) { a.Swap(&b); }
  inline void Swap(GetHeaderResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHeaderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHeaderResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetHeaderResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetHeaderResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetHeaderResponse& from) { GetHeaderResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetHeaderResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetHeaderResponse"; }

 protected:
  explicit GetHeaderResponse(::google::protobuf::Arena* arena);
  GetHeaderResponse(::google::protobuf::Arena* arena, const GetHeaderResponse& from);
  GetHeaderResponse(::google::protobuf::Arena* arena, GetHeaderResponse&& from) noexcept
      : GetHeaderResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeaderFieldNumber = 1,
  };
  // optional .execution.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::execution::Header& header() const;
  PROTOBUF_NODISCARD ::execution::Header* release_header();
  ::execution::Header* mutable_header();
  void set_allocated_header(::execution::Header* value);
  void unsafe_arena_set_allocated_header(::execution::Header* value);
  ::execution::Header* unsafe_arena_release_header();

  private:
  const ::execution::Header& _internal_header() const;
  ::execution::Header* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:execution.GetHeaderResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetHeaderResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetHeaderResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::execution::Header* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class BlockBody final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.BlockBody) */ {
 public:
  inline BlockBody() : BlockBody(nullptr) {}
  ~BlockBody() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBody(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockBody(const BlockBody& from) : BlockBody(nullptr, from) {}
  inline BlockBody(BlockBody&& from) noexcept
      : BlockBody(nullptr, std::move(from)) {}
  inline BlockBody& operator=(const BlockBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBody& operator=(BlockBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBody* internal_default_instance() {
    return reinterpret_cast<const BlockBody*>(
        &_BlockBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(BlockBody& a, BlockBody& b) { a.Swap(&b); }
  inline void Swap(BlockBody* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBody* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBody* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BlockBody>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockBody& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockBody& from) { BlockBody::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlockBody* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.BlockBody"; }

 protected:
  explicit BlockBody(::google::protobuf::Arena* arena);
  BlockBody(::google::protobuf::Arena* arena, const BlockBody& from);
  BlockBody(::google::protobuf::Arena* arena, BlockBody&& from) noexcept
      : BlockBody(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionsFieldNumber = 3,
    kUnclesFieldNumber = 4,
    kWithdrawalsFieldNumber = 5,
    kBlockHashFieldNumber = 1,
    kBlockNumberFieldNumber = 2,
  };
  // repeated bytes transactions = 3;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;

  public:
  void clear_transactions() ;
  const std::string& transactions(int index) const;
  std::string* mutable_transactions(int index);
  void set_transactions(int index, const std::string& value);
  void set_transactions(int index, std::string&& value);
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, std::size_t size);
  void set_transactions(int index, absl::string_view value);
  std::string* add_transactions();
  void add_transactions(const std::string& value);
  void add_transactions(std::string&& value);
  void add_transactions(const char* value);
  void add_transactions(const void* value, std::size_t size);
  void add_transactions(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& transactions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_transactions();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_transactions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_transactions();

  public:
  // repeated .execution.Header uncles = 4;
  int uncles_size() const;
  private:
  int _internal_uncles_size() const;

  public:
  void clear_uncles() ;
  ::execution::Header* mutable_uncles(int index);
  ::google::protobuf::RepeatedPtrField<::execution::Header>* mutable_uncles();

  private:
  const ::google::protobuf::RepeatedPtrField<::execution::Header>& _internal_uncles() const;
  ::google::protobuf::RepeatedPtrField<::execution::Header>* _internal_mutable_uncles();
  public:
  const ::execution::Header& uncles(int index) const;
  ::execution::Header* add_uncles();
  const ::google::protobuf::RepeatedPtrField<::execution::Header>& uncles() const;
  // repeated .types.Withdrawal withdrawals = 5;
  int withdrawals_size() const;
  private:
  int _internal_withdrawals_size() const;

  public:
  void clear_withdrawals() ;
  ::types::Withdrawal* mutable_withdrawals(int index);
  ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* mutable_withdrawals();

  private:
  const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& _internal_withdrawals() const;
  ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* _internal_mutable_withdrawals();
  public:
  const ::types::Withdrawal& withdrawals(int index) const;
  ::types::Withdrawal* add_withdrawals();
  const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& withdrawals() const;
  // .types.H256 block_hash = 1;
  bool has_block_hash() const;
  void clear_block_hash() ;
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* value);
  void unsafe_arena_set_allocated_block_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_block_hash();

  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();

  public:
  // uint64 block_number = 2;
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:execution.BlockBody)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BlockBody_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockBody& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> transactions_;
    ::google::protobuf::RepeatedPtrField< ::execution::Header > uncles_;
    ::google::protobuf::RepeatedPtrField< ::types::Withdrawal > withdrawals_;
    ::types::H256* block_hash_;
    ::uint64_t block_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class AssembledBlockData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.AssembledBlockData) */ {
 public:
  inline AssembledBlockData() : AssembledBlockData(nullptr) {}
  ~AssembledBlockData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssembledBlockData(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssembledBlockData(const AssembledBlockData& from) : AssembledBlockData(nullptr, from) {}
  inline AssembledBlockData(AssembledBlockData&& from) noexcept
      : AssembledBlockData(nullptr, std::move(from)) {}
  inline AssembledBlockData& operator=(const AssembledBlockData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssembledBlockData& operator=(AssembledBlockData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssembledBlockData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssembledBlockData* internal_default_instance() {
    return reinterpret_cast<const AssembledBlockData*>(
        &_AssembledBlockData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(AssembledBlockData& a, AssembledBlockData& b) { a.Swap(&b); }
  inline void Swap(AssembledBlockData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssembledBlockData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssembledBlockData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AssembledBlockData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssembledBlockData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssembledBlockData& from) { AssembledBlockData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssembledBlockData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.AssembledBlockData"; }

 protected:
  explicit AssembledBlockData(::google::protobuf::Arena* arena);
  AssembledBlockData(::google::protobuf::Arena* arena, const AssembledBlockData& from);
  AssembledBlockData(::google::protobuf::Arena* arena, AssembledBlockData&& from) noexcept
      : AssembledBlockData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExecutionPayloadFieldNumber = 1,
    kBlockValueFieldNumber = 2,
    kBlobsBundleFieldNumber = 3,
    kRequestsFieldNumber = 4,
  };
  // .types.ExecutionPayload execution_payload = 1;
  bool has_execution_payload() const;
  void clear_execution_payload() ;
  const ::types::ExecutionPayload& execution_payload() const;
  PROTOBUF_NODISCARD ::types::ExecutionPayload* release_execution_payload();
  ::types::ExecutionPayload* mutable_execution_payload();
  void set_allocated_execution_payload(::types::ExecutionPayload* value);
  void unsafe_arena_set_allocated_execution_payload(::types::ExecutionPayload* value);
  ::types::ExecutionPayload* unsafe_arena_release_execution_payload();

  private:
  const ::types::ExecutionPayload& _internal_execution_payload() const;
  ::types::ExecutionPayload* _internal_mutable_execution_payload();

  public:
  // .types.H256 block_value = 2;
  bool has_block_value() const;
  void clear_block_value() ;
  const ::types::H256& block_value() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_value();
  ::types::H256* mutable_block_value();
  void set_allocated_block_value(::types::H256* value);
  void unsafe_arena_set_allocated_block_value(::types::H256* value);
  ::types::H256* unsafe_arena_release_block_value();

  private:
  const ::types::H256& _internal_block_value() const;
  ::types::H256* _internal_mutable_block_value();

  public:
  // .types.BlobsBundleV1 blobs_bundle = 3;
  bool has_blobs_bundle() const;
  void clear_blobs_bundle() ;
  const ::types::BlobsBundleV1& blobs_bundle() const;
  PROTOBUF_NODISCARD ::types::BlobsBundleV1* release_blobs_bundle();
  ::types::BlobsBundleV1* mutable_blobs_bundle();
  void set_allocated_blobs_bundle(::types::BlobsBundleV1* value);
  void unsafe_arena_set_allocated_blobs_bundle(::types::BlobsBundleV1* value);
  ::types::BlobsBundleV1* unsafe_arena_release_blobs_bundle();

  private:
  const ::types::BlobsBundleV1& _internal_blobs_bundle() const;
  ::types::BlobsBundleV1* _internal_mutable_blobs_bundle();

  public:
  // .types.RequestsBundle requests = 4;
  bool has_requests() const;
  void clear_requests() ;
  const ::types::RequestsBundle& requests() const;
  PROTOBUF_NODISCARD ::types::RequestsBundle* release_requests();
  ::types::RequestsBundle* mutable_requests();
  void set_allocated_requests(::types::RequestsBundle* value);
  void unsafe_arena_set_allocated_requests(::types::RequestsBundle* value);
  ::types::RequestsBundle* unsafe_arena_release_requests();

  private:
  const ::types::RequestsBundle& _internal_requests() const;
  ::types::RequestsBundle* _internal_mutable_requests();

  public:
  // @@protoc_insertion_point(class_scope:execution.AssembledBlockData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AssembledBlockData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssembledBlockData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::ExecutionPayload* execution_payload_;
    ::types::H256* block_value_;
    ::types::BlobsBundleV1* blobs_bundle_;
    ::types::RequestsBundle* requests_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetBodyResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetBodyResponse) */ {
 public:
  inline GetBodyResponse() : GetBodyResponse(nullptr) {}
  ~GetBodyResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBodyResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBodyResponse(const GetBodyResponse& from) : GetBodyResponse(nullptr, from) {}
  inline GetBodyResponse(GetBodyResponse&& from) noexcept
      : GetBodyResponse(nullptr, std::move(from)) {}
  inline GetBodyResponse& operator=(const GetBodyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBodyResponse& operator=(GetBodyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBodyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBodyResponse* internal_default_instance() {
    return reinterpret_cast<const GetBodyResponse*>(
        &_GetBodyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GetBodyResponse& a, GetBodyResponse& b) { a.Swap(&b); }
  inline void Swap(GetBodyResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBodyResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBodyResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetBodyResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBodyResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBodyResponse& from) { GetBodyResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetBodyResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetBodyResponse"; }

 protected:
  explicit GetBodyResponse(::google::protobuf::Arena* arena);
  GetBodyResponse(::google::protobuf::Arena* arena, const GetBodyResponse& from);
  GetBodyResponse(::google::protobuf::Arena* arena, GetBodyResponse&& from) noexcept
      : GetBodyResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodyFieldNumber = 1,
  };
  // optional .execution.BlockBody body = 1;
  bool has_body() const;
  void clear_body() ;
  const ::execution::BlockBody& body() const;
  PROTOBUF_NODISCARD ::execution::BlockBody* release_body();
  ::execution::BlockBody* mutable_body();
  void set_allocated_body(::execution::BlockBody* value);
  void unsafe_arena_set_allocated_body(::execution::BlockBody* value);
  ::execution::BlockBody* unsafe_arena_release_body();

  private:
  const ::execution::BlockBody& _internal_body() const;
  ::execution::BlockBody* _internal_mutable_body();

  public:
  // @@protoc_insertion_point(class_scope:execution.GetBodyResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetBodyResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetBodyResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::execution::BlockBody* body_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetBodiesBatchResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetBodiesBatchResponse) */ {
 public:
  inline GetBodiesBatchResponse() : GetBodiesBatchResponse(nullptr) {}
  ~GetBodiesBatchResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBodiesBatchResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetBodiesBatchResponse(const GetBodiesBatchResponse& from) : GetBodiesBatchResponse(nullptr, from) {}
  inline GetBodiesBatchResponse(GetBodiesBatchResponse&& from) noexcept
      : GetBodiesBatchResponse(nullptr, std::move(from)) {}
  inline GetBodiesBatchResponse& operator=(const GetBodiesBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBodiesBatchResponse& operator=(GetBodiesBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBodiesBatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBodiesBatchResponse* internal_default_instance() {
    return reinterpret_cast<const GetBodiesBatchResponse*>(
        &_GetBodiesBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(GetBodiesBatchResponse& a, GetBodiesBatchResponse& b) { a.Swap(&b); }
  inline void Swap(GetBodiesBatchResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBodiesBatchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBodiesBatchResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetBodiesBatchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBodiesBatchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBodiesBatchResponse& from) { GetBodiesBatchResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetBodiesBatchResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetBodiesBatchResponse"; }

 protected:
  explicit GetBodiesBatchResponse(::google::protobuf::Arena* arena);
  GetBodiesBatchResponse(::google::protobuf::Arena* arena, const GetBodiesBatchResponse& from);
  GetBodiesBatchResponse(::google::protobuf::Arena* arena, GetBodiesBatchResponse&& from) noexcept
      : GetBodiesBatchResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodiesFieldNumber = 1,
  };
  // repeated .execution.BlockBody bodies = 1;
  int bodies_size() const;
  private:
  int _internal_bodies_size() const;

  public:
  void clear_bodies() ;
  ::execution::BlockBody* mutable_bodies(int index);
  ::google::protobuf::RepeatedPtrField<::execution::BlockBody>* mutable_bodies();

  private:
  const ::google::protobuf::RepeatedPtrField<::execution::BlockBody>& _internal_bodies() const;
  ::google::protobuf::RepeatedPtrField<::execution::BlockBody>* _internal_mutable_bodies();
  public:
  const ::execution::BlockBody& bodies(int index) const;
  ::execution::BlockBody* add_bodies();
  const ::google::protobuf::RepeatedPtrField<::execution::BlockBody>& bodies() const;
  // @@protoc_insertion_point(class_scope:execution.GetBodiesBatchResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetBodiesBatchResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetBodiesBatchResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::execution::BlockBody > bodies_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class GetAssembledBlockResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.GetAssembledBlockResponse) */ {
 public:
  inline GetAssembledBlockResponse() : GetAssembledBlockResponse(nullptr) {}
  ~GetAssembledBlockResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetAssembledBlockResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetAssembledBlockResponse(const GetAssembledBlockResponse& from) : GetAssembledBlockResponse(nullptr, from) {}
  inline GetAssembledBlockResponse(GetAssembledBlockResponse&& from) noexcept
      : GetAssembledBlockResponse(nullptr, std::move(from)) {}
  inline GetAssembledBlockResponse& operator=(const GetAssembledBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAssembledBlockResponse& operator=(GetAssembledBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAssembledBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAssembledBlockResponse* internal_default_instance() {
    return reinterpret_cast<const GetAssembledBlockResponse*>(
        &_GetAssembledBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(GetAssembledBlockResponse& a, GetAssembledBlockResponse& b) { a.Swap(&b); }
  inline void Swap(GetAssembledBlockResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAssembledBlockResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAssembledBlockResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetAssembledBlockResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAssembledBlockResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetAssembledBlockResponse& from) { GetAssembledBlockResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetAssembledBlockResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.GetAssembledBlockResponse"; }

 protected:
  explicit GetAssembledBlockResponse(::google::protobuf::Arena* arena);
  GetAssembledBlockResponse(::google::protobuf::Arena* arena, const GetAssembledBlockResponse& from);
  GetAssembledBlockResponse(::google::protobuf::Arena* arena, GetAssembledBlockResponse&& from) noexcept
      : GetAssembledBlockResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
    kBusyFieldNumber = 2,
  };
  // optional .execution.AssembledBlockData data = 1;
  bool has_data() const;
  void clear_data() ;
  const ::execution::AssembledBlockData& data() const;
  PROTOBUF_NODISCARD ::execution::AssembledBlockData* release_data();
  ::execution::AssembledBlockData* mutable_data();
  void set_allocated_data(::execution::AssembledBlockData* value);
  void unsafe_arena_set_allocated_data(::execution::AssembledBlockData* value);
  ::execution::AssembledBlockData* unsafe_arena_release_data();

  private:
  const ::execution::AssembledBlockData& _internal_data() const;
  ::execution::AssembledBlockData* _internal_mutable_data();

  public:
  // bool busy = 2;
  void clear_busy() ;
  bool busy() const;
  void set_busy(bool value);

  private:
  bool _internal_busy() const;
  void _internal_set_busy(bool value);

  public:
  // @@protoc_insertion_point(class_scope:execution.GetAssembledBlockResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetAssembledBlockResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetAssembledBlockResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::execution::AssembledBlockData* data_;
    bool busy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class Block final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Block(
      ::google::protobuf::internal::ConstantInitialized);

  inline Block(const Block& from) : Block(nullptr, from) {}
  inline Block(Block&& from) noexcept
      : Block(nullptr, std::move(from)) {}
  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
        &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Block& a, Block& b) { a.Swap(&b); }
  inline void Swap(Block* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Block>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Block& from) { Block::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Block* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.Block"; }

 protected:
  explicit Block(::google::protobuf::Arena* arena);
  Block(::google::protobuf::Arena* arena, const Block& from);
  Block(::google::protobuf::Arena* arena, Block&& from) noexcept
      : Block(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeaderFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // .execution.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::execution::Header& header() const;
  PROTOBUF_NODISCARD ::execution::Header* release_header();
  ::execution::Header* mutable_header();
  void set_allocated_header(::execution::Header* value);
  void unsafe_arena_set_allocated_header(::execution::Header* value);
  ::execution::Header* unsafe_arena_release_header();

  private:
  const ::execution::Header& _internal_header() const;
  ::execution::Header* _internal_mutable_header();

  public:
  // .execution.BlockBody body = 2;
  bool has_body() const;
  void clear_body() ;
  const ::execution::BlockBody& body() const;
  PROTOBUF_NODISCARD ::execution::BlockBody* release_body();
  ::execution::BlockBody* mutable_body();
  void set_allocated_body(::execution::BlockBody* value);
  void unsafe_arena_set_allocated_body(::execution::BlockBody* value);
  ::execution::BlockBody* unsafe_arena_release_body();

  private:
  const ::execution::BlockBody& _internal_body() const;
  ::execution::BlockBody* _internal_mutable_body();

  public:
  // @@protoc_insertion_point(class_scope:execution.Block)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Block_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Block& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::execution::Header* header_;
    ::execution::BlockBody* body_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};
// -------------------------------------------------------------------

class InsertBlocksRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:execution.InsertBlocksRequest) */ {
 public:
  inline InsertBlocksRequest() : InsertBlocksRequest(nullptr) {}
  ~InsertBlocksRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InsertBlocksRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline InsertBlocksRequest(const InsertBlocksRequest& from) : InsertBlocksRequest(nullptr, from) {}
  inline InsertBlocksRequest(InsertBlocksRequest&& from) noexcept
      : InsertBlocksRequest(nullptr, std::move(from)) {}
  inline InsertBlocksRequest& operator=(const InsertBlocksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertBlocksRequest& operator=(InsertBlocksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertBlocksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertBlocksRequest* internal_default_instance() {
    return reinterpret_cast<const InsertBlocksRequest*>(
        &_InsertBlocksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(InsertBlocksRequest& a, InsertBlocksRequest& b) { a.Swap(&b); }
  inline void Swap(InsertBlocksRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertBlocksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertBlocksRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InsertBlocksRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InsertBlocksRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InsertBlocksRequest& from) { InsertBlocksRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InsertBlocksRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "execution.InsertBlocksRequest"; }

 protected:
  explicit InsertBlocksRequest(::google::protobuf::Arena* arena);
  InsertBlocksRequest(::google::protobuf::Arena* arena, const InsertBlocksRequest& from);
  InsertBlocksRequest(::google::protobuf::Arena* arena, InsertBlocksRequest&& from) noexcept
      : InsertBlocksRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .execution.Block blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;

  public:
  void clear_blocks() ;
  ::execution::Block* mutable_blocks(int index);
  ::google::protobuf::RepeatedPtrField<::execution::Block>* mutable_blocks();

  private:
  const ::google::protobuf::RepeatedPtrField<::execution::Block>& _internal_blocks() const;
  ::google::protobuf::RepeatedPtrField<::execution::Block>* _internal_mutable_blocks();
  public:
  const ::execution::Block& blocks(int index) const;
  ::execution::Block* add_blocks();
  const ::google::protobuf::RepeatedPtrField<::execution::Block>& blocks() const;
  // @@protoc_insertion_point(class_scope:execution.InsertBlocksRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InsertBlocksRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InsertBlocksRequest& from_msg);
    ::google::protobuf::RepeatedPtrField< ::execution::Block > blocks_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_execution_2fexecution_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ForkChoiceReceipt

// .execution.ExecutionStatus status = 1;
inline void ForkChoiceReceipt::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::execution::ExecutionStatus ForkChoiceReceipt::status() const {
  // @@protoc_insertion_point(field_get:execution.ForkChoiceReceipt.status)
  return _internal_status();
}
inline void ForkChoiceReceipt::set_status(::execution::ExecutionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:execution.ForkChoiceReceipt.status)
}
inline ::execution::ExecutionStatus ForkChoiceReceipt::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::execution::ExecutionStatus>(_impl_.status_);
}
inline void ForkChoiceReceipt::_internal_set_status(::execution::ExecutionStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .types.H256 latest_valid_hash = 2;
inline bool ForkChoiceReceipt::has_latest_valid_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latest_valid_hash_ != nullptr);
  return value;
}
inline const ::types::H256& ForkChoiceReceipt::_internal_latest_valid_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.latest_valid_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ForkChoiceReceipt::latest_valid_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.ForkChoiceReceipt.latest_valid_hash)
  return _internal_latest_valid_hash();
}
inline void ForkChoiceReceipt::unsafe_arena_set_allocated_latest_valid_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latest_valid_hash_);
  }
  _impl_.latest_valid_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ForkChoiceReceipt.latest_valid_hash)
}
inline ::types::H256* ForkChoiceReceipt::release_latest_valid_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ForkChoiceReceipt::unsafe_arena_release_latest_valid_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.ForkChoiceReceipt.latest_valid_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ForkChoiceReceipt::_internal_mutable_latest_valid_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.latest_valid_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.latest_valid_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.latest_valid_hash_;
}
inline ::types::H256* ForkChoiceReceipt::mutable_latest_valid_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_latest_valid_hash();
  // @@protoc_insertion_point(field_mutable:execution.ForkChoiceReceipt.latest_valid_hash)
  return _msg;
}
inline void ForkChoiceReceipt::set_allocated_latest_valid_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latest_valid_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.latest_valid_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.ForkChoiceReceipt.latest_valid_hash)
}

// string validation_error = 3;
inline void ForkChoiceReceipt::clear_validation_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_error_.ClearToEmpty();
}
inline const std::string& ForkChoiceReceipt::validation_error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.ForkChoiceReceipt.validation_error)
  return _internal_validation_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForkChoiceReceipt::set_validation_error(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:execution.ForkChoiceReceipt.validation_error)
}
inline std::string* ForkChoiceReceipt::mutable_validation_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validation_error();
  // @@protoc_insertion_point(field_mutable:execution.ForkChoiceReceipt.validation_error)
  return _s;
}
inline const std::string& ForkChoiceReceipt::_internal_validation_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validation_error_.Get();
}
inline void ForkChoiceReceipt::_internal_set_validation_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_error_.Set(value, GetArena());
}
inline std::string* ForkChoiceReceipt::_internal_mutable_validation_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validation_error_.Mutable( GetArena());
}
inline std::string* ForkChoiceReceipt::release_validation_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.ForkChoiceReceipt.validation_error)
  return _impl_.validation_error_.Release();
}
inline void ForkChoiceReceipt::set_allocated_validation_error(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validation_error_.IsDefault()) {
          _impl_.validation_error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:execution.ForkChoiceReceipt.validation_error)
}

// -------------------------------------------------------------------

// ValidationReceipt

// .execution.ExecutionStatus validation_status = 1;
inline void ValidationReceipt::clear_validation_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_status_ = 0;
}
inline ::execution::ExecutionStatus ValidationReceipt::validation_status() const {
  // @@protoc_insertion_point(field_get:execution.ValidationReceipt.validation_status)
  return _internal_validation_status();
}
inline void ValidationReceipt::set_validation_status(::execution::ExecutionStatus value) {
  _internal_set_validation_status(value);
  // @@protoc_insertion_point(field_set:execution.ValidationReceipt.validation_status)
}
inline ::execution::ExecutionStatus ValidationReceipt::_internal_validation_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::execution::ExecutionStatus>(_impl_.validation_status_);
}
inline void ValidationReceipt::_internal_set_validation_status(::execution::ExecutionStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_status_ = value;
}

// .types.H256 latest_valid_hash = 2;
inline bool ValidationReceipt::has_latest_valid_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latest_valid_hash_ != nullptr);
  return value;
}
inline const ::types::H256& ValidationReceipt::_internal_latest_valid_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.latest_valid_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ValidationReceipt::latest_valid_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.ValidationReceipt.latest_valid_hash)
  return _internal_latest_valid_hash();
}
inline void ValidationReceipt::unsafe_arena_set_allocated_latest_valid_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latest_valid_hash_);
  }
  _impl_.latest_valid_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ValidationReceipt.latest_valid_hash)
}
inline ::types::H256* ValidationReceipt::release_latest_valid_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ValidationReceipt::unsafe_arena_release_latest_valid_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.ValidationReceipt.latest_valid_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.latest_valid_hash_;
  _impl_.latest_valid_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ValidationReceipt::_internal_mutable_latest_valid_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.latest_valid_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.latest_valid_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.latest_valid_hash_;
}
inline ::types::H256* ValidationReceipt::mutable_latest_valid_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_latest_valid_hash();
  // @@protoc_insertion_point(field_mutable:execution.ValidationReceipt.latest_valid_hash)
  return _msg;
}
inline void ValidationReceipt::set_allocated_latest_valid_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latest_valid_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.latest_valid_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.ValidationReceipt.latest_valid_hash)
}

// string validation_error = 3;
inline void ValidationReceipt::clear_validation_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_error_.ClearToEmpty();
}
inline const std::string& ValidationReceipt::validation_error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.ValidationReceipt.validation_error)
  return _internal_validation_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidationReceipt::set_validation_error(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:execution.ValidationReceipt.validation_error)
}
inline std::string* ValidationReceipt::mutable_validation_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validation_error();
  // @@protoc_insertion_point(field_mutable:execution.ValidationReceipt.validation_error)
  return _s;
}
inline const std::string& ValidationReceipt::_internal_validation_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validation_error_.Get();
}
inline void ValidationReceipt::_internal_set_validation_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_error_.Set(value, GetArena());
}
inline std::string* ValidationReceipt::_internal_mutable_validation_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validation_error_.Mutable( GetArena());
}
inline std::string* ValidationReceipt::release_validation_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.ValidationReceipt.validation_error)
  return _impl_.validation_error_.Release();
}
inline void ValidationReceipt::set_allocated_validation_error(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validation_error_.IsDefault()) {
          _impl_.validation_error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:execution.ValidationReceipt.validation_error)
}

// -------------------------------------------------------------------

// IsCanonicalResponse

// bool canonical = 1;
inline void IsCanonicalResponse::clear_canonical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.canonical_ = false;
}
inline bool IsCanonicalResponse::canonical() const {
  // @@protoc_insertion_point(field_get:execution.IsCanonicalResponse.canonical)
  return _internal_canonical();
}
inline void IsCanonicalResponse::set_canonical(bool value) {
  _internal_set_canonical(value);
  // @@protoc_insertion_point(field_set:execution.IsCanonicalResponse.canonical)
}
inline bool IsCanonicalResponse::_internal_canonical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.canonical_;
}
inline void IsCanonicalResponse::_internal_set_canonical(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.canonical_ = value;
}

// -------------------------------------------------------------------

// Header

// .types.H256 parent_hash = 1;
inline bool Header::has_parent_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_hash_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_parent_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.parent_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::parent_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.parent_hash)
  return _internal_parent_hash();
}
inline void Header::unsafe_arena_set_allocated_parent_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_hash_);
  }
  _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.parent_hash)
}
inline ::types::H256* Header::release_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* released = _impl_.parent_hash_;
  _impl_.parent_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.parent_hash)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* temp = _impl_.parent_hash_;
  _impl_.parent_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parent_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.parent_hash_;
}
inline ::types::H256* Header::mutable_parent_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H256* _msg = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.parent_hash)
  return _msg;
}
inline void Header::set_allocated_parent_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.parent_hash)
}

// .types.H160 coinbase = 2;
inline bool Header::has_coinbase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.coinbase_ != nullptr);
  return value;
}
inline const ::types::H160& Header::_internal_coinbase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H160* p = _impl_.coinbase_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(::types::_H160_default_instance_);
}
inline const ::types::H160& Header::coinbase() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.coinbase)
  return _internal_coinbase();
}
inline void Header::unsafe_arena_set_allocated_coinbase(::types::H160* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.coinbase_);
  }
  _impl_.coinbase_ = reinterpret_cast<::types::H160*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.coinbase)
}
inline ::types::H160* Header::release_coinbase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H160* released = _impl_.coinbase_;
  _impl_.coinbase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H160* Header::unsafe_arena_release_coinbase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.coinbase)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H160* temp = _impl_.coinbase_;
  _impl_.coinbase_ = nullptr;
  return temp;
}
inline ::types::H160* Header::_internal_mutable_coinbase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.coinbase_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H160>(GetArena());
    _impl_.coinbase_ = reinterpret_cast<::types::H160*>(p);
  }
  return _impl_.coinbase_;
}
inline ::types::H160* Header::mutable_coinbase() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::types::H160* _msg = _internal_mutable_coinbase();
  // @@protoc_insertion_point(field_mutable:execution.Header.coinbase)
  return _msg;
}
inline void Header::set_allocated_coinbase(::types::H160* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.coinbase_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.coinbase_ = reinterpret_cast<::types::H160*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.coinbase)
}

// .types.H256 state_root = 3;
inline bool Header::has_state_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_root_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_state_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::state_root() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.state_root)
  return _internal_state_root();
}
inline void Header::unsafe_arena_set_allocated_state_root(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_root_);
  }
  _impl_.state_root_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.state_root)
}
inline ::types::H256* Header::release_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::types::H256* released = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.state_root)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::types::H256* temp = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_root_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.state_root_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.state_root_;
}
inline ::types::H256* Header::mutable_state_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::types::H256* _msg = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:execution.Header.state_root)
  return _msg;
}
inline void Header::set_allocated_state_root(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_root_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.state_root_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.state_root)
}

// .types.H256 receipt_root = 4;
inline bool Header::has_receipt_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receipt_root_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_receipt_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.receipt_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::receipt_root() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.receipt_root)
  return _internal_receipt_root();
}
inline void Header::unsafe_arena_set_allocated_receipt_root(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receipt_root_);
  }
  _impl_.receipt_root_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.receipt_root)
}
inline ::types::H256* Header::release_receipt_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::types::H256* released = _impl_.receipt_root_;
  _impl_.receipt_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_receipt_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.receipt_root)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::types::H256* temp = _impl_.receipt_root_;
  _impl_.receipt_root_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_receipt_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.receipt_root_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.receipt_root_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.receipt_root_;
}
inline ::types::H256* Header::mutable_receipt_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::types::H256* _msg = _internal_mutable_receipt_root();
  // @@protoc_insertion_point(field_mutable:execution.Header.receipt_root)
  return _msg;
}
inline void Header::set_allocated_receipt_root(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receipt_root_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.receipt_root_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.receipt_root)
}

// .types.H2048 logs_bloom = 5;
inline bool Header::has_logs_bloom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logs_bloom_ != nullptr);
  return value;
}
inline const ::types::H2048& Header::_internal_logs_bloom() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H2048* p = _impl_.logs_bloom_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H2048&>(::types::_H2048_default_instance_);
}
inline const ::types::H2048& Header::logs_bloom() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.logs_bloom)
  return _internal_logs_bloom();
}
inline void Header::unsafe_arena_set_allocated_logs_bloom(::types::H2048* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logs_bloom_);
  }
  _impl_.logs_bloom_ = reinterpret_cast<::types::H2048*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.logs_bloom)
}
inline ::types::H2048* Header::release_logs_bloom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::types::H2048* released = _impl_.logs_bloom_;
  _impl_.logs_bloom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H2048* Header::unsafe_arena_release_logs_bloom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.logs_bloom)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::types::H2048* temp = _impl_.logs_bloom_;
  _impl_.logs_bloom_ = nullptr;
  return temp;
}
inline ::types::H2048* Header::_internal_mutable_logs_bloom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logs_bloom_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H2048>(GetArena());
    _impl_.logs_bloom_ = reinterpret_cast<::types::H2048*>(p);
  }
  return _impl_.logs_bloom_;
}
inline ::types::H2048* Header::mutable_logs_bloom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::types::H2048* _msg = _internal_mutable_logs_bloom();
  // @@protoc_insertion_point(field_mutable:execution.Header.logs_bloom)
  return _msg;
}
inline void Header::set_allocated_logs_bloom(::types::H2048* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logs_bloom_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.logs_bloom_ = reinterpret_cast<::types::H2048*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.logs_bloom)
}

// .types.H256 prev_randao = 6;
inline bool Header::has_prev_randao() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prev_randao_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_prev_randao() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.prev_randao_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::prev_randao() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.prev_randao)
  return _internal_prev_randao();
}
inline void Header::unsafe_arena_set_allocated_prev_randao(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prev_randao_);
  }
  _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.prev_randao)
}
inline ::types::H256* Header::release_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::types::H256* released = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.prev_randao)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::types::H256* temp = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.prev_randao_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.prev_randao_;
}
inline ::types::H256* Header::mutable_prev_randao() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::types::H256* _msg = _internal_mutable_prev_randao();
  // @@protoc_insertion_point(field_mutable:execution.Header.prev_randao)
  return _msg;
}
inline void Header::set_allocated_prev_randao(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prev_randao_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.prev_randao)
}

// uint64 block_number = 7;
inline void Header::clear_block_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t Header::block_number() const {
  // @@protoc_insertion_point(field_get:execution.Header.block_number)
  return _internal_block_number();
}
inline void Header::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:execution.Header.block_number)
}
inline ::uint64_t Header::_internal_block_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_number_;
}
inline void Header::_internal_set_block_number(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = value;
}

// uint64 gas_limit = 8;
inline void Header::clear_gas_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_limit_ = ::uint64_t{0u};
}
inline ::uint64_t Header::gas_limit() const {
  // @@protoc_insertion_point(field_get:execution.Header.gas_limit)
  return _internal_gas_limit();
}
inline void Header::set_gas_limit(::uint64_t value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:execution.Header.gas_limit)
}
inline ::uint64_t Header::_internal_gas_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gas_limit_;
}
inline void Header::_internal_set_gas_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_limit_ = value;
}

// uint64 gas_used = 9;
inline void Header::clear_gas_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_used_ = ::uint64_t{0u};
}
inline ::uint64_t Header::gas_used() const {
  // @@protoc_insertion_point(field_get:execution.Header.gas_used)
  return _internal_gas_used();
}
inline void Header::set_gas_used(::uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:execution.Header.gas_used)
}
inline ::uint64_t Header::_internal_gas_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gas_used_;
}
inline void Header::_internal_set_gas_used(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_used_ = value;
}

// uint64 timestamp = 10;
inline void Header::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t Header::timestamp() const {
  // @@protoc_insertion_point(field_get:execution.Header.timestamp)
  return _internal_timestamp();
}
inline void Header::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:execution.Header.timestamp)
}
inline ::uint64_t Header::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Header::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// uint64 nonce = 11;
inline void Header::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t Header::nonce() const {
  // @@protoc_insertion_point(field_get:execution.Header.nonce)
  return _internal_nonce();
}
inline void Header::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:execution.Header.nonce)
}
inline ::uint64_t Header::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_;
}
inline void Header::_internal_set_nonce(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = value;
}

// bytes extra_data = 12;
inline void Header::clear_extra_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_data_.ClearToEmpty();
}
inline const std::string& Header::extra_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.extra_data)
  return _internal_extra_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_extra_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:execution.Header.extra_data)
}
inline std::string* Header::mutable_extra_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extra_data();
  // @@protoc_insertion_point(field_mutable:execution.Header.extra_data)
  return _s;
}
inline const std::string& Header::_internal_extra_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extra_data_.Get();
}
inline void Header::_internal_set_extra_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_data_.Set(value, GetArena());
}
inline std::string* Header::_internal_mutable_extra_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.extra_data_.Mutable( GetArena());
}
inline std::string* Header::release_extra_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.extra_data)
  return _impl_.extra_data_.Release();
}
inline void Header::set_allocated_extra_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extra_data_.IsDefault()) {
          _impl_.extra_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:execution.Header.extra_data)
}

// .types.H256 difficulty = 13;
inline bool Header::has_difficulty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.difficulty_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_difficulty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.difficulty_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::difficulty() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.difficulty)
  return _internal_difficulty();
}
inline void Header::unsafe_arena_set_allocated_difficulty(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.difficulty_);
  }
  _impl_.difficulty_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.difficulty)
}
inline ::types::H256* Header::release_difficulty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::types::H256* released = _impl_.difficulty_;
  _impl_.difficulty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_difficulty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.difficulty)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::types::H256* temp = _impl_.difficulty_;
  _impl_.difficulty_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_difficulty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.difficulty_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.difficulty_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.difficulty_;
}
inline ::types::H256* Header::mutable_difficulty() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::types::H256* _msg = _internal_mutable_difficulty();
  // @@protoc_insertion_point(field_mutable:execution.Header.difficulty)
  return _msg;
}
inline void Header::set_allocated_difficulty(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.difficulty_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.difficulty_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.difficulty)
}

// .types.H256 block_hash = 14;
inline bool Header::has_block_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_hash_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_block_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::block_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.block_hash)
  return _internal_block_hash();
}
inline void Header::unsafe_arena_set_allocated_block_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.block_hash)
}
inline ::types::H256* Header::release_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::types::H256* released = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.block_hash)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.block_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.block_hash_;
}
inline ::types::H256* Header::mutable_block_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.block_hash)
  return _msg;
}
inline void Header::set_allocated_block_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.block_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.block_hash)
}

// .types.H256 ommer_hash = 15;
inline bool Header::has_ommer_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ommer_hash_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_ommer_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.ommer_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::ommer_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.ommer_hash)
  return _internal_ommer_hash();
}
inline void Header::unsafe_arena_set_allocated_ommer_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ommer_hash_);
  }
  _impl_.ommer_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.ommer_hash)
}
inline ::types::H256* Header::release_ommer_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::types::H256* released = _impl_.ommer_hash_;
  _impl_.ommer_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_ommer_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.ommer_hash)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::types::H256* temp = _impl_.ommer_hash_;
  _impl_.ommer_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_ommer_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ommer_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.ommer_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.ommer_hash_;
}
inline ::types::H256* Header::mutable_ommer_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::types::H256* _msg = _internal_mutable_ommer_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.ommer_hash)
  return _msg;
}
inline void Header::set_allocated_ommer_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ommer_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.ommer_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.ommer_hash)
}

// .types.H256 transaction_hash = 16;
inline bool Header::has_transaction_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transaction_hash_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_transaction_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.transaction_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::transaction_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.transaction_hash)
  return _internal_transaction_hash();
}
inline void Header::unsafe_arena_set_allocated_transaction_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transaction_hash_);
  }
  _impl_.transaction_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.transaction_hash)
}
inline ::types::H256* Header::release_transaction_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::types::H256* released = _impl_.transaction_hash_;
  _impl_.transaction_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_transaction_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.transaction_hash)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::types::H256* temp = _impl_.transaction_hash_;
  _impl_.transaction_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_transaction_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transaction_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.transaction_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.transaction_hash_;
}
inline ::types::H256* Header::mutable_transaction_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::types::H256* _msg = _internal_mutable_transaction_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.transaction_hash)
  return _msg;
}
inline void Header::set_allocated_transaction_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transaction_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.transaction_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.transaction_hash)
}

// optional .types.H256 base_fee_per_gas = 17;
inline bool Header::has_base_fee_per_gas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_fee_per_gas_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_base_fee_per_gas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.base_fee_per_gas_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::base_fee_per_gas() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.base_fee_per_gas)
  return _internal_base_fee_per_gas();
}
inline void Header::unsafe_arena_set_allocated_base_fee_per_gas(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_fee_per_gas_);
  }
  _impl_.base_fee_per_gas_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.base_fee_per_gas)
}
inline ::types::H256* Header::release_base_fee_per_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::types::H256* released = _impl_.base_fee_per_gas_;
  _impl_.base_fee_per_gas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_base_fee_per_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.base_fee_per_gas)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::types::H256* temp = _impl_.base_fee_per_gas_;
  _impl_.base_fee_per_gas_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_base_fee_per_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_fee_per_gas_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.base_fee_per_gas_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.base_fee_per_gas_;
}
inline ::types::H256* Header::mutable_base_fee_per_gas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000800u;
  ::types::H256* _msg = _internal_mutable_base_fee_per_gas();
  // @@protoc_insertion_point(field_mutable:execution.Header.base_fee_per_gas)
  return _msg;
}
inline void Header::set_allocated_base_fee_per_gas(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_fee_per_gas_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.base_fee_per_gas_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.base_fee_per_gas)
}

// optional .types.H256 withdrawal_hash = 18;
inline bool Header::has_withdrawal_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.withdrawal_hash_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_withdrawal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.withdrawal_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::withdrawal_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.withdrawal_hash)
  return _internal_withdrawal_hash();
}
inline void Header::unsafe_arena_set_allocated_withdrawal_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.withdrawal_hash_);
  }
  _impl_.withdrawal_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.withdrawal_hash)
}
inline ::types::H256* Header::release_withdrawal_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::types::H256* released = _impl_.withdrawal_hash_;
  _impl_.withdrawal_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_withdrawal_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.withdrawal_hash)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::types::H256* temp = _impl_.withdrawal_hash_;
  _impl_.withdrawal_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_withdrawal_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.withdrawal_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.withdrawal_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.withdrawal_hash_;
}
inline ::types::H256* Header::mutable_withdrawal_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00001000u;
  ::types::H256* _msg = _internal_mutable_withdrawal_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.withdrawal_hash)
  return _msg;
}
inline void Header::set_allocated_withdrawal_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.withdrawal_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.withdrawal_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.withdrawal_hash)
}

// optional uint64 blob_gas_used = 19;
inline bool Header::has_blob_gas_used() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void Header::clear_blob_gas_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blob_gas_used_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::uint64_t Header::blob_gas_used() const {
  // @@protoc_insertion_point(field_get:execution.Header.blob_gas_used)
  return _internal_blob_gas_used();
}
inline void Header::set_blob_gas_used(::uint64_t value) {
  _internal_set_blob_gas_used(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:execution.Header.blob_gas_used)
}
inline ::uint64_t Header::_internal_blob_gas_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blob_gas_used_;
}
inline void Header::_internal_set_blob_gas_used(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blob_gas_used_ = value;
}

// optional uint64 excess_blob_gas = 20;
inline bool Header::has_excess_blob_gas() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void Header::clear_excess_blob_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.excess_blob_gas_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::uint64_t Header::excess_blob_gas() const {
  // @@protoc_insertion_point(field_get:execution.Header.excess_blob_gas)
  return _internal_excess_blob_gas();
}
inline void Header::set_excess_blob_gas(::uint64_t value) {
  _internal_set_excess_blob_gas(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:execution.Header.excess_blob_gas)
}
inline ::uint64_t Header::_internal_excess_blob_gas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.excess_blob_gas_;
}
inline void Header::_internal_set_excess_blob_gas(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.excess_blob_gas_ = value;
}

// optional .types.H256 parent_beacon_block_root = 21;
inline bool Header::has_parent_beacon_block_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_beacon_block_root_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_parent_beacon_block_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.parent_beacon_block_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::parent_beacon_block_root() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.parent_beacon_block_root)
  return _internal_parent_beacon_block_root();
}
inline void Header::unsafe_arena_set_allocated_parent_beacon_block_root(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_beacon_block_root_);
  }
  _impl_.parent_beacon_block_root_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.parent_beacon_block_root)
}
inline ::types::H256* Header::release_parent_beacon_block_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::types::H256* released = _impl_.parent_beacon_block_root_;
  _impl_.parent_beacon_block_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_parent_beacon_block_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.parent_beacon_block_root)

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::types::H256* temp = _impl_.parent_beacon_block_root_;
  _impl_.parent_beacon_block_root_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_parent_beacon_block_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parent_beacon_block_root_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.parent_beacon_block_root_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.parent_beacon_block_root_;
}
inline ::types::H256* Header::mutable_parent_beacon_block_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00002000u;
  ::types::H256* _msg = _internal_mutable_parent_beacon_block_root();
  // @@protoc_insertion_point(field_mutable:execution.Header.parent_beacon_block_root)
  return _msg;
}
inline void Header::set_allocated_parent_beacon_block_root(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_beacon_block_root_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }

  _impl_.parent_beacon_block_root_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.parent_beacon_block_root)
}

// optional .types.H256 requests_hash = 22;
inline bool Header::has_requests_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requests_hash_ != nullptr);
  return value;
}
inline const ::types::H256& Header::_internal_requests_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.requests_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& Header::requests_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.requests_hash)
  return _internal_requests_hash();
}
inline void Header::unsafe_arena_set_allocated_requests_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requests_hash_);
  }
  _impl_.requests_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Header.requests_hash)
}
inline ::types::H256* Header::release_requests_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::types::H256* released = _impl_.requests_hash_;
  _impl_.requests_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* Header::unsafe_arena_release_requests_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.requests_hash)

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::types::H256* temp = _impl_.requests_hash_;
  _impl_.requests_hash_ = nullptr;
  return temp;
}
inline ::types::H256* Header::_internal_mutable_requests_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.requests_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.requests_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.requests_hash_;
}
inline ::types::H256* Header::mutable_requests_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00004000u;
  ::types::H256* _msg = _internal_mutable_requests_hash();
  // @@protoc_insertion_point(field_mutable:execution.Header.requests_hash)
  return _msg;
}
inline void Header::set_allocated_requests_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requests_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }

  _impl_.requests_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Header.requests_hash)
}

// optional uint64 aura_step = 23;
inline bool Header::has_aura_step() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void Header::clear_aura_step() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aura_step_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::uint64_t Header::aura_step() const {
  // @@protoc_insertion_point(field_get:execution.Header.aura_step)
  return _internal_aura_step();
}
inline void Header::set_aura_step(::uint64_t value) {
  _internal_set_aura_step(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:execution.Header.aura_step)
}
inline ::uint64_t Header::_internal_aura_step() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aura_step_;
}
inline void Header::_internal_set_aura_step(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aura_step_ = value;
}

// optional bytes aura_seal = 24;
inline bool Header::has_aura_seal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Header::clear_aura_seal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aura_seal_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Header::aura_seal() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Header.aura_seal)
  return _internal_aura_seal();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_aura_seal(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.aura_seal_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:execution.Header.aura_seal)
}
inline std::string* Header::mutable_aura_seal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_aura_seal();
  // @@protoc_insertion_point(field_mutable:execution.Header.aura_seal)
  return _s;
}
inline const std::string& Header::_internal_aura_seal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aura_seal_.Get();
}
inline void Header::_internal_set_aura_seal(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.aura_seal_.Set(value, GetArena());
}
inline std::string* Header::_internal_mutable_aura_seal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.aura_seal_.Mutable( GetArena());
}
inline std::string* Header::release_aura_seal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Header.aura_seal)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.aura_seal_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.aura_seal_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header::set_allocated_aura_seal(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.aura_seal_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aura_seal_.IsDefault()) {
          _impl_.aura_seal_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:execution.Header.aura_seal)
}

// -------------------------------------------------------------------

// BlockBody

// .types.H256 block_hash = 1;
inline bool BlockBody::has_block_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_hash_ != nullptr);
  return value;
}
inline const ::types::H256& BlockBody::_internal_block_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& BlockBody::block_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.BlockBody.block_hash)
  return _internal_block_hash();
}
inline void BlockBody::unsafe_arena_set_allocated_block_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.BlockBody.block_hash)
}
inline ::types::H256* BlockBody::release_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* BlockBody::unsafe_arena_release_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.BlockBody.block_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* BlockBody::_internal_mutable_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.block_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.block_hash_;
}
inline ::types::H256* BlockBody::mutable_block_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.BlockBody.block_hash)
  return _msg;
}
inline void BlockBody::set_allocated_block_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.block_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.BlockBody.block_hash)
}

// uint64 block_number = 2;
inline void BlockBody::clear_block_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t BlockBody::block_number() const {
  // @@protoc_insertion_point(field_get:execution.BlockBody.block_number)
  return _internal_block_number();
}
inline void BlockBody::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:execution.BlockBody.block_number)
}
inline ::uint64_t BlockBody::_internal_block_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_number_;
}
inline void BlockBody::_internal_set_block_number(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = value;
}

// repeated bytes transactions = 3;
inline int BlockBody::_internal_transactions_size() const {
  return _internal_transactions().size();
}
inline int BlockBody::transactions_size() const {
  return _internal_transactions_size();
}
inline void BlockBody::clear_transactions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transactions_.Clear();
}
inline std::string* BlockBody::add_transactions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_transactions()->Add();
  // @@protoc_insertion_point(field_add_mutable:execution.BlockBody.transactions)
  return _s;
}
inline const std::string& BlockBody::transactions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.BlockBody.transactions)
  return _internal_transactions().Get(index);
}
inline std::string* BlockBody::mutable_transactions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:execution.BlockBody.transactions)
  return _internal_mutable_transactions()->Mutable(index);
}
inline void BlockBody::set_transactions(int index, const std::string& value) {
  _internal_mutable_transactions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:execution.BlockBody.transactions)
}
inline void BlockBody::set_transactions(int index, std::string&& value) {
  _internal_mutable_transactions()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:execution.BlockBody.transactions)
}
inline void BlockBody::set_transactions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transactions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:execution.BlockBody.transactions)
}
inline void BlockBody::set_transactions(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_transactions()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:execution.BlockBody.transactions)
}
inline void BlockBody::set_transactions(int index, absl::string_view value) {
  _internal_mutable_transactions()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:execution.BlockBody.transactions)
}
inline void BlockBody::add_transactions(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:execution.BlockBody.transactions)
}
inline void BlockBody::add_transactions(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:execution.BlockBody.transactions)
}
inline void BlockBody::add_transactions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:execution.BlockBody.transactions)
}
inline void BlockBody::add_transactions(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:execution.BlockBody.transactions)
}
inline void BlockBody::add_transactions(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:execution.BlockBody.transactions)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlockBody::transactions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:execution.BlockBody.transactions)
  return _internal_transactions();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlockBody::mutable_transactions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:execution.BlockBody.transactions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_transactions();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlockBody::_internal_transactions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transactions_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlockBody::_internal_mutable_transactions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.transactions_;
}

// repeated .execution.Header uncles = 4;
inline int BlockBody::_internal_uncles_size() const {
  return _internal_uncles().size();
}
inline int BlockBody::uncles_size() const {
  return _internal_uncles_size();
}
inline void BlockBody::clear_uncles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uncles_.Clear();
}
inline ::execution::Header* BlockBody::mutable_uncles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:execution.BlockBody.uncles)
  return _internal_mutable_uncles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::execution::Header>* BlockBody::mutable_uncles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:execution.BlockBody.uncles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_uncles();
}
inline const ::execution::Header& BlockBody::uncles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.BlockBody.uncles)
  return _internal_uncles().Get(index);
}
inline ::execution::Header* BlockBody::add_uncles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::execution::Header* _add = _internal_mutable_uncles()->Add();
  // @@protoc_insertion_point(field_add:execution.BlockBody.uncles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::execution::Header>& BlockBody::uncles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:execution.BlockBody.uncles)
  return _internal_uncles();
}
inline const ::google::protobuf::RepeatedPtrField<::execution::Header>&
BlockBody::_internal_uncles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uncles_;
}
inline ::google::protobuf::RepeatedPtrField<::execution::Header>*
BlockBody::_internal_mutable_uncles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.uncles_;
}

// repeated .types.Withdrawal withdrawals = 5;
inline int BlockBody::_internal_withdrawals_size() const {
  return _internal_withdrawals().size();
}
inline int BlockBody::withdrawals_size() const {
  return _internal_withdrawals_size();
}
inline ::types::Withdrawal* BlockBody::mutable_withdrawals(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:execution.BlockBody.withdrawals)
  return _internal_mutable_withdrawals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* BlockBody::mutable_withdrawals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:execution.BlockBody.withdrawals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_withdrawals();
}
inline const ::types::Withdrawal& BlockBody::withdrawals(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.BlockBody.withdrawals)
  return _internal_withdrawals().Get(index);
}
inline ::types::Withdrawal* BlockBody::add_withdrawals() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::types::Withdrawal* _add = _internal_mutable_withdrawals()->Add();
  // @@protoc_insertion_point(field_add:execution.BlockBody.withdrawals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& BlockBody::withdrawals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:execution.BlockBody.withdrawals)
  return _internal_withdrawals();
}
inline const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>&
BlockBody::_internal_withdrawals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.withdrawals_;
}
inline ::google::protobuf::RepeatedPtrField<::types::Withdrawal>*
BlockBody::_internal_mutable_withdrawals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.withdrawals_;
}

// -------------------------------------------------------------------

// Block

// .execution.Header header = 1;
inline bool Block::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void Block::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::execution::Header& Block::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::execution::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::execution::Header&>(::execution::_Header_default_instance_);
}
inline const ::execution::Header& Block::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Block.header)
  return _internal_header();
}
inline void Block::unsafe_arena_set_allocated_header(::execution::Header* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::execution::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Block.header)
}
inline ::execution::Header* Block::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::execution::Header* Block::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Block.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::execution::Header* Block::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::execution::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::execution::Header*>(p);
  }
  return _impl_.header_;
}
inline ::execution::Header* Block::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::execution::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:execution.Block.header)
  return _msg;
}
inline void Block::set_allocated_header(::execution::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::execution::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Block.header)
}

// .execution.BlockBody body = 2;
inline bool Block::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline void Block::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::execution::BlockBody& Block::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::execution::BlockBody* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::execution::BlockBody&>(::execution::_BlockBody_default_instance_);
}
inline const ::execution::BlockBody& Block::body() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.Block.body)
  return _internal_body();
}
inline void Block::unsafe_arena_set_allocated_body(::execution::BlockBody* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = reinterpret_cast<::execution::BlockBody*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.Block.body)
}
inline ::execution::BlockBody* Block::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::execution::BlockBody* released = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::execution::BlockBody* Block::unsafe_arena_release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.Block.body)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::execution::BlockBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::execution::BlockBody* Block::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::execution::BlockBody>(GetArena());
    _impl_.body_ = reinterpret_cast<::execution::BlockBody*>(p);
  }
  return _impl_.body_;
}
inline ::execution::BlockBody* Block::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::execution::BlockBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:execution.Block.body)
  return _msg;
}
inline void Block::set_allocated_body(::execution::BlockBody* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.body_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.body_ = reinterpret_cast<::execution::BlockBody*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.Block.body)
}

// -------------------------------------------------------------------

// GetHeaderResponse

// optional .execution.Header header = 1;
inline bool GetHeaderResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void GetHeaderResponse::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::execution::Header& GetHeaderResponse::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::execution::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::execution::Header&>(::execution::_Header_default_instance_);
}
inline const ::execution::Header& GetHeaderResponse::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.GetHeaderResponse.header)
  return _internal_header();
}
inline void GetHeaderResponse::unsafe_arena_set_allocated_header(::execution::Header* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::execution::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.GetHeaderResponse.header)
}
inline ::execution::Header* GetHeaderResponse::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::execution::Header* GetHeaderResponse::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.GetHeaderResponse.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::execution::Header* GetHeaderResponse::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::execution::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::execution::Header*>(p);
  }
  return _impl_.header_;
}
inline ::execution::Header* GetHeaderResponse::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::execution::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:execution.GetHeaderResponse.header)
  return _msg;
}
inline void GetHeaderResponse::set_allocated_header(::execution::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::execution::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.GetHeaderResponse.header)
}

// -------------------------------------------------------------------

// GetTDResponse

// optional .types.H256 td = 1;
inline bool GetTDResponse::has_td() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.td_ != nullptr);
  return value;
}
inline const ::types::H256& GetTDResponse::_internal_td() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.td_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& GetTDResponse::td() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.GetTDResponse.td)
  return _internal_td();
}
inline void GetTDResponse::unsafe_arena_set_allocated_td(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.td_);
  }
  _impl_.td_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.GetTDResponse.td)
}
inline ::types::H256* GetTDResponse::release_td() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.td_;
  _impl_.td_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* GetTDResponse::unsafe_arena_release_td() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.GetTDResponse.td)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.td_;
  _impl_.td_ = nullptr;
  return temp;
}
inline ::types::H256* GetTDResponse::_internal_mutable_td() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.td_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.td_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.td_;
}
inline ::types::H256* GetTDResponse::mutable_td() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_td();
  // @@protoc_insertion_point(field_mutable:execution.GetTDResponse.td)
  return _msg;
}
inline void GetTDResponse::set_allocated_td(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.td_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.td_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.GetTDResponse.td)
}

// -------------------------------------------------------------------

// GetBodyResponse

// optional .execution.BlockBody body = 1;
inline bool GetBodyResponse::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline void GetBodyResponse::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::execution::BlockBody& GetBodyResponse::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::execution::BlockBody* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::execution::BlockBody&>(::execution::_BlockBody_default_instance_);
}
inline const ::execution::BlockBody& GetBodyResponse::body() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.GetBodyResponse.body)
  return _internal_body();
}
inline void GetBodyResponse::unsafe_arena_set_allocated_body(::execution::BlockBody* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = reinterpret_cast<::execution::BlockBody*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.GetBodyResponse.body)
}
inline ::execution::BlockBody* GetBodyResponse::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::BlockBody* released = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::execution::BlockBody* GetBodyResponse::unsafe_arena_release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.GetBodyResponse.body)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::BlockBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::execution::BlockBody* GetBodyResponse::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::execution::BlockBody>(GetArena());
    _impl_.body_ = reinterpret_cast<::execution::BlockBody*>(p);
  }
  return _impl_.body_;
}
inline ::execution::BlockBody* GetBodyResponse::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::execution::BlockBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:execution.GetBodyResponse.body)
  return _msg;
}
inline void GetBodyResponse::set_allocated_body(::execution::BlockBody* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.body_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.body_ = reinterpret_cast<::execution::BlockBody*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.GetBodyResponse.body)
}

// -------------------------------------------------------------------

// GetHeaderHashNumberResponse

// optional uint64 block_number = 1;
inline bool GetHeaderHashNumberResponse::has_block_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetHeaderHashNumberResponse::clear_block_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t GetHeaderHashNumberResponse::block_number() const {
  // @@protoc_insertion_point(field_get:execution.GetHeaderHashNumberResponse.block_number)
  return _internal_block_number();
}
inline void GetHeaderHashNumberResponse::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:execution.GetHeaderHashNumberResponse.block_number)
}
inline ::uint64_t GetHeaderHashNumberResponse::_internal_block_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_number_;
}
inline void GetHeaderHashNumberResponse::_internal_set_block_number(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = value;
}

// -------------------------------------------------------------------

// GetSegmentRequest

// optional uint64 block_number = 1;
inline bool GetSegmentRequest::has_block_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetSegmentRequest::clear_block_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t GetSegmentRequest::block_number() const {
  // @@protoc_insertion_point(field_get:execution.GetSegmentRequest.block_number)
  return _internal_block_number();
}
inline void GetSegmentRequest::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:execution.GetSegmentRequest.block_number)
}
inline ::uint64_t GetSegmentRequest::_internal_block_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_number_;
}
inline void GetSegmentRequest::_internal_set_block_number(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = value;
}

// optional .types.H256 block_hash = 2;
inline bool GetSegmentRequest::has_block_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_hash_ != nullptr);
  return value;
}
inline const ::types::H256& GetSegmentRequest::_internal_block_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& GetSegmentRequest::block_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.GetSegmentRequest.block_hash)
  return _internal_block_hash();
}
inline void GetSegmentRequest::unsafe_arena_set_allocated_block_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.GetSegmentRequest.block_hash)
}
inline ::types::H256* GetSegmentRequest::release_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* GetSegmentRequest::unsafe_arena_release_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.GetSegmentRequest.block_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* GetSegmentRequest::_internal_mutable_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.block_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.block_hash_;
}
inline ::types::H256* GetSegmentRequest::mutable_block_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.GetSegmentRequest.block_hash)
  return _msg;
}
inline void GetSegmentRequest::set_allocated_block_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.block_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.GetSegmentRequest.block_hash)
}

// -------------------------------------------------------------------

// InsertBlocksRequest

// repeated .execution.Block blocks = 1;
inline int InsertBlocksRequest::_internal_blocks_size() const {
  return _internal_blocks().size();
}
inline int InsertBlocksRequest::blocks_size() const {
  return _internal_blocks_size();
}
inline void InsertBlocksRequest::clear_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_.Clear();
}
inline ::execution::Block* InsertBlocksRequest::mutable_blocks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:execution.InsertBlocksRequest.blocks)
  return _internal_mutable_blocks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::execution::Block>* InsertBlocksRequest::mutable_blocks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:execution.InsertBlocksRequest.blocks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_blocks();
}
inline const ::execution::Block& InsertBlocksRequest::blocks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.InsertBlocksRequest.blocks)
  return _internal_blocks().Get(index);
}
inline ::execution::Block* InsertBlocksRequest::add_blocks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::execution::Block* _add = _internal_mutable_blocks()->Add();
  // @@protoc_insertion_point(field_add:execution.InsertBlocksRequest.blocks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::execution::Block>& InsertBlocksRequest::blocks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:execution.InsertBlocksRequest.blocks)
  return _internal_blocks();
}
inline const ::google::protobuf::RepeatedPtrField<::execution::Block>&
InsertBlocksRequest::_internal_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_;
}
inline ::google::protobuf::RepeatedPtrField<::execution::Block>*
InsertBlocksRequest::_internal_mutable_blocks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.blocks_;
}

// -------------------------------------------------------------------

// ForkChoice

// .types.H256 head_block_hash = 1;
inline bool ForkChoice::has_head_block_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.head_block_hash_ != nullptr);
  return value;
}
inline const ::types::H256& ForkChoice::_internal_head_block_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.head_block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ForkChoice::head_block_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.ForkChoice.head_block_hash)
  return _internal_head_block_hash();
}
inline void ForkChoice::unsafe_arena_set_allocated_head_block_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.head_block_hash_);
  }
  _impl_.head_block_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ForkChoice.head_block_hash)
}
inline ::types::H256* ForkChoice::release_head_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.head_block_hash_;
  _impl_.head_block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ForkChoice::unsafe_arena_release_head_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.ForkChoice.head_block_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.head_block_hash_;
  _impl_.head_block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ForkChoice::_internal_mutable_head_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.head_block_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.head_block_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.head_block_hash_;
}
inline ::types::H256* ForkChoice::mutable_head_block_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_head_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.ForkChoice.head_block_hash)
  return _msg;
}
inline void ForkChoice::set_allocated_head_block_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.head_block_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.head_block_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.ForkChoice.head_block_hash)
}

// uint64 timeout = 2;
inline void ForkChoice::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
}
inline ::uint64_t ForkChoice::timeout() const {
  // @@protoc_insertion_point(field_get:execution.ForkChoice.timeout)
  return _internal_timeout();
}
inline void ForkChoice::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:execution.ForkChoice.timeout)
}
inline ::uint64_t ForkChoice::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void ForkChoice::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// optional .types.H256 finalized_block_hash = 3;
inline bool ForkChoice::has_finalized_block_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.finalized_block_hash_ != nullptr);
  return value;
}
inline const ::types::H256& ForkChoice::_internal_finalized_block_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.finalized_block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ForkChoice::finalized_block_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.ForkChoice.finalized_block_hash)
  return _internal_finalized_block_hash();
}
inline void ForkChoice::unsafe_arena_set_allocated_finalized_block_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.finalized_block_hash_);
  }
  _impl_.finalized_block_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ForkChoice.finalized_block_hash)
}
inline ::types::H256* ForkChoice::release_finalized_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* released = _impl_.finalized_block_hash_;
  _impl_.finalized_block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ForkChoice::unsafe_arena_release_finalized_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.ForkChoice.finalized_block_hash)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* temp = _impl_.finalized_block_hash_;
  _impl_.finalized_block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ForkChoice::_internal_mutable_finalized_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.finalized_block_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.finalized_block_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.finalized_block_hash_;
}
inline ::types::H256* ForkChoice::mutable_finalized_block_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H256* _msg = _internal_mutable_finalized_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.ForkChoice.finalized_block_hash)
  return _msg;
}
inline void ForkChoice::set_allocated_finalized_block_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.finalized_block_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.finalized_block_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.ForkChoice.finalized_block_hash)
}

// optional .types.H256 safe_block_hash = 4;
inline bool ForkChoice::has_safe_block_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.safe_block_hash_ != nullptr);
  return value;
}
inline const ::types::H256& ForkChoice::_internal_safe_block_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.safe_block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ForkChoice::safe_block_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.ForkChoice.safe_block_hash)
  return _internal_safe_block_hash();
}
inline void ForkChoice::unsafe_arena_set_allocated_safe_block_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.safe_block_hash_);
  }
  _impl_.safe_block_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ForkChoice.safe_block_hash)
}
inline ::types::H256* ForkChoice::release_safe_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H256* released = _impl_.safe_block_hash_;
  _impl_.safe_block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ForkChoice::unsafe_arena_release_safe_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.ForkChoice.safe_block_hash)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H256* temp = _impl_.safe_block_hash_;
  _impl_.safe_block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ForkChoice::_internal_mutable_safe_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.safe_block_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.safe_block_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.safe_block_hash_;
}
inline ::types::H256* ForkChoice::mutable_safe_block_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::types::H256* _msg = _internal_mutable_safe_block_hash();
  // @@protoc_insertion_point(field_mutable:execution.ForkChoice.safe_block_hash)
  return _msg;
}
inline void ForkChoice::set_allocated_safe_block_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.safe_block_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.safe_block_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.ForkChoice.safe_block_hash)
}

// -------------------------------------------------------------------

// InsertionResult

// .execution.ExecutionStatus result = 1;
inline void InsertionResult::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::execution::ExecutionStatus InsertionResult::result() const {
  // @@protoc_insertion_point(field_get:execution.InsertionResult.result)
  return _internal_result();
}
inline void InsertionResult::set_result(::execution::ExecutionStatus value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:execution.InsertionResult.result)
}
inline ::execution::ExecutionStatus InsertionResult::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::execution::ExecutionStatus>(_impl_.result_);
}
inline void InsertionResult::_internal_set_result(::execution::ExecutionStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// ValidationRequest

// .types.H256 hash = 1;
inline bool ValidationRequest::has_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hash_ != nullptr);
  return value;
}
inline const ::types::H256& ValidationRequest::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ValidationRequest::hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.ValidationRequest.hash)
  return _internal_hash();
}
inline void ValidationRequest::unsafe_arena_set_allocated_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hash_);
  }
  _impl_.hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.ValidationRequest.hash)
}
inline ::types::H256* ValidationRequest::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.hash_;
  _impl_.hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ValidationRequest::unsafe_arena_release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.ValidationRequest.hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.hash_;
  _impl_.hash_ = nullptr;
  return temp;
}
inline ::types::H256* ValidationRequest::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.hash_;
}
inline ::types::H256* ValidationRequest::mutable_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:execution.ValidationRequest.hash)
  return _msg;
}
inline void ValidationRequest::set_allocated_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.ValidationRequest.hash)
}

// uint64 number = 2;
inline void ValidationRequest::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = ::uint64_t{0u};
}
inline ::uint64_t ValidationRequest::number() const {
  // @@protoc_insertion_point(field_get:execution.ValidationRequest.number)
  return _internal_number();
}
inline void ValidationRequest::set_number(::uint64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:execution.ValidationRequest.number)
}
inline ::uint64_t ValidationRequest::_internal_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_;
}
inline void ValidationRequest::_internal_set_number(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = value;
}

// -------------------------------------------------------------------

// AssembleBlockRequest

// .types.H256 parent_hash = 1;
inline bool AssembleBlockRequest::has_parent_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_hash_ != nullptr);
  return value;
}
inline const ::types::H256& AssembleBlockRequest::_internal_parent_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.parent_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& AssembleBlockRequest::parent_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembleBlockRequest.parent_hash)
  return _internal_parent_hash();
}
inline void AssembleBlockRequest::unsafe_arena_set_allocated_parent_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_hash_);
  }
  _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.AssembleBlockRequest.parent_hash)
}
inline ::types::H256* AssembleBlockRequest::release_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.parent_hash_;
  _impl_.parent_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* AssembleBlockRequest::unsafe_arena_release_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.AssembleBlockRequest.parent_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.parent_hash_;
  _impl_.parent_hash_ = nullptr;
  return temp;
}
inline ::types::H256* AssembleBlockRequest::_internal_mutable_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parent_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.parent_hash_;
}
inline ::types::H256* AssembleBlockRequest::mutable_parent_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:execution.AssembleBlockRequest.parent_hash)
  return _msg;
}
inline void AssembleBlockRequest::set_allocated_parent_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.AssembleBlockRequest.parent_hash)
}

// uint64 timestamp = 2;
inline void AssembleBlockRequest::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t AssembleBlockRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:execution.AssembleBlockRequest.timestamp)
  return _internal_timestamp();
}
inline void AssembleBlockRequest::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:execution.AssembleBlockRequest.timestamp)
}
inline ::uint64_t AssembleBlockRequest::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void AssembleBlockRequest::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// .types.H256 prev_randao = 3;
inline bool AssembleBlockRequest::has_prev_randao() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prev_randao_ != nullptr);
  return value;
}
inline const ::types::H256& AssembleBlockRequest::_internal_prev_randao() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.prev_randao_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& AssembleBlockRequest::prev_randao() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembleBlockRequest.prev_randao)
  return _internal_prev_randao();
}
inline void AssembleBlockRequest::unsafe_arena_set_allocated_prev_randao(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prev_randao_);
  }
  _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.AssembleBlockRequest.prev_randao)
}
inline ::types::H256* AssembleBlockRequest::release_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* released = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* AssembleBlockRequest::unsafe_arena_release_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.AssembleBlockRequest.prev_randao)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* temp = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
  return temp;
}
inline ::types::H256* AssembleBlockRequest::_internal_mutable_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.prev_randao_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.prev_randao_;
}
inline ::types::H256* AssembleBlockRequest::mutable_prev_randao() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H256* _msg = _internal_mutable_prev_randao();
  // @@protoc_insertion_point(field_mutable:execution.AssembleBlockRequest.prev_randao)
  return _msg;
}
inline void AssembleBlockRequest::set_allocated_prev_randao(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prev_randao_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.AssembleBlockRequest.prev_randao)
}

// .types.H160 suggested_fee_recipient = 4;
inline bool AssembleBlockRequest::has_suggested_fee_recipient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.suggested_fee_recipient_ != nullptr);
  return value;
}
inline const ::types::H160& AssembleBlockRequest::_internal_suggested_fee_recipient() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H160* p = _impl_.suggested_fee_recipient_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(::types::_H160_default_instance_);
}
inline const ::types::H160& AssembleBlockRequest::suggested_fee_recipient() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembleBlockRequest.suggested_fee_recipient)
  return _internal_suggested_fee_recipient();
}
inline void AssembleBlockRequest::unsafe_arena_set_allocated_suggested_fee_recipient(::types::H160* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.suggested_fee_recipient_);
  }
  _impl_.suggested_fee_recipient_ = reinterpret_cast<::types::H160*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.AssembleBlockRequest.suggested_fee_recipient)
}
inline ::types::H160* AssembleBlockRequest::release_suggested_fee_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H160* released = _impl_.suggested_fee_recipient_;
  _impl_.suggested_fee_recipient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H160* AssembleBlockRequest::unsafe_arena_release_suggested_fee_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.AssembleBlockRequest.suggested_fee_recipient)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H160* temp = _impl_.suggested_fee_recipient_;
  _impl_.suggested_fee_recipient_ = nullptr;
  return temp;
}
inline ::types::H160* AssembleBlockRequest::_internal_mutable_suggested_fee_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.suggested_fee_recipient_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H160>(GetArena());
    _impl_.suggested_fee_recipient_ = reinterpret_cast<::types::H160*>(p);
  }
  return _impl_.suggested_fee_recipient_;
}
inline ::types::H160* AssembleBlockRequest::mutable_suggested_fee_recipient() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::types::H160* _msg = _internal_mutable_suggested_fee_recipient();
  // @@protoc_insertion_point(field_mutable:execution.AssembleBlockRequest.suggested_fee_recipient)
  return _msg;
}
inline void AssembleBlockRequest::set_allocated_suggested_fee_recipient(::types::H160* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.suggested_fee_recipient_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.suggested_fee_recipient_ = reinterpret_cast<::types::H160*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.AssembleBlockRequest.suggested_fee_recipient)
}

// repeated .types.Withdrawal withdrawals = 5;
inline int AssembleBlockRequest::_internal_withdrawals_size() const {
  return _internal_withdrawals().size();
}
inline int AssembleBlockRequest::withdrawals_size() const {
  return _internal_withdrawals_size();
}
inline ::types::Withdrawal* AssembleBlockRequest::mutable_withdrawals(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:execution.AssembleBlockRequest.withdrawals)
  return _internal_mutable_withdrawals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* AssembleBlockRequest::mutable_withdrawals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:execution.AssembleBlockRequest.withdrawals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_withdrawals();
}
inline const ::types::Withdrawal& AssembleBlockRequest::withdrawals(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembleBlockRequest.withdrawals)
  return _internal_withdrawals().Get(index);
}
inline ::types::Withdrawal* AssembleBlockRequest::add_withdrawals() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::types::Withdrawal* _add = _internal_mutable_withdrawals()->Add();
  // @@protoc_insertion_point(field_add:execution.AssembleBlockRequest.withdrawals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& AssembleBlockRequest::withdrawals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:execution.AssembleBlockRequest.withdrawals)
  return _internal_withdrawals();
}
inline const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>&
AssembleBlockRequest::_internal_withdrawals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.withdrawals_;
}
inline ::google::protobuf::RepeatedPtrField<::types::Withdrawal>*
AssembleBlockRequest::_internal_mutable_withdrawals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.withdrawals_;
}

// optional .types.H256 parent_beacon_block_root = 6;
inline bool AssembleBlockRequest::has_parent_beacon_block_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_beacon_block_root_ != nullptr);
  return value;
}
inline const ::types::H256& AssembleBlockRequest::_internal_parent_beacon_block_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.parent_beacon_block_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& AssembleBlockRequest::parent_beacon_block_root() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembleBlockRequest.parent_beacon_block_root)
  return _internal_parent_beacon_block_root();
}
inline void AssembleBlockRequest::unsafe_arena_set_allocated_parent_beacon_block_root(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_beacon_block_root_);
  }
  _impl_.parent_beacon_block_root_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.AssembleBlockRequest.parent_beacon_block_root)
}
inline ::types::H256* AssembleBlockRequest::release_parent_beacon_block_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::types::H256* released = _impl_.parent_beacon_block_root_;
  _impl_.parent_beacon_block_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* AssembleBlockRequest::unsafe_arena_release_parent_beacon_block_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.AssembleBlockRequest.parent_beacon_block_root)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::types::H256* temp = _impl_.parent_beacon_block_root_;
  _impl_.parent_beacon_block_root_ = nullptr;
  return temp;
}
inline ::types::H256* AssembleBlockRequest::_internal_mutable_parent_beacon_block_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parent_beacon_block_root_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.parent_beacon_block_root_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.parent_beacon_block_root_;
}
inline ::types::H256* AssembleBlockRequest::mutable_parent_beacon_block_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::types::H256* _msg = _internal_mutable_parent_beacon_block_root();
  // @@protoc_insertion_point(field_mutable:execution.AssembleBlockRequest.parent_beacon_block_root)
  return _msg;
}
inline void AssembleBlockRequest::set_allocated_parent_beacon_block_root(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_beacon_block_root_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.parent_beacon_block_root_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.AssembleBlockRequest.parent_beacon_block_root)
}

// -------------------------------------------------------------------

// AssembleBlockResponse

// uint64 id = 1;
inline void AssembleBlockResponse::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t AssembleBlockResponse::id() const {
  // @@protoc_insertion_point(field_get:execution.AssembleBlockResponse.id)
  return _internal_id();
}
inline void AssembleBlockResponse::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:execution.AssembleBlockResponse.id)
}
inline ::uint64_t AssembleBlockResponse::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void AssembleBlockResponse::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// bool busy = 2;
inline void AssembleBlockResponse::clear_busy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.busy_ = false;
}
inline bool AssembleBlockResponse::busy() const {
  // @@protoc_insertion_point(field_get:execution.AssembleBlockResponse.busy)
  return _internal_busy();
}
inline void AssembleBlockResponse::set_busy(bool value) {
  _internal_set_busy(value);
  // @@protoc_insertion_point(field_set:execution.AssembleBlockResponse.busy)
}
inline bool AssembleBlockResponse::_internal_busy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.busy_;
}
inline void AssembleBlockResponse::_internal_set_busy(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.busy_ = value;
}

// -------------------------------------------------------------------

// GetAssembledBlockRequest

// uint64 id = 1;
inline void GetAssembledBlockRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t GetAssembledBlockRequest::id() const {
  // @@protoc_insertion_point(field_get:execution.GetAssembledBlockRequest.id)
  return _internal_id();
}
inline void GetAssembledBlockRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:execution.GetAssembledBlockRequest.id)
}
inline ::uint64_t GetAssembledBlockRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void GetAssembledBlockRequest::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// AssembledBlockData

// .types.ExecutionPayload execution_payload = 1;
inline bool AssembledBlockData::has_execution_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.execution_payload_ != nullptr);
  return value;
}
inline const ::types::ExecutionPayload& AssembledBlockData::_internal_execution_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::ExecutionPayload* p = _impl_.execution_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::ExecutionPayload&>(::types::_ExecutionPayload_default_instance_);
}
inline const ::types::ExecutionPayload& AssembledBlockData::execution_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembledBlockData.execution_payload)
  return _internal_execution_payload();
}
inline void AssembledBlockData::unsafe_arena_set_allocated_execution_payload(::types::ExecutionPayload* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.execution_payload_);
  }
  _impl_.execution_payload_ = reinterpret_cast<::types::ExecutionPayload*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.AssembledBlockData.execution_payload)
}
inline ::types::ExecutionPayload* AssembledBlockData::release_execution_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::ExecutionPayload* released = _impl_.execution_payload_;
  _impl_.execution_payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::ExecutionPayload* AssembledBlockData::unsafe_arena_release_execution_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.AssembledBlockData.execution_payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::ExecutionPayload* temp = _impl_.execution_payload_;
  _impl_.execution_payload_ = nullptr;
  return temp;
}
inline ::types::ExecutionPayload* AssembledBlockData::_internal_mutable_execution_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.execution_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::ExecutionPayload>(GetArena());
    _impl_.execution_payload_ = reinterpret_cast<::types::ExecutionPayload*>(p);
  }
  return _impl_.execution_payload_;
}
inline ::types::ExecutionPayload* AssembledBlockData::mutable_execution_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::ExecutionPayload* _msg = _internal_mutable_execution_payload();
  // @@protoc_insertion_point(field_mutable:execution.AssembledBlockData.execution_payload)
  return _msg;
}
inline void AssembledBlockData::set_allocated_execution_payload(::types::ExecutionPayload* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.execution_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.execution_payload_ = reinterpret_cast<::types::ExecutionPayload*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.AssembledBlockData.execution_payload)
}

// .types.H256 block_value = 2;
inline bool AssembledBlockData::has_block_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_value_ != nullptr);
  return value;
}
inline const ::types::H256& AssembledBlockData::_internal_block_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.block_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& AssembledBlockData::block_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembledBlockData.block_value)
  return _internal_block_value();
}
inline void AssembledBlockData::unsafe_arena_set_allocated_block_value(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_value_);
  }
  _impl_.block_value_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.AssembledBlockData.block_value)
}
inline ::types::H256* AssembledBlockData::release_block_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* released = _impl_.block_value_;
  _impl_.block_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* AssembledBlockData::unsafe_arena_release_block_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.AssembledBlockData.block_value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* temp = _impl_.block_value_;
  _impl_.block_value_ = nullptr;
  return temp;
}
inline ::types::H256* AssembledBlockData::_internal_mutable_block_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.block_value_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.block_value_;
}
inline ::types::H256* AssembledBlockData::mutable_block_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H256* _msg = _internal_mutable_block_value();
  // @@protoc_insertion_point(field_mutable:execution.AssembledBlockData.block_value)
  return _msg;
}
inline void AssembledBlockData::set_allocated_block_value(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.block_value_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.AssembledBlockData.block_value)
}

// .types.BlobsBundleV1 blobs_bundle = 3;
inline bool AssembledBlockData::has_blobs_bundle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.blobs_bundle_ != nullptr);
  return value;
}
inline const ::types::BlobsBundleV1& AssembledBlockData::_internal_blobs_bundle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::BlobsBundleV1* p = _impl_.blobs_bundle_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::BlobsBundleV1&>(::types::_BlobsBundleV1_default_instance_);
}
inline const ::types::BlobsBundleV1& AssembledBlockData::blobs_bundle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembledBlockData.blobs_bundle)
  return _internal_blobs_bundle();
}
inline void AssembledBlockData::unsafe_arena_set_allocated_blobs_bundle(::types::BlobsBundleV1* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blobs_bundle_);
  }
  _impl_.blobs_bundle_ = reinterpret_cast<::types::BlobsBundleV1*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.AssembledBlockData.blobs_bundle)
}
inline ::types::BlobsBundleV1* AssembledBlockData::release_blobs_bundle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::BlobsBundleV1* released = _impl_.blobs_bundle_;
  _impl_.blobs_bundle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::BlobsBundleV1* AssembledBlockData::unsafe_arena_release_blobs_bundle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.AssembledBlockData.blobs_bundle)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::BlobsBundleV1* temp = _impl_.blobs_bundle_;
  _impl_.blobs_bundle_ = nullptr;
  return temp;
}
inline ::types::BlobsBundleV1* AssembledBlockData::_internal_mutable_blobs_bundle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.blobs_bundle_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::BlobsBundleV1>(GetArena());
    _impl_.blobs_bundle_ = reinterpret_cast<::types::BlobsBundleV1*>(p);
  }
  return _impl_.blobs_bundle_;
}
inline ::types::BlobsBundleV1* AssembledBlockData::mutable_blobs_bundle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::types::BlobsBundleV1* _msg = _internal_mutable_blobs_bundle();
  // @@protoc_insertion_point(field_mutable:execution.AssembledBlockData.blobs_bundle)
  return _msg;
}
inline void AssembledBlockData::set_allocated_blobs_bundle(::types::BlobsBundleV1* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blobs_bundle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.blobs_bundle_ = reinterpret_cast<::types::BlobsBundleV1*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.AssembledBlockData.blobs_bundle)
}

// .types.RequestsBundle requests = 4;
inline bool AssembledBlockData::has_requests() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requests_ != nullptr);
  return value;
}
inline const ::types::RequestsBundle& AssembledBlockData::_internal_requests() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::RequestsBundle* p = _impl_.requests_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::RequestsBundle&>(::types::_RequestsBundle_default_instance_);
}
inline const ::types::RequestsBundle& AssembledBlockData::requests() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.AssembledBlockData.requests)
  return _internal_requests();
}
inline void AssembledBlockData::unsafe_arena_set_allocated_requests(::types::RequestsBundle* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requests_);
  }
  _impl_.requests_ = reinterpret_cast<::types::RequestsBundle*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.AssembledBlockData.requests)
}
inline ::types::RequestsBundle* AssembledBlockData::release_requests() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::types::RequestsBundle* released = _impl_.requests_;
  _impl_.requests_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::RequestsBundle* AssembledBlockData::unsafe_arena_release_requests() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.AssembledBlockData.requests)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::types::RequestsBundle* temp = _impl_.requests_;
  _impl_.requests_ = nullptr;
  return temp;
}
inline ::types::RequestsBundle* AssembledBlockData::_internal_mutable_requests() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.requests_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::RequestsBundle>(GetArena());
    _impl_.requests_ = reinterpret_cast<::types::RequestsBundle*>(p);
  }
  return _impl_.requests_;
}
inline ::types::RequestsBundle* AssembledBlockData::mutable_requests() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::types::RequestsBundle* _msg = _internal_mutable_requests();
  // @@protoc_insertion_point(field_mutable:execution.AssembledBlockData.requests)
  return _msg;
}
inline void AssembledBlockData::set_allocated_requests(::types::RequestsBundle* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requests_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.requests_ = reinterpret_cast<::types::RequestsBundle*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.AssembledBlockData.requests)
}

// -------------------------------------------------------------------

// GetAssembledBlockResponse

// optional .execution.AssembledBlockData data = 1;
inline bool GetAssembledBlockResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void GetAssembledBlockResponse::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::execution::AssembledBlockData& GetAssembledBlockResponse::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::execution::AssembledBlockData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::execution::AssembledBlockData&>(::execution::_AssembledBlockData_default_instance_);
}
inline const ::execution::AssembledBlockData& GetAssembledBlockResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.GetAssembledBlockResponse.data)
  return _internal_data();
}
inline void GetAssembledBlockResponse::unsafe_arena_set_allocated_data(::execution::AssembledBlockData* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::execution::AssembledBlockData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:execution.GetAssembledBlockResponse.data)
}
inline ::execution::AssembledBlockData* GetAssembledBlockResponse::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::AssembledBlockData* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::execution::AssembledBlockData* GetAssembledBlockResponse::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:execution.GetAssembledBlockResponse.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::execution::AssembledBlockData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::execution::AssembledBlockData* GetAssembledBlockResponse::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::execution::AssembledBlockData>(GetArena());
    _impl_.data_ = reinterpret_cast<::execution::AssembledBlockData*>(p);
  }
  return _impl_.data_;
}
inline ::execution::AssembledBlockData* GetAssembledBlockResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::execution::AssembledBlockData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:execution.GetAssembledBlockResponse.data)
  return _msg;
}
inline void GetAssembledBlockResponse::set_allocated_data(::execution::AssembledBlockData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::execution::AssembledBlockData*>(value);
  // @@protoc_insertion_point(field_set_allocated:execution.GetAssembledBlockResponse.data)
}

// bool busy = 2;
inline void GetAssembledBlockResponse::clear_busy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.busy_ = false;
}
inline bool GetAssembledBlockResponse::busy() const {
  // @@protoc_insertion_point(field_get:execution.GetAssembledBlockResponse.busy)
  return _internal_busy();
}
inline void GetAssembledBlockResponse::set_busy(bool value) {
  _internal_set_busy(value);
  // @@protoc_insertion_point(field_set:execution.GetAssembledBlockResponse.busy)
}
inline bool GetAssembledBlockResponse::_internal_busy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.busy_;
}
inline void GetAssembledBlockResponse::_internal_set_busy(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.busy_ = value;
}

// -------------------------------------------------------------------

// GetBodiesBatchResponse

// repeated .execution.BlockBody bodies = 1;
inline int GetBodiesBatchResponse::_internal_bodies_size() const {
  return _internal_bodies().size();
}
inline int GetBodiesBatchResponse::bodies_size() const {
  return _internal_bodies_size();
}
inline void GetBodiesBatchResponse::clear_bodies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bodies_.Clear();
}
inline ::execution::BlockBody* GetBodiesBatchResponse::mutable_bodies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:execution.GetBodiesBatchResponse.bodies)
  return _internal_mutable_bodies()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::execution::BlockBody>* GetBodiesBatchResponse::mutable_bodies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:execution.GetBodiesBatchResponse.bodies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bodies();
}
inline const ::execution::BlockBody& GetBodiesBatchResponse::bodies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.GetBodiesBatchResponse.bodies)
  return _internal_bodies().Get(index);
}
inline ::execution::BlockBody* GetBodiesBatchResponse::add_bodies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::execution::BlockBody* _add = _internal_mutable_bodies()->Add();
  // @@protoc_insertion_point(field_add:execution.GetBodiesBatchResponse.bodies)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::execution::BlockBody>& GetBodiesBatchResponse::bodies() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:execution.GetBodiesBatchResponse.bodies)
  return _internal_bodies();
}
inline const ::google::protobuf::RepeatedPtrField<::execution::BlockBody>&
GetBodiesBatchResponse::_internal_bodies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bodies_;
}
inline ::google::protobuf::RepeatedPtrField<::execution::BlockBody>*
GetBodiesBatchResponse::_internal_mutable_bodies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bodies_;
}

// -------------------------------------------------------------------

// GetBodiesByHashesRequest

// repeated .types.H256 hashes = 1;
inline int GetBodiesByHashesRequest::_internal_hashes_size() const {
  return _internal_hashes().size();
}
inline int GetBodiesByHashesRequest::hashes_size() const {
  return _internal_hashes_size();
}
inline ::types::H256* GetBodiesByHashesRequest::mutable_hashes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:execution.GetBodiesByHashesRequest.hashes)
  return _internal_mutable_hashes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::types::H256>* GetBodiesByHashesRequest::mutable_hashes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:execution.GetBodiesByHashesRequest.hashes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hashes();
}
inline const ::types::H256& GetBodiesByHashesRequest::hashes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:execution.GetBodiesByHashesRequest.hashes)
  return _internal_hashes().Get(index);
}
inline ::types::H256* GetBodiesByHashesRequest::add_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::types::H256* _add = _internal_mutable_hashes()->Add();
  // @@protoc_insertion_point(field_add:execution.GetBodiesByHashesRequest.hashes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::types::H256>& GetBodiesByHashesRequest::hashes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:execution.GetBodiesByHashesRequest.hashes)
  return _internal_hashes();
}
inline const ::google::protobuf::RepeatedPtrField<::types::H256>&
GetBodiesByHashesRequest::_internal_hashes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hashes_;
}
inline ::google::protobuf::RepeatedPtrField<::types::H256>*
GetBodiesByHashesRequest::_internal_mutable_hashes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hashes_;
}

// -------------------------------------------------------------------

// GetBodiesByRangeRequest

// uint64 start = 1;
inline void GetBodiesByRangeRequest::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = ::uint64_t{0u};
}
inline ::uint64_t GetBodiesByRangeRequest::start() const {
  // @@protoc_insertion_point(field_get:execution.GetBodiesByRangeRequest.start)
  return _internal_start();
}
inline void GetBodiesByRangeRequest::set_start(::uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:execution.GetBodiesByRangeRequest.start)
}
inline ::uint64_t GetBodiesByRangeRequest::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_;
}
inline void GetBodiesByRangeRequest::_internal_set_start(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = value;
}

// uint64 count = 2;
inline void GetBodiesByRangeRequest::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = ::uint64_t{0u};
}
inline ::uint64_t GetBodiesByRangeRequest::count() const {
  // @@protoc_insertion_point(field_get:execution.GetBodiesByRangeRequest.count)
  return _internal_count();
}
inline void GetBodiesByRangeRequest::set_count(::uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:execution.GetBodiesByRangeRequest.count)
}
inline ::uint64_t GetBodiesByRangeRequest::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void GetBodiesByRangeRequest::_internal_set_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// ReadyResponse

// bool ready = 1;
inline void ReadyResponse::clear_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ready_ = false;
}
inline bool ReadyResponse::ready() const {
  // @@protoc_insertion_point(field_get:execution.ReadyResponse.ready)
  return _internal_ready();
}
inline void ReadyResponse::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:execution.ReadyResponse.ready)
}
inline bool ReadyResponse::_internal_ready() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ready_;
}
inline void ReadyResponse::_internal_set_ready(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ready_ = value;
}

// -------------------------------------------------------------------

// FrozenBlocksResponse

// uint64 frozen_blocks = 1;
inline void FrozenBlocksResponse::clear_frozen_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frozen_blocks_ = ::uint64_t{0u};
}
inline ::uint64_t FrozenBlocksResponse::frozen_blocks() const {
  // @@protoc_insertion_point(field_get:execution.FrozenBlocksResponse.frozen_blocks)
  return _internal_frozen_blocks();
}
inline void FrozenBlocksResponse::set_frozen_blocks(::uint64_t value) {
  _internal_set_frozen_blocks(value);
  // @@protoc_insertion_point(field_set:execution.FrozenBlocksResponse.frozen_blocks)
}
inline ::uint64_t FrozenBlocksResponse::_internal_frozen_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frozen_blocks_;
}
inline void FrozenBlocksResponse::_internal_set_frozen_blocks(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frozen_blocks_ = value;
}

// bool has_gap = 2;
inline void FrozenBlocksResponse::clear_has_gap() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_gap_ = false;
}
inline bool FrozenBlocksResponse::has_gap() const {
  // @@protoc_insertion_point(field_get:execution.FrozenBlocksResponse.has_gap)
  return _internal_has_gap();
}
inline void FrozenBlocksResponse::set_has_gap(bool value) {
  _internal_set_has_gap(value);
  // @@protoc_insertion_point(field_set:execution.FrozenBlocksResponse.has_gap)
}
inline bool FrozenBlocksResponse::_internal_has_gap() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_gap_;
}
inline void FrozenBlocksResponse::_internal_set_has_gap(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_gap_ = value;
}

// -------------------------------------------------------------------

// HasBlockResponse

// bool has_block = 1;
inline void HasBlockResponse::clear_has_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_block_ = false;
}
inline bool HasBlockResponse::has_block() const {
  // @@protoc_insertion_point(field_get:execution.HasBlockResponse.has_block)
  return _internal_has_block();
}
inline void HasBlockResponse::set_has_block(bool value) {
  _internal_set_has_block(value);
  // @@protoc_insertion_point(field_set:execution.HasBlockResponse.has_block)
}
inline bool HasBlockResponse::_internal_has_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_block_;
}
inline void HasBlockResponse::_internal_set_has_block(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_block_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace execution


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::execution::ExecutionStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::execution::ExecutionStatus>() {
  return ::execution::ExecutionStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_execution_2fexecution_2eproto_2epb_2eh
