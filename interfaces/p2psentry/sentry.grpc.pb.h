// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: p2psentry/sentry.proto
#ifndef GRPC_p2psentry_2fsentry_2eproto__INCLUDED
#define GRPC_p2psentry_2fsentry_2eproto__INCLUDED

#include "p2psentry/sentry.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace sentry {

class Sentry final {
 public:
  static constexpr char const* service_full_name() {
    return "sentry.Sentry";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // SetStatus - force new ETH client state of sentry - network_id, max_block, etc...
    virtual ::grpc::Status SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::sentry::SetStatusReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>> AsyncSetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>>(AsyncSetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>> PrepareAsyncSetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>>(PrepareAsyncSetStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncPenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncPenalizePeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncPenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncPenalizePeerRaw(context, request, cq));
    }
    virtual ::grpc::Status PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncPeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncPeerMinBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncPeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncPeerMinBlockRaw(context, request, cq));
    }
    // HandShake - pre-requirement for all Send* methods - returns ETH protocol version,
    // without knowledge of protocol - impossible encode correct P2P message
    virtual ::grpc::Status HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sentry::HandShakeReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>> AsyncHandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>>(AsyncHandShakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>> PrepareAsyncHandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>>(PrepareAsyncHandShakeRaw(context, request, cq));
    }
    virtual ::grpc::Status SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::sentry::SentPeers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> AsyncSendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(AsyncSendMessageByMinBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> PrepareAsyncSendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(PrepareAsyncSendMessageByMinBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::sentry::SentPeers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> AsyncSendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(AsyncSendMessageByIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> PrepareAsyncSendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(PrepareAsyncSendMessageByIdRaw(context, request, cq));
    }
    virtual ::grpc::Status SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::sentry::SentPeers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> AsyncSendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(AsyncSendMessageToRandomPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> PrepareAsyncSendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(PrepareAsyncSendMessageToRandomPeersRaw(context, request, cq));
    }
    virtual ::grpc::Status SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::sentry::SentPeers* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> AsyncSendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(AsyncSendMessageToAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>> PrepareAsyncSendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>>(PrepareAsyncSendMessageToAllRaw(context, request, cq));
    }
    // Subscribe to receive messages.
    // Calling multiple times with a different set of ids starts separate streams.
    // It is possible to subscribe to the same set if ids more than once.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sentry::InboundMessage>> Messages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sentry::InboundMessage>>(MessagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>> AsyncMessages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>>(AsyncMessagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>> PrepareAsyncMessages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>>(PrepareAsyncMessagesRaw(context, request, cq));
    }
    virtual ::grpc::Status PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::sentry::PeerCountReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>> AsyncPeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>>(AsyncPeerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>> PrepareAsyncPeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>>(PrepareAsyncPeerCountRaw(context, request, cq));
    }
    // Notifications about connected (after sub-protocol handshake) or lost peer
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sentry::PeersReply>> Peers(::grpc::ClientContext* context, const ::sentry::PeersRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sentry::PeersReply>>(PeersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::PeersReply>> AsyncPeers(::grpc::ClientContext* context, const ::sentry::PeersRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::PeersReply>>(AsyncPeersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::PeersReply>> PrepareAsyncPeers(::grpc::ClientContext* context, const ::sentry::PeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentry::PeersReply>>(PrepareAsyncPeersRaw(context, request, cq));
    }
    // NodeInfo returns a collection of metadata known about the host.
    virtual ::grpc::Status NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::NodeInfoReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>> AsyncNodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>>(AsyncNodeInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>> PrepareAsyncNodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>>(PrepareAsyncNodeInfoRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // SetStatus - force new ETH client state of sentry - network_id, max_block, etc...
      virtual void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SetStatusReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SetStatusReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SetStatusReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PenalizePeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PenalizePeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PenalizePeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PeerMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PeerMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PeerMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // HandShake - pre-requirement for all Send* methods - returns ETH protocol version,
      // without knowledge of protocol - impossible encode correct P2P message
      virtual void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HandShake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::HandShakeReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void HandShake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::HandShakeReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void HandShake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::HandShakeReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMessageByMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMessageByMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMessageByMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMessageById(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMessageById(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMessageById(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendMessageToAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendMessageToAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendMessageToAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Subscribe to receive messages.
      // Calling multiple times with a different set of ids starts separate streams.
      // It is possible to subscribe to the same set if ids more than once.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Messages(::grpc::ClientContext* context, ::sentry::MessagesRequest* request, ::grpc::ClientReadReactor< ::sentry::InboundMessage>* reactor) = 0;
      #else
      virtual void Messages(::grpc::ClientContext* context, ::sentry::MessagesRequest* request, ::grpc::experimental::ClientReadReactor< ::sentry::InboundMessage>* reactor) = 0;
      #endif
      virtual void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PeerCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::PeerCountReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PeerCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::PeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PeerCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::PeerCountReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Notifications about connected (after sub-protocol handshake) or lost peer
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Peers(::grpc::ClientContext* context, ::sentry::PeersRequest* request, ::grpc::ClientReadReactor< ::sentry::PeersReply>* reactor) = 0;
      #else
      virtual void Peers(::grpc::ClientContext* context, ::sentry::PeersRequest* request, ::grpc::experimental::ClientReadReactor< ::sentry::PeersReply>* reactor) = 0;
      #endif
      // NodeInfo returns a collection of metadata known about the host.
      virtual void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::types::NodeInfoReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::types::NodeInfoReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::types::NodeInfoReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>* AsyncSetStatusRaw(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SetStatusReply>* PrepareAsyncSetStatusRaw(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncPenalizePeerRaw(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncPenalizePeerRaw(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncPeerMinBlockRaw(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncPeerMinBlockRaw(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>* AsyncHandShakeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::HandShakeReply>* PrepareAsyncHandShakeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* AsyncSendMessageByMinBlockRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* PrepareAsyncSendMessageByMinBlockRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* AsyncSendMessageByIdRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* PrepareAsyncSendMessageByIdRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* AsyncSendMessageToRandomPeersRaw(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* PrepareAsyncSendMessageToRandomPeersRaw(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* AsyncSendMessageToAllRaw(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::SentPeers>* PrepareAsyncSendMessageToAllRaw(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sentry::InboundMessage>* MessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>* AsyncMessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentry::InboundMessage>* PrepareAsyncMessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>* AsyncPeerCountRaw(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentry::PeerCountReply>* PrepareAsyncPeerCountRaw(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sentry::PeersReply>* PeersRaw(::grpc::ClientContext* context, const ::sentry::PeersRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentry::PeersReply>* AsyncPeersRaw(::grpc::ClientContext* context, const ::sentry::PeersRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentry::PeersReply>* PrepareAsyncPeersRaw(::grpc::ClientContext* context, const ::sentry::PeersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>* AsyncNodeInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::types::NodeInfoReply>* PrepareAsyncNodeInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::sentry::SetStatusReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>> AsyncSetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>>(AsyncSetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>> PrepareAsyncSetStatus(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>>(PrepareAsyncSetStatusRaw(context, request, cq));
    }
    ::grpc::Status PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncPenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncPenalizePeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncPenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncPenalizePeerRaw(context, request, cq));
    }
    ::grpc::Status PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncPeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncPeerMinBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncPeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncPeerMinBlockRaw(context, request, cq));
    }
    ::grpc::Status HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::sentry::HandShakeReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>> AsyncHandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>>(AsyncHandShakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>> PrepareAsyncHandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>>(PrepareAsyncHandShakeRaw(context, request, cq));
    }
    ::grpc::Status SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::sentry::SentPeers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> AsyncSendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(AsyncSendMessageByMinBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> PrepareAsyncSendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(PrepareAsyncSendMessageByMinBlockRaw(context, request, cq));
    }
    ::grpc::Status SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::sentry::SentPeers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> AsyncSendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(AsyncSendMessageByIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> PrepareAsyncSendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(PrepareAsyncSendMessageByIdRaw(context, request, cq));
    }
    ::grpc::Status SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::sentry::SentPeers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> AsyncSendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(AsyncSendMessageToRandomPeersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> PrepareAsyncSendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(PrepareAsyncSendMessageToRandomPeersRaw(context, request, cq));
    }
    ::grpc::Status SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::sentry::SentPeers* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> AsyncSendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(AsyncSendMessageToAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>> PrepareAsyncSendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>>(PrepareAsyncSendMessageToAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sentry::InboundMessage>> Messages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sentry::InboundMessage>>(MessagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::InboundMessage>> AsyncMessages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::InboundMessage>>(AsyncMessagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::InboundMessage>> PrepareAsyncMessages(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::InboundMessage>>(PrepareAsyncMessagesRaw(context, request, cq));
    }
    ::grpc::Status PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::sentry::PeerCountReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>> AsyncPeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>>(AsyncPeerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>> PrepareAsyncPeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>>(PrepareAsyncPeerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sentry::PeersReply>> Peers(::grpc::ClientContext* context, const ::sentry::PeersRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sentry::PeersReply>>(PeersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::PeersReply>> AsyncPeers(::grpc::ClientContext* context, const ::sentry::PeersRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::PeersReply>>(AsyncPeersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::PeersReply>> PrepareAsyncPeers(::grpc::ClientContext* context, const ::sentry::PeersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentry::PeersReply>>(PrepareAsyncPeersRaw(context, request, cq));
    }
    ::grpc::Status NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::NodeInfoReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>> AsyncNodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>>(AsyncNodeInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>> PrepareAsyncNodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>>(PrepareAsyncNodeInfoRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, std::function<void(::grpc::Status)>) override;
      void SetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SetStatusReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetStatus(::grpc::ClientContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SetStatusReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SetStatusReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void PenalizePeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PenalizePeer(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PenalizePeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PenalizePeer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void PeerMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PeerMinBlock(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PeerMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PeerMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, std::function<void(::grpc::Status)>) override;
      void HandShake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::HandShakeReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void HandShake(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void HandShake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::HandShakeReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void HandShake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::HandShakeReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      void SendMessageByMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMessageByMinBlock(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMessageByMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMessageByMinBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      void SendMessageById(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMessageById(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMessageById(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMessageById(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMessageToRandomPeers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      void SendMessageToAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMessageToAll(::grpc::ClientContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendMessageToAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendMessageToAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::SentPeers* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Messages(::grpc::ClientContext* context, ::sentry::MessagesRequest* request, ::grpc::ClientReadReactor< ::sentry::InboundMessage>* reactor) override;
      #else
      void Messages(::grpc::ClientContext* context, ::sentry::MessagesRequest* request, ::grpc::experimental::ClientReadReactor< ::sentry::InboundMessage>* reactor) override;
      #endif
      void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, std::function<void(::grpc::Status)>) override;
      void PeerCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::PeerCountReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PeerCount(::grpc::ClientContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PeerCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::PeerCountReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PeerCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sentry::PeerCountReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Peers(::grpc::ClientContext* context, ::sentry::PeersRequest* request, ::grpc::ClientReadReactor< ::sentry::PeersReply>* reactor) override;
      #else
      void Peers(::grpc::ClientContext* context, ::sentry::PeersRequest* request, ::grpc::experimental::ClientReadReactor< ::sentry::PeersReply>* reactor) override;
      #endif
      void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, std::function<void(::grpc::Status)>) override;
      void NodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::types::NodeInfoReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::types::NodeInfoReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::types::NodeInfoReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>* AsyncSetStatusRaw(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SetStatusReply>* PrepareAsyncSetStatusRaw(::grpc::ClientContext* context, const ::sentry::StatusData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncPenalizePeerRaw(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncPenalizePeerRaw(::grpc::ClientContext* context, const ::sentry::PenalizePeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncPeerMinBlockRaw(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncPeerMinBlockRaw(::grpc::ClientContext* context, const ::sentry::PeerMinBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>* AsyncHandShakeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::HandShakeReply>* PrepareAsyncHandShakeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* AsyncSendMessageByMinBlockRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* PrepareAsyncSendMessageByMinBlockRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByMinBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* AsyncSendMessageByIdRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* PrepareAsyncSendMessageByIdRaw(::grpc::ClientContext* context, const ::sentry::SendMessageByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* AsyncSendMessageToRandomPeersRaw(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* PrepareAsyncSendMessageToRandomPeersRaw(::grpc::ClientContext* context, const ::sentry::SendMessageToRandomPeersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* AsyncSendMessageToAllRaw(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::SentPeers>* PrepareAsyncSendMessageToAllRaw(::grpc::ClientContext* context, const ::sentry::OutboundMessageData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sentry::InboundMessage>* MessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request) override;
    ::grpc::ClientAsyncReader< ::sentry::InboundMessage>* AsyncMessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sentry::InboundMessage>* PrepareAsyncMessagesRaw(::grpc::ClientContext* context, const ::sentry::MessagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>* AsyncPeerCountRaw(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentry::PeerCountReply>* PrepareAsyncPeerCountRaw(::grpc::ClientContext* context, const ::sentry::PeerCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sentry::PeersReply>* PeersRaw(::grpc::ClientContext* context, const ::sentry::PeersRequest& request) override;
    ::grpc::ClientAsyncReader< ::sentry::PeersReply>* AsyncPeersRaw(::grpc::ClientContext* context, const ::sentry::PeersRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sentry::PeersReply>* PrepareAsyncPeersRaw(::grpc::ClientContext* context, const ::sentry::PeersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>* AsyncNodeInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::types::NodeInfoReply>* PrepareAsyncNodeInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_PenalizePeer_;
    const ::grpc::internal::RpcMethod rpcmethod_PeerMinBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_HandShake_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMessageByMinBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMessageById_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMessageToRandomPeers_;
    const ::grpc::internal::RpcMethod rpcmethod_SendMessageToAll_;
    const ::grpc::internal::RpcMethod rpcmethod_Messages_;
    const ::grpc::internal::RpcMethod rpcmethod_PeerCount_;
    const ::grpc::internal::RpcMethod rpcmethod_Peers_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // SetStatus - force new ETH client state of sentry - network_id, max_block, etc...
    virtual ::grpc::Status SetStatus(::grpc::ServerContext* context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response);
    virtual ::grpc::Status PenalizePeer(::grpc::ServerContext* context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status PeerMinBlock(::grpc::ServerContext* context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response);
    // HandShake - pre-requirement for all Send* methods - returns ETH protocol version,
    // without knowledge of protocol - impossible encode correct P2P message
    virtual ::grpc::Status HandShake(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response);
    virtual ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response);
    virtual ::grpc::Status SendMessageById(::grpc::ServerContext* context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response);
    virtual ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response);
    virtual ::grpc::Status SendMessageToAll(::grpc::ServerContext* context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response);
    // Subscribe to receive messages.
    // Calling multiple times with a different set of ids starts separate streams.
    // It is possible to subscribe to the same set if ids more than once.
    virtual ::grpc::Status Messages(::grpc::ServerContext* context, const ::sentry::MessagesRequest* request, ::grpc::ServerWriter< ::sentry::InboundMessage>* writer);
    virtual ::grpc::Status PeerCount(::grpc::ServerContext* context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response);
    // Notifications about connected (after sub-protocol handshake) or lost peer
    virtual ::grpc::Status Peers(::grpc::ServerContext* context, const ::sentry::PeersRequest* request, ::grpc::ServerWriter< ::sentry::PeersReply>* writer);
    // NodeInfo returns a collection of metadata known about the host.
    virtual ::grpc::Status NodeInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetStatus() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStatus(::grpc::ServerContext* context, ::sentry::StatusData* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SetStatusReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPenalizePeer(::grpc::ServerContext* context, ::sentry::PenalizePeerRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerMinBlock(::grpc::ServerContext* context, ::sentry::PeerMinBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HandShake() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandShake(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::sentry::HandShakeReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageByMinBlock(::grpc::ServerContext* context, ::sentry::SendMessageByMinBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SentPeers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMessageById() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageById(::grpc::ServerContext* context, ::sentry::SendMessageByIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SentPeers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageToRandomPeers(::grpc::ServerContext* context, ::sentry::SendMessageToRandomPeersRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SentPeers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageToAll(::grpc::ServerContext* context, ::sentry::OutboundMessageData* request, ::grpc::ServerAsyncResponseWriter< ::sentry::SentPeers>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Messages() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMessages(::grpc::ServerContext* context, ::sentry::MessagesRequest* request, ::grpc::ServerAsyncWriter< ::sentry::InboundMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PeerCount() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerCount(::grpc::ServerContext* context, ::sentry::PeerCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentry::PeerCountReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Peers() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::sentry::PeersRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeersReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeers(::grpc::ServerContext* context, ::sentry::PeersRequest* request, ::grpc::ServerAsyncWriter< ::sentry::PeersReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(10, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeInfo() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeInfo(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::types::NodeInfoReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetStatus<WithAsyncMethod_PenalizePeer<WithAsyncMethod_PeerMinBlock<WithAsyncMethod_HandShake<WithAsyncMethod_SendMessageByMinBlock<WithAsyncMethod_SendMessageById<WithAsyncMethod_SendMessageToRandomPeers<WithAsyncMethod_SendMessageToAll<WithAsyncMethod_Messages<WithAsyncMethod_PeerCount<WithAsyncMethod_Peers<WithAsyncMethod_NodeInfo<Service > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sentry::StatusData, ::sentry::SetStatusReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::StatusData* request, ::sentry::SetStatusReply* response) { return this->SetStatus(context, request, response); }));}
    void SetMessageAllocatorFor_SetStatus(
        ::grpc::experimental::MessageAllocator< ::sentry::StatusData, ::sentry::SetStatusReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sentry::StatusData, ::sentry::SetStatusReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PenalizePeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::PenalizePeerRequest* request, ::google::protobuf::Empty* response) { return this->PenalizePeer(context, request, response); }));}
    void SetMessageAllocatorFor_PenalizePeer(
        ::grpc::experimental::MessageAllocator< ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PenalizePeer(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PenalizePeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PeerMinBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::PeerMinBlockRequest* request, ::google::protobuf::Empty* response) { return this->PeerMinBlock(context, request, response); }));}
    void SetMessageAllocatorFor_PeerMinBlock(
        ::grpc::experimental::MessageAllocator< ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PeerMinBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PeerMinBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_HandShake() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sentry::HandShakeReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::sentry::HandShakeReply* response) { return this->HandShake(context, request, response); }));}
    void SetMessageAllocatorFor_HandShake(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::sentry::HandShakeReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::sentry::HandShakeReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HandShake(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HandShake(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendMessageByMinBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::SendMessageByMinBlockRequest* request, ::sentry::SentPeers* response) { return this->SendMessageByMinBlock(context, request, response); }));}
    void SetMessageAllocatorFor_SendMessageByMinBlock(
        ::grpc::experimental::MessageAllocator< ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMessageByMinBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMessageByMinBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendMessageById() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::SendMessageByIdRequest* request, ::sentry::SentPeers* response) { return this->SendMessageById(context, request, response); }));}
    void SetMessageAllocatorFor_SendMessageById(
        ::grpc::experimental::MessageAllocator< ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMessageById(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMessageById(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendMessageToRandomPeers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::SendMessageToRandomPeersRequest* request, ::sentry::SentPeers* response) { return this->SendMessageToRandomPeers(context, request, response); }));}
    void SetMessageAllocatorFor_SendMessageToRandomPeers(
        ::grpc::experimental::MessageAllocator< ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMessageToRandomPeers(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMessageToRandomPeers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendMessageToAll() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sentry::OutboundMessageData, ::sentry::SentPeers>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::OutboundMessageData* request, ::sentry::SentPeers* response) { return this->SendMessageToAll(context, request, response); }));}
    void SetMessageAllocatorFor_SendMessageToAll(
        ::grpc::experimental::MessageAllocator< ::sentry::OutboundMessageData, ::sentry::SentPeers>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sentry::OutboundMessageData, ::sentry::SentPeers>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMessageToAll(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMessageToAll(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Messages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::sentry::MessagesRequest, ::sentry::InboundMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::MessagesRequest* request) { return this->Messages(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sentry::InboundMessage>* Messages(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sentry::InboundMessage>* Messages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PeerCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sentry::PeerCountRequest, ::sentry::PeerCountReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::PeerCountRequest* request, ::sentry::PeerCountReply* response) { return this->PeerCount(context, request, response); }));}
    void SetMessageAllocatorFor_PeerCount(
        ::grpc::experimental::MessageAllocator< ::sentry::PeerCountRequest, ::sentry::PeerCountReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sentry::PeerCountRequest, ::sentry::PeerCountReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PeerCount(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PeerCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Peers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::sentry::PeersRequest, ::sentry::PeersReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sentry::PeersRequest* request) { return this->Peers(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::sentry::PeersRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeersReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::sentry::PeersReply>* Peers(
      ::grpc::CallbackServerContext* /*context*/, const ::sentry::PeersRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::sentry::PeersReply>* Peers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sentry::PeersRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodeInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::types::NodeInfoReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::types::NodeInfoReply* response) { return this->NodeInfo(context, request, response); }));}
    void SetMessageAllocatorFor_NodeInfo(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::types::NodeInfoReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::types::NodeInfoReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SetStatus<ExperimentalWithCallbackMethod_PenalizePeer<ExperimentalWithCallbackMethod_PeerMinBlock<ExperimentalWithCallbackMethod_HandShake<ExperimentalWithCallbackMethod_SendMessageByMinBlock<ExperimentalWithCallbackMethod_SendMessageById<ExperimentalWithCallbackMethod_SendMessageToRandomPeers<ExperimentalWithCallbackMethod_SendMessageToAll<ExperimentalWithCallbackMethod_Messages<ExperimentalWithCallbackMethod_PeerCount<ExperimentalWithCallbackMethod_Peers<ExperimentalWithCallbackMethod_NodeInfo<Service > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SetStatus<ExperimentalWithCallbackMethod_PenalizePeer<ExperimentalWithCallbackMethod_PeerMinBlock<ExperimentalWithCallbackMethod_HandShake<ExperimentalWithCallbackMethod_SendMessageByMinBlock<ExperimentalWithCallbackMethod_SendMessageById<ExperimentalWithCallbackMethod_SendMessageToRandomPeers<ExperimentalWithCallbackMethod_SendMessageToAll<ExperimentalWithCallbackMethod_Messages<ExperimentalWithCallbackMethod_PeerCount<ExperimentalWithCallbackMethod_Peers<ExperimentalWithCallbackMethod_NodeInfo<Service > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetStatus() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HandShake() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMessageById() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Messages() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PeerCount() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Peers() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::sentry::PeersRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeersReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeInfo() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetStatus() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPenalizePeer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerMinBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HandShake() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandShake(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageByMinBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMessageById() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageById(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageToRandomPeers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendMessageToAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Messages() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMessages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PeerCount() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Peers() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::sentry::PeersRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeersReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(10, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeInfo() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PenalizePeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PenalizePeer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PenalizePeer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PenalizePeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PeerMinBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PeerMinBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PeerMinBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PeerMinBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_HandShake() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HandShake(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HandShake(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HandShake(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendMessageByMinBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMessageByMinBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMessageByMinBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMessageByMinBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendMessageById() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMessageById(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMessageById(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMessageById(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendMessageToRandomPeers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMessageToRandomPeers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMessageToRandomPeers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMessageToRandomPeers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendMessageToAll() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendMessageToAll(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendMessageToAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendMessageToAll(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Messages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->Messages(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Messages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* Messages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PeerCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PeerCount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PeerCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PeerCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Peers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->Peers(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::sentry::PeersRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeersReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Peers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* Peers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodeInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetStatus() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::StatusData, ::sentry::SetStatusReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::sentry::StatusData, ::sentry::SetStatusReply>* streamer) {
                       return this->StreamedSetStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetStatus(::grpc::ServerContext* /*context*/, const ::sentry::StatusData* /*request*/, ::sentry::SetStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::StatusData,::sentry::SetStatusReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PenalizePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PenalizePeer() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::sentry::PenalizePeerRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedPenalizePeer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PenalizePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PenalizePeer(::grpc::ServerContext* /*context*/, const ::sentry::PenalizePeerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPenalizePeer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::PenalizePeerRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PeerMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PeerMinBlock() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::sentry::PeerMinBlockRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedPeerMinBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PeerMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PeerMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::PeerMinBlockRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPeerMinBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::PeerMinBlockRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HandShake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HandShake() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::sentry::HandShakeReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::sentry::HandShakeReply>* streamer) {
                       return this->StreamedHandShake(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HandShake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HandShake(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::sentry::HandShakeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHandShake(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::sentry::HandShakeReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMessageByMinBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMessageByMinBlock() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::sentry::SendMessageByMinBlockRequest, ::sentry::SentPeers>* streamer) {
                       return this->StreamedSendMessageByMinBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendMessageByMinBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMessageByMinBlock(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByMinBlockRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMessageByMinBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::SendMessageByMinBlockRequest,::sentry::SentPeers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMessageById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMessageById() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::sentry::SendMessageByIdRequest, ::sentry::SentPeers>* streamer) {
                       return this->StreamedSendMessageById(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendMessageById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMessageById(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageByIdRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMessageById(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::SendMessageByIdRequest,::sentry::SentPeers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMessageToRandomPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMessageToRandomPeers() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::sentry::SendMessageToRandomPeersRequest, ::sentry::SentPeers>* streamer) {
                       return this->StreamedSendMessageToRandomPeers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendMessageToRandomPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMessageToRandomPeers(::grpc::ServerContext* /*context*/, const ::sentry::SendMessageToRandomPeersRequest* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMessageToRandomPeers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::SendMessageToRandomPeersRequest,::sentry::SentPeers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendMessageToAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendMessageToAll() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::OutboundMessageData, ::sentry::SentPeers>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::sentry::OutboundMessageData, ::sentry::SentPeers>* streamer) {
                       return this->StreamedSendMessageToAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendMessageToAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendMessageToAll(::grpc::ServerContext* /*context*/, const ::sentry::OutboundMessageData* /*request*/, ::sentry::SentPeers* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendMessageToAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::OutboundMessageData,::sentry::SentPeers>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PeerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PeerCount() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentry::PeerCountRequest, ::sentry::PeerCountReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::sentry::PeerCountRequest, ::sentry::PeerCountReply>* streamer) {
                       return this->StreamedPeerCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PeerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PeerCount(::grpc::ServerContext* /*context*/, const ::sentry::PeerCountRequest* /*request*/, ::sentry::PeerCountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPeerCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentry::PeerCountRequest,::sentry::PeerCountReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeInfo() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::types::NodeInfoReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::types::NodeInfoReply>* streamer) {
                       return this->StreamedNodeInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeInfo(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::types::NodeInfoReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::types::NodeInfoReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetStatus<WithStreamedUnaryMethod_PenalizePeer<WithStreamedUnaryMethod_PeerMinBlock<WithStreamedUnaryMethod_HandShake<WithStreamedUnaryMethod_SendMessageByMinBlock<WithStreamedUnaryMethod_SendMessageById<WithStreamedUnaryMethod_SendMessageToRandomPeers<WithStreamedUnaryMethod_SendMessageToAll<WithStreamedUnaryMethod_PeerCount<WithStreamedUnaryMethod_NodeInfo<Service > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Messages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Messages() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::sentry::MessagesRequest, ::sentry::InboundMessage>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::sentry::MessagesRequest, ::sentry::InboundMessage>* streamer) {
                       return this->StreamedMessages(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Messages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Messages(::grpc::ServerContext* /*context*/, const ::sentry::MessagesRequest* /*request*/, ::grpc::ServerWriter< ::sentry::InboundMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedMessages(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::sentry::MessagesRequest,::sentry::InboundMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_Peers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Peers() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::sentry::PeersRequest, ::sentry::PeersReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::sentry::PeersRequest, ::sentry::PeersReply>* streamer) {
                       return this->StreamedPeers(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Peers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Peers(::grpc::ServerContext* /*context*/, const ::sentry::PeersRequest* /*request*/, ::grpc::ServerWriter< ::sentry::PeersReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedPeers(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::sentry::PeersRequest,::sentry::PeersReply>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Messages<WithSplitStreamingMethod_Peers<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetStatus<WithStreamedUnaryMethod_PenalizePeer<WithStreamedUnaryMethod_PeerMinBlock<WithStreamedUnaryMethod_HandShake<WithStreamedUnaryMethod_SendMessageByMinBlock<WithStreamedUnaryMethod_SendMessageById<WithStreamedUnaryMethod_SendMessageToRandomPeers<WithStreamedUnaryMethod_SendMessageToAll<WithSplitStreamingMethod_Messages<WithStreamedUnaryMethod_PeerCount<WithSplitStreamingMethod_Peers<WithStreamedUnaryMethod_NodeInfo<Service > > > > > > > > > > > > StreamedService;
};

}  // namespace sentry


#endif  // GRPC_p2psentry_2fsentry_2eproto__INCLUDED
