// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: txpool/mining.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_txpool_2fmining_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_txpool_2fmining_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_txpool_2fmining_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_txpool_2fmining_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_txpool_2fmining_2eproto;
namespace txpool {
class GetWorkReply;
struct GetWorkReplyDefaultTypeInternal;
extern GetWorkReplyDefaultTypeInternal _GetWorkReply_default_instance_;
class GetWorkRequest;
struct GetWorkRequestDefaultTypeInternal;
extern GetWorkRequestDefaultTypeInternal _GetWorkRequest_default_instance_;
class HashRateReply;
struct HashRateReplyDefaultTypeInternal;
extern HashRateReplyDefaultTypeInternal _HashRateReply_default_instance_;
class HashRateRequest;
struct HashRateRequestDefaultTypeInternal;
extern HashRateRequestDefaultTypeInternal _HashRateRequest_default_instance_;
class MiningReply;
struct MiningReplyDefaultTypeInternal;
extern MiningReplyDefaultTypeInternal _MiningReply_default_instance_;
class MiningRequest;
struct MiningRequestDefaultTypeInternal;
extern MiningRequestDefaultTypeInternal _MiningRequest_default_instance_;
class OnMinedBlockReply;
struct OnMinedBlockReplyDefaultTypeInternal;
extern OnMinedBlockReplyDefaultTypeInternal _OnMinedBlockReply_default_instance_;
class OnMinedBlockRequest;
struct OnMinedBlockRequestDefaultTypeInternal;
extern OnMinedBlockRequestDefaultTypeInternal _OnMinedBlockRequest_default_instance_;
class OnPendingBlockReply;
struct OnPendingBlockReplyDefaultTypeInternal;
extern OnPendingBlockReplyDefaultTypeInternal _OnPendingBlockReply_default_instance_;
class OnPendingBlockRequest;
struct OnPendingBlockRequestDefaultTypeInternal;
extern OnPendingBlockRequestDefaultTypeInternal _OnPendingBlockRequest_default_instance_;
class OnPendingLogsReply;
struct OnPendingLogsReplyDefaultTypeInternal;
extern OnPendingLogsReplyDefaultTypeInternal _OnPendingLogsReply_default_instance_;
class OnPendingLogsRequest;
struct OnPendingLogsRequestDefaultTypeInternal;
extern OnPendingLogsRequestDefaultTypeInternal _OnPendingLogsRequest_default_instance_;
class SubmitHashRateReply;
struct SubmitHashRateReplyDefaultTypeInternal;
extern SubmitHashRateReplyDefaultTypeInternal _SubmitHashRateReply_default_instance_;
class SubmitHashRateRequest;
struct SubmitHashRateRequestDefaultTypeInternal;
extern SubmitHashRateRequestDefaultTypeInternal _SubmitHashRateRequest_default_instance_;
class SubmitWorkReply;
struct SubmitWorkReplyDefaultTypeInternal;
extern SubmitWorkReplyDefaultTypeInternal _SubmitWorkReply_default_instance_;
class SubmitWorkRequest;
struct SubmitWorkRequestDefaultTypeInternal;
extern SubmitWorkRequestDefaultTypeInternal _SubmitWorkRequest_default_instance_;
}  // namespace txpool
PROTOBUF_NAMESPACE_OPEN
template<> ::txpool::GetWorkReply* Arena::CreateMaybeMessage<::txpool::GetWorkReply>(Arena*);
template<> ::txpool::GetWorkRequest* Arena::CreateMaybeMessage<::txpool::GetWorkRequest>(Arena*);
template<> ::txpool::HashRateReply* Arena::CreateMaybeMessage<::txpool::HashRateReply>(Arena*);
template<> ::txpool::HashRateRequest* Arena::CreateMaybeMessage<::txpool::HashRateRequest>(Arena*);
template<> ::txpool::MiningReply* Arena::CreateMaybeMessage<::txpool::MiningReply>(Arena*);
template<> ::txpool::MiningRequest* Arena::CreateMaybeMessage<::txpool::MiningRequest>(Arena*);
template<> ::txpool::OnMinedBlockReply* Arena::CreateMaybeMessage<::txpool::OnMinedBlockReply>(Arena*);
template<> ::txpool::OnMinedBlockRequest* Arena::CreateMaybeMessage<::txpool::OnMinedBlockRequest>(Arena*);
template<> ::txpool::OnPendingBlockReply* Arena::CreateMaybeMessage<::txpool::OnPendingBlockReply>(Arena*);
template<> ::txpool::OnPendingBlockRequest* Arena::CreateMaybeMessage<::txpool::OnPendingBlockRequest>(Arena*);
template<> ::txpool::OnPendingLogsReply* Arena::CreateMaybeMessage<::txpool::OnPendingLogsReply>(Arena*);
template<> ::txpool::OnPendingLogsRequest* Arena::CreateMaybeMessage<::txpool::OnPendingLogsRequest>(Arena*);
template<> ::txpool::SubmitHashRateReply* Arena::CreateMaybeMessage<::txpool::SubmitHashRateReply>(Arena*);
template<> ::txpool::SubmitHashRateRequest* Arena::CreateMaybeMessage<::txpool::SubmitHashRateRequest>(Arena*);
template<> ::txpool::SubmitWorkReply* Arena::CreateMaybeMessage<::txpool::SubmitWorkReply>(Arena*);
template<> ::txpool::SubmitWorkRequest* Arena::CreateMaybeMessage<::txpool::SubmitWorkRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace txpool {

// ===================================================================

class OnPendingBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.OnPendingBlockRequest) */ {
 public:
  inline OnPendingBlockRequest() : OnPendingBlockRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OnPendingBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPendingBlockRequest(const OnPendingBlockRequest& from);
  OnPendingBlockRequest(OnPendingBlockRequest&& from) noexcept
    : OnPendingBlockRequest() {
    *this = ::std::move(from);
  }

  inline OnPendingBlockRequest& operator=(const OnPendingBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPendingBlockRequest& operator=(OnPendingBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnPendingBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPendingBlockRequest* internal_default_instance() {
    return reinterpret_cast<const OnPendingBlockRequest*>(
               &_OnPendingBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OnPendingBlockRequest& a, OnPendingBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OnPendingBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPendingBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPendingBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPendingBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OnPendingBlockRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OnPendingBlockRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnPendingBlockRequest";
  }
  protected:
  explicit OnPendingBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.OnPendingBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnPendingBlockReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.OnPendingBlockReply) */ {
 public:
  inline OnPendingBlockReply() : OnPendingBlockReply(nullptr) {}
  ~OnPendingBlockReply() override;
  explicit PROTOBUF_CONSTEXPR OnPendingBlockReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPendingBlockReply(const OnPendingBlockReply& from);
  OnPendingBlockReply(OnPendingBlockReply&& from) noexcept
    : OnPendingBlockReply() {
    *this = ::std::move(from);
  }

  inline OnPendingBlockReply& operator=(const OnPendingBlockReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPendingBlockReply& operator=(OnPendingBlockReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnPendingBlockReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPendingBlockReply* internal_default_instance() {
    return reinterpret_cast<const OnPendingBlockReply*>(
               &_OnPendingBlockReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OnPendingBlockReply& a, OnPendingBlockReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OnPendingBlockReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPendingBlockReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPendingBlockReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPendingBlockReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnPendingBlockReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnPendingBlockReply& from) {
    OnPendingBlockReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnPendingBlockReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnPendingBlockReply";
  }
  protected:
  explicit OnPendingBlockReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRplBlockFieldNumber = 1,
  };
  // bytes rpl_block = 1;
  void clear_rpl_block();
  const std::string& rpl_block() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rpl_block(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rpl_block();
  PROTOBUF_NODISCARD std::string* release_rpl_block();
  void set_allocated_rpl_block(std::string* rpl_block);
  private:
  const std::string& _internal_rpl_block() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rpl_block(const std::string& value);
  std::string* _internal_mutable_rpl_block();
  public:

  // @@protoc_insertion_point(class_scope:txpool.OnPendingBlockReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpl_block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnMinedBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.OnMinedBlockRequest) */ {
 public:
  inline OnMinedBlockRequest() : OnMinedBlockRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OnMinedBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnMinedBlockRequest(const OnMinedBlockRequest& from);
  OnMinedBlockRequest(OnMinedBlockRequest&& from) noexcept
    : OnMinedBlockRequest() {
    *this = ::std::move(from);
  }

  inline OnMinedBlockRequest& operator=(const OnMinedBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnMinedBlockRequest& operator=(OnMinedBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnMinedBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnMinedBlockRequest* internal_default_instance() {
    return reinterpret_cast<const OnMinedBlockRequest*>(
               &_OnMinedBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OnMinedBlockRequest& a, OnMinedBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OnMinedBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnMinedBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnMinedBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnMinedBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OnMinedBlockRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OnMinedBlockRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnMinedBlockRequest";
  }
  protected:
  explicit OnMinedBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.OnMinedBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnMinedBlockReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.OnMinedBlockReply) */ {
 public:
  inline OnMinedBlockReply() : OnMinedBlockReply(nullptr) {}
  ~OnMinedBlockReply() override;
  explicit PROTOBUF_CONSTEXPR OnMinedBlockReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnMinedBlockReply(const OnMinedBlockReply& from);
  OnMinedBlockReply(OnMinedBlockReply&& from) noexcept
    : OnMinedBlockReply() {
    *this = ::std::move(from);
  }

  inline OnMinedBlockReply& operator=(const OnMinedBlockReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnMinedBlockReply& operator=(OnMinedBlockReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnMinedBlockReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnMinedBlockReply* internal_default_instance() {
    return reinterpret_cast<const OnMinedBlockReply*>(
               &_OnMinedBlockReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OnMinedBlockReply& a, OnMinedBlockReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OnMinedBlockReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnMinedBlockReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnMinedBlockReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnMinedBlockReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnMinedBlockReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnMinedBlockReply& from) {
    OnMinedBlockReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnMinedBlockReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnMinedBlockReply";
  }
  protected:
  explicit OnMinedBlockReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRplBlockFieldNumber = 1,
  };
  // bytes rpl_block = 1;
  void clear_rpl_block();
  const std::string& rpl_block() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rpl_block(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rpl_block();
  PROTOBUF_NODISCARD std::string* release_rpl_block();
  void set_allocated_rpl_block(std::string* rpl_block);
  private:
  const std::string& _internal_rpl_block() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rpl_block(const std::string& value);
  std::string* _internal_mutable_rpl_block();
  public:

  // @@protoc_insertion_point(class_scope:txpool.OnMinedBlockReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpl_block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnPendingLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.OnPendingLogsRequest) */ {
 public:
  inline OnPendingLogsRequest() : OnPendingLogsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OnPendingLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPendingLogsRequest(const OnPendingLogsRequest& from);
  OnPendingLogsRequest(OnPendingLogsRequest&& from) noexcept
    : OnPendingLogsRequest() {
    *this = ::std::move(from);
  }

  inline OnPendingLogsRequest& operator=(const OnPendingLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPendingLogsRequest& operator=(OnPendingLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnPendingLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPendingLogsRequest* internal_default_instance() {
    return reinterpret_cast<const OnPendingLogsRequest*>(
               &_OnPendingLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OnPendingLogsRequest& a, OnPendingLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OnPendingLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPendingLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPendingLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPendingLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OnPendingLogsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OnPendingLogsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnPendingLogsRequest";
  }
  protected:
  explicit OnPendingLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.OnPendingLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class OnPendingLogsReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.OnPendingLogsReply) */ {
 public:
  inline OnPendingLogsReply() : OnPendingLogsReply(nullptr) {}
  ~OnPendingLogsReply() override;
  explicit PROTOBUF_CONSTEXPR OnPendingLogsReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPendingLogsReply(const OnPendingLogsReply& from);
  OnPendingLogsReply(OnPendingLogsReply&& from) noexcept
    : OnPendingLogsReply() {
    *this = ::std::move(from);
  }

  inline OnPendingLogsReply& operator=(const OnPendingLogsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPendingLogsReply& operator=(OnPendingLogsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnPendingLogsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPendingLogsReply* internal_default_instance() {
    return reinterpret_cast<const OnPendingLogsReply*>(
               &_OnPendingLogsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OnPendingLogsReply& a, OnPendingLogsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OnPendingLogsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPendingLogsReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPendingLogsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPendingLogsReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnPendingLogsReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnPendingLogsReply& from) {
    OnPendingLogsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnPendingLogsReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.OnPendingLogsReply";
  }
  protected:
  explicit OnPendingLogsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRplLogsFieldNumber = 1,
  };
  // bytes rpl_logs = 1;
  void clear_rpl_logs();
  const std::string& rpl_logs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rpl_logs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rpl_logs();
  PROTOBUF_NODISCARD std::string* release_rpl_logs();
  void set_allocated_rpl_logs(std::string* rpl_logs);
  private:
  const std::string& _internal_rpl_logs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rpl_logs(const std::string& value);
  std::string* _internal_mutable_rpl_logs();
  public:

  // @@protoc_insertion_point(class_scope:txpool.OnPendingLogsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpl_logs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class GetWorkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.GetWorkRequest) */ {
 public:
  inline GetWorkRequest() : GetWorkRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetWorkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkRequest(const GetWorkRequest& from);
  GetWorkRequest(GetWorkRequest&& from) noexcept
    : GetWorkRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkRequest& operator=(const GetWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkRequest& operator=(GetWorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkRequest*>(
               &_GetWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetWorkRequest& a, GetWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetWorkRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetWorkRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.GetWorkRequest";
  }
  protected:
  explicit GetWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.GetWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class GetWorkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.GetWorkReply) */ {
 public:
  inline GetWorkReply() : GetWorkReply(nullptr) {}
  ~GetWorkReply() override;
  explicit PROTOBUF_CONSTEXPR GetWorkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkReply(const GetWorkReply& from);
  GetWorkReply(GetWorkReply&& from) noexcept
    : GetWorkReply() {
    *this = ::std::move(from);
  }

  inline GetWorkReply& operator=(const GetWorkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkReply& operator=(GetWorkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkReply* internal_default_instance() {
    return reinterpret_cast<const GetWorkReply*>(
               &_GetWorkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetWorkReply& a, GetWorkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWorkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWorkReply& from) {
    GetWorkReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.GetWorkReply";
  }
  protected:
  explicit GetWorkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderHashFieldNumber = 1,
    kSeedHashFieldNumber = 2,
    kTargetFieldNumber = 3,
    kBlockNumberFieldNumber = 4,
  };
  // string header_hash = 1;
  void clear_header_hash();
  const std::string& header_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header_hash();
  PROTOBUF_NODISCARD std::string* release_header_hash();
  void set_allocated_header_hash(std::string* header_hash);
  private:
  const std::string& _internal_header_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header_hash(const std::string& value);
  std::string* _internal_mutable_header_hash();
  public:

  // string seed_hash = 2;
  void clear_seed_hash();
  const std::string& seed_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seed_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seed_hash();
  PROTOBUF_NODISCARD std::string* release_seed_hash();
  void set_allocated_seed_hash(std::string* seed_hash);
  private:
  const std::string& _internal_seed_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seed_hash(const std::string& value);
  std::string* _internal_mutable_seed_hash();
  public:

  // string target = 3;
  void clear_target();
  const std::string& target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* target);
  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(const std::string& value);
  std::string* _internal_mutable_target();
  public:

  // string block_number = 4;
  void clear_block_number();
  const std::string& block_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_number();
  PROTOBUF_NODISCARD std::string* release_block_number();
  void set_allocated_block_number(std::string* block_number);
  private:
  const std::string& _internal_block_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_number(const std::string& value);
  std::string* _internal_mutable_block_number();
  public:

  // @@protoc_insertion_point(class_scope:txpool.GetWorkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seed_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.SubmitWorkRequest) */ {
 public:
  inline SubmitWorkRequest() : SubmitWorkRequest(nullptr) {}
  ~SubmitWorkRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitWorkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitWorkRequest(const SubmitWorkRequest& from);
  SubmitWorkRequest(SubmitWorkRequest&& from) noexcept
    : SubmitWorkRequest() {
    *this = ::std::move(from);
  }

  inline SubmitWorkRequest& operator=(const SubmitWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkRequest& operator=(SubmitWorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitWorkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitWorkRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkRequest*>(
               &_SubmitWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SubmitWorkRequest& a, SubmitWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitWorkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitWorkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitWorkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitWorkRequest& from) {
    SubmitWorkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitWorkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.SubmitWorkRequest";
  }
  protected:
  explicit SubmitWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockNonceFieldNumber = 1,
    kPowHashFieldNumber = 2,
    kDigestFieldNumber = 3,
  };
  // bytes block_nonce = 1;
  void clear_block_nonce();
  const std::string& block_nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_nonce();
  PROTOBUF_NODISCARD std::string* release_block_nonce();
  void set_allocated_block_nonce(std::string* block_nonce);
  private:
  const std::string& _internal_block_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_nonce(const std::string& value);
  std::string* _internal_mutable_block_nonce();
  public:

  // bytes pow_hash = 2;
  void clear_pow_hash();
  const std::string& pow_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pow_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pow_hash();
  PROTOBUF_NODISCARD std::string* release_pow_hash();
  void set_allocated_pow_hash(std::string* pow_hash);
  private:
  const std::string& _internal_pow_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pow_hash(const std::string& value);
  std::string* _internal_mutable_pow_hash();
  public:

  // bytes digest = 3;
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_NODISCARD std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // @@protoc_insertion_point(class_scope:txpool.SubmitWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_nonce_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pow_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.SubmitWorkReply) */ {
 public:
  inline SubmitWorkReply() : SubmitWorkReply(nullptr) {}
  ~SubmitWorkReply() override;
  explicit PROTOBUF_CONSTEXPR SubmitWorkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitWorkReply(const SubmitWorkReply& from);
  SubmitWorkReply(SubmitWorkReply&& from) noexcept
    : SubmitWorkReply() {
    *this = ::std::move(from);
  }

  inline SubmitWorkReply& operator=(const SubmitWorkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkReply& operator=(SubmitWorkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitWorkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitWorkReply* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkReply*>(
               &_SubmitWorkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SubmitWorkReply& a, SubmitWorkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitWorkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitWorkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitWorkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitWorkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitWorkReply& from) {
    SubmitWorkReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitWorkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.SubmitWorkReply";
  }
  protected:
  explicit SubmitWorkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.SubmitWorkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class SubmitHashRateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.SubmitHashRateRequest) */ {
 public:
  inline SubmitHashRateRequest() : SubmitHashRateRequest(nullptr) {}
  ~SubmitHashRateRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitHashRateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitHashRateRequest(const SubmitHashRateRequest& from);
  SubmitHashRateRequest(SubmitHashRateRequest&& from) noexcept
    : SubmitHashRateRequest() {
    *this = ::std::move(from);
  }

  inline SubmitHashRateRequest& operator=(const SubmitHashRateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitHashRateRequest& operator=(SubmitHashRateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitHashRateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitHashRateRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitHashRateRequest*>(
               &_SubmitHashRateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SubmitHashRateRequest& a, SubmitHashRateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitHashRateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitHashRateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitHashRateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitHashRateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitHashRateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitHashRateRequest& from) {
    SubmitHashRateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitHashRateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.SubmitHashRateRequest";
  }
  protected:
  explicit SubmitHashRateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kRateFieldNumber = 1,
  };
  // bytes id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 rate = 1;
  void clear_rate();
  uint64_t rate() const;
  void set_rate(uint64_t value);
  private:
  uint64_t _internal_rate() const;
  void _internal_set_rate(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.SubmitHashRateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    uint64_t rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class SubmitHashRateReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.SubmitHashRateReply) */ {
 public:
  inline SubmitHashRateReply() : SubmitHashRateReply(nullptr) {}
  ~SubmitHashRateReply() override;
  explicit PROTOBUF_CONSTEXPR SubmitHashRateReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitHashRateReply(const SubmitHashRateReply& from);
  SubmitHashRateReply(SubmitHashRateReply&& from) noexcept
    : SubmitHashRateReply() {
    *this = ::std::move(from);
  }

  inline SubmitHashRateReply& operator=(const SubmitHashRateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitHashRateReply& operator=(SubmitHashRateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitHashRateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitHashRateReply* internal_default_instance() {
    return reinterpret_cast<const SubmitHashRateReply*>(
               &_SubmitHashRateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SubmitHashRateReply& a, SubmitHashRateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitHashRateReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitHashRateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitHashRateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitHashRateReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitHashRateReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitHashRateReply& from) {
    SubmitHashRateReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitHashRateReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.SubmitHashRateReply";
  }
  protected:
  explicit SubmitHashRateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.SubmitHashRateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class HashRateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.HashRateRequest) */ {
 public:
  inline HashRateRequest() : HashRateRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HashRateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashRateRequest(const HashRateRequest& from);
  HashRateRequest(HashRateRequest&& from) noexcept
    : HashRateRequest() {
    *this = ::std::move(from);
  }

  inline HashRateRequest& operator=(const HashRateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashRateRequest& operator=(HashRateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashRateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashRateRequest* internal_default_instance() {
    return reinterpret_cast<const HashRateRequest*>(
               &_HashRateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HashRateRequest& a, HashRateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HashRateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashRateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashRateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashRateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HashRateRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HashRateRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.HashRateRequest";
  }
  protected:
  explicit HashRateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.HashRateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class HashRateReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.HashRateReply) */ {
 public:
  inline HashRateReply() : HashRateReply(nullptr) {}
  ~HashRateReply() override;
  explicit PROTOBUF_CONSTEXPR HashRateReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashRateReply(const HashRateReply& from);
  HashRateReply(HashRateReply&& from) noexcept
    : HashRateReply() {
    *this = ::std::move(from);
  }

  inline HashRateReply& operator=(const HashRateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashRateReply& operator=(HashRateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashRateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashRateReply* internal_default_instance() {
    return reinterpret_cast<const HashRateReply*>(
               &_HashRateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HashRateReply& a, HashRateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HashRateReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashRateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashRateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashRateReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HashRateReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HashRateReply& from) {
    HashRateReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashRateReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.HashRateReply";
  }
  protected:
  explicit HashRateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashRateFieldNumber = 1,
  };
  // uint64 hash_rate = 1;
  void clear_hash_rate();
  uint64_t hash_rate() const;
  void set_hash_rate(uint64_t value);
  private:
  uint64_t _internal_hash_rate() const;
  void _internal_set_hash_rate(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.HashRateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hash_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class MiningRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:txpool.MiningRequest) */ {
 public:
  inline MiningRequest() : MiningRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MiningRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MiningRequest(const MiningRequest& from);
  MiningRequest(MiningRequest&& from) noexcept
    : MiningRequest() {
    *this = ::std::move(from);
  }

  inline MiningRequest& operator=(const MiningRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MiningRequest& operator=(MiningRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MiningRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MiningRequest* internal_default_instance() {
    return reinterpret_cast<const MiningRequest*>(
               &_MiningRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MiningRequest& a, MiningRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MiningRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MiningRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MiningRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MiningRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MiningRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MiningRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.MiningRequest";
  }
  protected:
  explicit MiningRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:txpool.MiningRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// -------------------------------------------------------------------

class MiningReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:txpool.MiningReply) */ {
 public:
  inline MiningReply() : MiningReply(nullptr) {}
  ~MiningReply() override;
  explicit PROTOBUF_CONSTEXPR MiningReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MiningReply(const MiningReply& from);
  MiningReply(MiningReply&& from) noexcept
    : MiningReply() {
    *this = ::std::move(from);
  }

  inline MiningReply& operator=(const MiningReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MiningReply& operator=(MiningReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MiningReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MiningReply* internal_default_instance() {
    return reinterpret_cast<const MiningReply*>(
               &_MiningReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MiningReply& a, MiningReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MiningReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MiningReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MiningReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MiningReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MiningReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MiningReply& from) {
    MiningReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MiningReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "txpool.MiningReply";
  }
  protected:
  explicit MiningReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kRunningFieldNumber = 2,
  };
  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool running = 2;
  void clear_running();
  bool running() const;
  void set_running(bool value);
  private:
  bool _internal_running() const;
  void _internal_set_running(bool value);
  public:

  // @@protoc_insertion_point(class_scope:txpool.MiningReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enabled_;
    bool running_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txpool_2fmining_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OnPendingBlockRequest

// -------------------------------------------------------------------

// OnPendingBlockReply

// bytes rpl_block = 1;
inline void OnPendingBlockReply::clear_rpl_block() {
  _impl_.rpl_block_.ClearToEmpty();
}
inline const std::string& OnPendingBlockReply::rpl_block() const {
  // @@protoc_insertion_point(field_get:txpool.OnPendingBlockReply.rpl_block)
  return _internal_rpl_block();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnPendingBlockReply::set_rpl_block(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rpl_block_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.OnPendingBlockReply.rpl_block)
}
inline std::string* OnPendingBlockReply::mutable_rpl_block() {
  std::string* _s = _internal_mutable_rpl_block();
  // @@protoc_insertion_point(field_mutable:txpool.OnPendingBlockReply.rpl_block)
  return _s;
}
inline const std::string& OnPendingBlockReply::_internal_rpl_block() const {
  return _impl_.rpl_block_.Get();
}
inline void OnPendingBlockReply::_internal_set_rpl_block(const std::string& value) {
  
  _impl_.rpl_block_.Set(value, GetArenaForAllocation());
}
inline std::string* OnPendingBlockReply::_internal_mutable_rpl_block() {
  
  return _impl_.rpl_block_.Mutable(GetArenaForAllocation());
}
inline std::string* OnPendingBlockReply::release_rpl_block() {
  // @@protoc_insertion_point(field_release:txpool.OnPendingBlockReply.rpl_block)
  return _impl_.rpl_block_.Release();
}
inline void OnPendingBlockReply::set_allocated_rpl_block(std::string* rpl_block) {
  if (rpl_block != nullptr) {
    
  } else {
    
  }
  _impl_.rpl_block_.SetAllocated(rpl_block, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rpl_block_.IsDefault()) {
    _impl_.rpl_block_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.OnPendingBlockReply.rpl_block)
}

// -------------------------------------------------------------------

// OnMinedBlockRequest

// -------------------------------------------------------------------

// OnMinedBlockReply

// bytes rpl_block = 1;
inline void OnMinedBlockReply::clear_rpl_block() {
  _impl_.rpl_block_.ClearToEmpty();
}
inline const std::string& OnMinedBlockReply::rpl_block() const {
  // @@protoc_insertion_point(field_get:txpool.OnMinedBlockReply.rpl_block)
  return _internal_rpl_block();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnMinedBlockReply::set_rpl_block(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rpl_block_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.OnMinedBlockReply.rpl_block)
}
inline std::string* OnMinedBlockReply::mutable_rpl_block() {
  std::string* _s = _internal_mutable_rpl_block();
  // @@protoc_insertion_point(field_mutable:txpool.OnMinedBlockReply.rpl_block)
  return _s;
}
inline const std::string& OnMinedBlockReply::_internal_rpl_block() const {
  return _impl_.rpl_block_.Get();
}
inline void OnMinedBlockReply::_internal_set_rpl_block(const std::string& value) {
  
  _impl_.rpl_block_.Set(value, GetArenaForAllocation());
}
inline std::string* OnMinedBlockReply::_internal_mutable_rpl_block() {
  
  return _impl_.rpl_block_.Mutable(GetArenaForAllocation());
}
inline std::string* OnMinedBlockReply::release_rpl_block() {
  // @@protoc_insertion_point(field_release:txpool.OnMinedBlockReply.rpl_block)
  return _impl_.rpl_block_.Release();
}
inline void OnMinedBlockReply::set_allocated_rpl_block(std::string* rpl_block) {
  if (rpl_block != nullptr) {
    
  } else {
    
  }
  _impl_.rpl_block_.SetAllocated(rpl_block, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rpl_block_.IsDefault()) {
    _impl_.rpl_block_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.OnMinedBlockReply.rpl_block)
}

// -------------------------------------------------------------------

// OnPendingLogsRequest

// -------------------------------------------------------------------

// OnPendingLogsReply

// bytes rpl_logs = 1;
inline void OnPendingLogsReply::clear_rpl_logs() {
  _impl_.rpl_logs_.ClearToEmpty();
}
inline const std::string& OnPendingLogsReply::rpl_logs() const {
  // @@protoc_insertion_point(field_get:txpool.OnPendingLogsReply.rpl_logs)
  return _internal_rpl_logs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnPendingLogsReply::set_rpl_logs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rpl_logs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.OnPendingLogsReply.rpl_logs)
}
inline std::string* OnPendingLogsReply::mutable_rpl_logs() {
  std::string* _s = _internal_mutable_rpl_logs();
  // @@protoc_insertion_point(field_mutable:txpool.OnPendingLogsReply.rpl_logs)
  return _s;
}
inline const std::string& OnPendingLogsReply::_internal_rpl_logs() const {
  return _impl_.rpl_logs_.Get();
}
inline void OnPendingLogsReply::_internal_set_rpl_logs(const std::string& value) {
  
  _impl_.rpl_logs_.Set(value, GetArenaForAllocation());
}
inline std::string* OnPendingLogsReply::_internal_mutable_rpl_logs() {
  
  return _impl_.rpl_logs_.Mutable(GetArenaForAllocation());
}
inline std::string* OnPendingLogsReply::release_rpl_logs() {
  // @@protoc_insertion_point(field_release:txpool.OnPendingLogsReply.rpl_logs)
  return _impl_.rpl_logs_.Release();
}
inline void OnPendingLogsReply::set_allocated_rpl_logs(std::string* rpl_logs) {
  if (rpl_logs != nullptr) {
    
  } else {
    
  }
  _impl_.rpl_logs_.SetAllocated(rpl_logs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rpl_logs_.IsDefault()) {
    _impl_.rpl_logs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.OnPendingLogsReply.rpl_logs)
}

// -------------------------------------------------------------------

// GetWorkRequest

// -------------------------------------------------------------------

// GetWorkReply

// string header_hash = 1;
inline void GetWorkReply::clear_header_hash() {
  _impl_.header_hash_.ClearToEmpty();
}
inline const std::string& GetWorkReply::header_hash() const {
  // @@protoc_insertion_point(field_get:txpool.GetWorkReply.header_hash)
  return _internal_header_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkReply::set_header_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.header_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.GetWorkReply.header_hash)
}
inline std::string* GetWorkReply::mutable_header_hash() {
  std::string* _s = _internal_mutable_header_hash();
  // @@protoc_insertion_point(field_mutable:txpool.GetWorkReply.header_hash)
  return _s;
}
inline const std::string& GetWorkReply::_internal_header_hash() const {
  return _impl_.header_hash_.Get();
}
inline void GetWorkReply::_internal_set_header_hash(const std::string& value) {
  
  _impl_.header_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkReply::_internal_mutable_header_hash() {
  
  return _impl_.header_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkReply::release_header_hash() {
  // @@protoc_insertion_point(field_release:txpool.GetWorkReply.header_hash)
  return _impl_.header_hash_.Release();
}
inline void GetWorkReply::set_allocated_header_hash(std::string* header_hash) {
  if (header_hash != nullptr) {
    
  } else {
    
  }
  _impl_.header_hash_.SetAllocated(header_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.header_hash_.IsDefault()) {
    _impl_.header_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.GetWorkReply.header_hash)
}

// string seed_hash = 2;
inline void GetWorkReply::clear_seed_hash() {
  _impl_.seed_hash_.ClearToEmpty();
}
inline const std::string& GetWorkReply::seed_hash() const {
  // @@protoc_insertion_point(field_get:txpool.GetWorkReply.seed_hash)
  return _internal_seed_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkReply::set_seed_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.seed_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.GetWorkReply.seed_hash)
}
inline std::string* GetWorkReply::mutable_seed_hash() {
  std::string* _s = _internal_mutable_seed_hash();
  // @@protoc_insertion_point(field_mutable:txpool.GetWorkReply.seed_hash)
  return _s;
}
inline const std::string& GetWorkReply::_internal_seed_hash() const {
  return _impl_.seed_hash_.Get();
}
inline void GetWorkReply::_internal_set_seed_hash(const std::string& value) {
  
  _impl_.seed_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkReply::_internal_mutable_seed_hash() {
  
  return _impl_.seed_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkReply::release_seed_hash() {
  // @@protoc_insertion_point(field_release:txpool.GetWorkReply.seed_hash)
  return _impl_.seed_hash_.Release();
}
inline void GetWorkReply::set_allocated_seed_hash(std::string* seed_hash) {
  if (seed_hash != nullptr) {
    
  } else {
    
  }
  _impl_.seed_hash_.SetAllocated(seed_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seed_hash_.IsDefault()) {
    _impl_.seed_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.GetWorkReply.seed_hash)
}

// string target = 3;
inline void GetWorkReply::clear_target() {
  _impl_.target_.ClearToEmpty();
}
inline const std::string& GetWorkReply::target() const {
  // @@protoc_insertion_point(field_get:txpool.GetWorkReply.target)
  return _internal_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkReply::set_target(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.GetWorkReply.target)
}
inline std::string* GetWorkReply::mutable_target() {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:txpool.GetWorkReply.target)
  return _s;
}
inline const std::string& GetWorkReply::_internal_target() const {
  return _impl_.target_.Get();
}
inline void GetWorkReply::_internal_set_target(const std::string& value) {
  
  _impl_.target_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkReply::_internal_mutable_target() {
  
  return _impl_.target_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkReply::release_target() {
  // @@protoc_insertion_point(field_release:txpool.GetWorkReply.target)
  return _impl_.target_.Release();
}
inline void GetWorkReply::set_allocated_target(std::string* target) {
  if (target != nullptr) {
    
  } else {
    
  }
  _impl_.target_.SetAllocated(target, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.GetWorkReply.target)
}

// string block_number = 4;
inline void GetWorkReply::clear_block_number() {
  _impl_.block_number_.ClearToEmpty();
}
inline const std::string& GetWorkReply::block_number() const {
  // @@protoc_insertion_point(field_get:txpool.GetWorkReply.block_number)
  return _internal_block_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkReply::set_block_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.GetWorkReply.block_number)
}
inline std::string* GetWorkReply::mutable_block_number() {
  std::string* _s = _internal_mutable_block_number();
  // @@protoc_insertion_point(field_mutable:txpool.GetWorkReply.block_number)
  return _s;
}
inline const std::string& GetWorkReply::_internal_block_number() const {
  return _impl_.block_number_.Get();
}
inline void GetWorkReply::_internal_set_block_number(const std::string& value) {
  
  _impl_.block_number_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkReply::_internal_mutable_block_number() {
  
  return _impl_.block_number_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkReply::release_block_number() {
  // @@protoc_insertion_point(field_release:txpool.GetWorkReply.block_number)
  return _impl_.block_number_.Release();
}
inline void GetWorkReply::set_allocated_block_number(std::string* block_number) {
  if (block_number != nullptr) {
    
  } else {
    
  }
  _impl_.block_number_.SetAllocated(block_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_number_.IsDefault()) {
    _impl_.block_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.GetWorkReply.block_number)
}

// -------------------------------------------------------------------

// SubmitWorkRequest

// bytes block_nonce = 1;
inline void SubmitWorkRequest::clear_block_nonce() {
  _impl_.block_nonce_.ClearToEmpty();
}
inline const std::string& SubmitWorkRequest::block_nonce() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitWorkRequest.block_nonce)
  return _internal_block_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitWorkRequest::set_block_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_nonce_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.SubmitWorkRequest.block_nonce)
}
inline std::string* SubmitWorkRequest::mutable_block_nonce() {
  std::string* _s = _internal_mutable_block_nonce();
  // @@protoc_insertion_point(field_mutable:txpool.SubmitWorkRequest.block_nonce)
  return _s;
}
inline const std::string& SubmitWorkRequest::_internal_block_nonce() const {
  return _impl_.block_nonce_.Get();
}
inline void SubmitWorkRequest::_internal_set_block_nonce(const std::string& value) {
  
  _impl_.block_nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::_internal_mutable_block_nonce() {
  
  return _impl_.block_nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::release_block_nonce() {
  // @@protoc_insertion_point(field_release:txpool.SubmitWorkRequest.block_nonce)
  return _impl_.block_nonce_.Release();
}
inline void SubmitWorkRequest::set_allocated_block_nonce(std::string* block_nonce) {
  if (block_nonce != nullptr) {
    
  } else {
    
  }
  _impl_.block_nonce_.SetAllocated(block_nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_nonce_.IsDefault()) {
    _impl_.block_nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.SubmitWorkRequest.block_nonce)
}

// bytes pow_hash = 2;
inline void SubmitWorkRequest::clear_pow_hash() {
  _impl_.pow_hash_.ClearToEmpty();
}
inline const std::string& SubmitWorkRequest::pow_hash() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitWorkRequest.pow_hash)
  return _internal_pow_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitWorkRequest::set_pow_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pow_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.SubmitWorkRequest.pow_hash)
}
inline std::string* SubmitWorkRequest::mutable_pow_hash() {
  std::string* _s = _internal_mutable_pow_hash();
  // @@protoc_insertion_point(field_mutable:txpool.SubmitWorkRequest.pow_hash)
  return _s;
}
inline const std::string& SubmitWorkRequest::_internal_pow_hash() const {
  return _impl_.pow_hash_.Get();
}
inline void SubmitWorkRequest::_internal_set_pow_hash(const std::string& value) {
  
  _impl_.pow_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::_internal_mutable_pow_hash() {
  
  return _impl_.pow_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::release_pow_hash() {
  // @@protoc_insertion_point(field_release:txpool.SubmitWorkRequest.pow_hash)
  return _impl_.pow_hash_.Release();
}
inline void SubmitWorkRequest::set_allocated_pow_hash(std::string* pow_hash) {
  if (pow_hash != nullptr) {
    
  } else {
    
  }
  _impl_.pow_hash_.SetAllocated(pow_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pow_hash_.IsDefault()) {
    _impl_.pow_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.SubmitWorkRequest.pow_hash)
}

// bytes digest = 3;
inline void SubmitWorkRequest::clear_digest() {
  _impl_.digest_.ClearToEmpty();
}
inline const std::string& SubmitWorkRequest::digest() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitWorkRequest.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitWorkRequest::set_digest(ArgT0&& arg0, ArgT... args) {
 
 _impl_.digest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.SubmitWorkRequest.digest)
}
inline std::string* SubmitWorkRequest::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:txpool.SubmitWorkRequest.digest)
  return _s;
}
inline const std::string& SubmitWorkRequest::_internal_digest() const {
  return _impl_.digest_.Get();
}
inline void SubmitWorkRequest::_internal_set_digest(const std::string& value) {
  
  _impl_.digest_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::_internal_mutable_digest() {
  
  return _impl_.digest_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitWorkRequest::release_digest() {
  // @@protoc_insertion_point(field_release:txpool.SubmitWorkRequest.digest)
  return _impl_.digest_.Release();
}
inline void SubmitWorkRequest::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  _impl_.digest_.SetAllocated(digest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digest_.IsDefault()) {
    _impl_.digest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.SubmitWorkRequest.digest)
}

// -------------------------------------------------------------------

// SubmitWorkReply

// bool ok = 1;
inline void SubmitWorkReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SubmitWorkReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SubmitWorkReply::ok() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitWorkReply.ok)
  return _internal_ok();
}
inline void SubmitWorkReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SubmitWorkReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:txpool.SubmitWorkReply.ok)
}

// -------------------------------------------------------------------

// SubmitHashRateRequest

// uint64 rate = 1;
inline void SubmitHashRateRequest::clear_rate() {
  _impl_.rate_ = uint64_t{0u};
}
inline uint64_t SubmitHashRateRequest::_internal_rate() const {
  return _impl_.rate_;
}
inline uint64_t SubmitHashRateRequest::rate() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitHashRateRequest.rate)
  return _internal_rate();
}
inline void SubmitHashRateRequest::_internal_set_rate(uint64_t value) {
  
  _impl_.rate_ = value;
}
inline void SubmitHashRateRequest::set_rate(uint64_t value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:txpool.SubmitHashRateRequest.rate)
}

// bytes id = 2;
inline void SubmitHashRateRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SubmitHashRateRequest::id() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitHashRateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitHashRateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:txpool.SubmitHashRateRequest.id)
}
inline std::string* SubmitHashRateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:txpool.SubmitHashRateRequest.id)
  return _s;
}
inline const std::string& SubmitHashRateRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SubmitHashRateRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitHashRateRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitHashRateRequest::release_id() {
  // @@protoc_insertion_point(field_release:txpool.SubmitHashRateRequest.id)
  return _impl_.id_.Release();
}
inline void SubmitHashRateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:txpool.SubmitHashRateRequest.id)
}

// -------------------------------------------------------------------

// SubmitHashRateReply

// bool ok = 1;
inline void SubmitHashRateReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SubmitHashRateReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SubmitHashRateReply::ok() const {
  // @@protoc_insertion_point(field_get:txpool.SubmitHashRateReply.ok)
  return _internal_ok();
}
inline void SubmitHashRateReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SubmitHashRateReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:txpool.SubmitHashRateReply.ok)
}

// -------------------------------------------------------------------

// HashRateRequest

// -------------------------------------------------------------------

// HashRateReply

// uint64 hash_rate = 1;
inline void HashRateReply::clear_hash_rate() {
  _impl_.hash_rate_ = uint64_t{0u};
}
inline uint64_t HashRateReply::_internal_hash_rate() const {
  return _impl_.hash_rate_;
}
inline uint64_t HashRateReply::hash_rate() const {
  // @@protoc_insertion_point(field_get:txpool.HashRateReply.hash_rate)
  return _internal_hash_rate();
}
inline void HashRateReply::_internal_set_hash_rate(uint64_t value) {
  
  _impl_.hash_rate_ = value;
}
inline void HashRateReply::set_hash_rate(uint64_t value) {
  _internal_set_hash_rate(value);
  // @@protoc_insertion_point(field_set:txpool.HashRateReply.hash_rate)
}

// -------------------------------------------------------------------

// MiningRequest

// -------------------------------------------------------------------

// MiningReply

// bool enabled = 1;
inline void MiningReply::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool MiningReply::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool MiningReply::enabled() const {
  // @@protoc_insertion_point(field_get:txpool.MiningReply.enabled)
  return _internal_enabled();
}
inline void MiningReply::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void MiningReply::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:txpool.MiningReply.enabled)
}

// bool running = 2;
inline void MiningReply::clear_running() {
  _impl_.running_ = false;
}
inline bool MiningReply::_internal_running() const {
  return _impl_.running_;
}
inline bool MiningReply::running() const {
  // @@protoc_insertion_point(field_get:txpool.MiningReply.running)
  return _internal_running();
}
inline void MiningReply::_internal_set_running(bool value) {
  
  _impl_.running_ = value;
}
inline void MiningReply::set_running(bool value) {
  _internal_set_running(value);
  // @@protoc_insertion_point(field_set:txpool.MiningReply.running)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace txpool

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_txpool_2fmining_2eproto
