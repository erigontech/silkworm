// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: remote/bor.proto

#ifndef GRPC_MOCK_remote_2fbor_2eproto__INCLUDED
#define GRPC_MOCK_remote_2fbor_2eproto__INCLUDED

#include "remote/bor.pb.h"
#include "remote/bor.grpc.pb.h"

#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/sync_stream.h>
#include <gmock/gmock.h>
namespace remote {

class MockBridgeBackendStub : public BridgeBackend::StubInterface {
 public:
  MOCK_METHOD3(Version, ::grpc::Status(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::VersionReply* response));
  MOCK_METHOD3(AsyncVersionRaw, ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>*(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq));
  MOCK_METHOD3(PrepareAsyncVersionRaw, ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>*(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq));
  MOCK_METHOD3(BorTxnLookup, ::grpc::Status(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::remote::BorTxnLookupReply* response));
  MOCK_METHOD3(AsyncBorTxnLookupRaw, ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorTxnLookupReply>*(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq));
  MOCK_METHOD3(PrepareAsyncBorTxnLookupRaw, ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorTxnLookupReply>*(::grpc::ClientContext* context, const ::remote::BorTxnLookupRequest& request, ::grpc::CompletionQueue* cq));
  MOCK_METHOD3(BorEvents, ::grpc::Status(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::remote::BorEventsReply* response));
  MOCK_METHOD3(AsyncBorEventsRaw, ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorEventsReply>*(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq));
  MOCK_METHOD3(PrepareAsyncBorEventsRaw, ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorEventsReply>*(::grpc::ClientContext* context, const ::remote::BorEventsRequest& request, ::grpc::CompletionQueue* cq));
};

class MockHeimdallBackendStub : public HeimdallBackend::StubInterface {
 public:
  MOCK_METHOD3(Version, ::grpc::Status(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::types::VersionReply* response));
  MOCK_METHOD3(AsyncVersionRaw, ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>*(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq));
  MOCK_METHOD3(PrepareAsyncVersionRaw, ::grpc::ClientAsyncResponseReaderInterface< ::types::VersionReply>*(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq));
  MOCK_METHOD3(Producers, ::grpc::Status(::grpc::ClientContext* context, const ::remote::BorProducersRequest& request, ::remote::BorProducersResponse* response));
  MOCK_METHOD3(AsyncProducersRaw, ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorProducersResponse>*(::grpc::ClientContext* context, const ::remote::BorProducersRequest& request, ::grpc::CompletionQueue* cq));
  MOCK_METHOD3(PrepareAsyncProducersRaw, ::grpc::ClientAsyncResponseReaderInterface< ::remote::BorProducersResponse>*(::grpc::ClientContext* context, const ::remote::BorProducersRequest& request, ::grpc::CompletionQueue* cq));
};

}  // namespace remote


#endif  // GRPC_MOCK_remote_2fbor_2eproto__INCLUDED
