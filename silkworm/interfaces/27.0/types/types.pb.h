// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: types/types.proto
// Protobuf C++ Version: 5.27.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/descriptor.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_types_2ftypes_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_types_2ftypes_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_types_2ftypes_2eproto;
namespace types {
class BlobsBundleV1;
struct BlobsBundleV1DefaultTypeInternal;
extern BlobsBundleV1DefaultTypeInternal _BlobsBundleV1_default_instance_;
class ExecutionPayload;
struct ExecutionPayloadDefaultTypeInternal;
extern ExecutionPayloadDefaultTypeInternal _ExecutionPayload_default_instance_;
class ExecutionPayloadBodyV1;
struct ExecutionPayloadBodyV1DefaultTypeInternal;
extern ExecutionPayloadBodyV1DefaultTypeInternal _ExecutionPayloadBodyV1_default_instance_;
class H1024;
struct H1024DefaultTypeInternal;
extern H1024DefaultTypeInternal _H1024_default_instance_;
class H128;
struct H128DefaultTypeInternal;
extern H128DefaultTypeInternal _H128_default_instance_;
class H160;
struct H160DefaultTypeInternal;
extern H160DefaultTypeInternal _H160_default_instance_;
class H2048;
struct H2048DefaultTypeInternal;
extern H2048DefaultTypeInternal _H2048_default_instance_;
class H256;
struct H256DefaultTypeInternal;
extern H256DefaultTypeInternal _H256_default_instance_;
class H512;
struct H512DefaultTypeInternal;
extern H512DefaultTypeInternal _H512_default_instance_;
class NodeInfoPorts;
struct NodeInfoPortsDefaultTypeInternal;
extern NodeInfoPortsDefaultTypeInternal _NodeInfoPorts_default_instance_;
class NodeInfoReply;
struct NodeInfoReplyDefaultTypeInternal;
extern NodeInfoReplyDefaultTypeInternal _NodeInfoReply_default_instance_;
class PeerInfo;
struct PeerInfoDefaultTypeInternal;
extern PeerInfoDefaultTypeInternal _PeerInfo_default_instance_;
class RequestsBundle;
struct RequestsBundleDefaultTypeInternal;
extern RequestsBundleDefaultTypeInternal _RequestsBundle_default_instance_;
class VersionReply;
struct VersionReplyDefaultTypeInternal;
extern VersionReplyDefaultTypeInternal _VersionReply_default_instance_;
class Withdrawal;
struct WithdrawalDefaultTypeInternal;
extern WithdrawalDefaultTypeInternal _Withdrawal_default_instance_;
}  // namespace types
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace types {

// ===================================================================


// -------------------------------------------------------------------

class VersionReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.VersionReply) */ {
 public:
  inline VersionReply() : VersionReply(nullptr) {}
  ~VersionReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VersionReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline VersionReply(const VersionReply& from) : VersionReply(nullptr, from) {}
  inline VersionReply(VersionReply&& from) noexcept
      : VersionReply(nullptr, std::move(from)) {}
  inline VersionReply& operator=(const VersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionReply& operator=(VersionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionReply* internal_default_instance() {
    return reinterpret_cast<const VersionReply*>(
        &_VersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(VersionReply& a, VersionReply& b) { a.Swap(&b); }
  inline void Swap(VersionReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<VersionReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VersionReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VersionReply& from) { VersionReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VersionReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.VersionReply"; }

 protected:
  explicit VersionReply(::google::protobuf::Arena* arena);
  VersionReply(::google::protobuf::Arena* arena, const VersionReply& from);
  VersionReply(::google::protobuf::Arena* arena, VersionReply&& from) noexcept
      : VersionReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // uint32 major = 1;
  void clear_major() ;
  ::uint32_t major() const;
  void set_major(::uint32_t value);

  private:
  ::uint32_t _internal_major() const;
  void _internal_set_major(::uint32_t value);

  public:
  // uint32 minor = 2;
  void clear_minor() ;
  ::uint32_t minor() const;
  void set_minor(::uint32_t value);

  private:
  ::uint32_t _internal_minor() const;
  void _internal_set_minor(::uint32_t value);

  public:
  // uint32 patch = 3;
  void clear_patch() ;
  ::uint32_t patch() const;
  void set_patch(::uint32_t value);

  private:
  ::uint32_t _internal_patch() const;
  void _internal_set_patch(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:types.VersionReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_VersionReply_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VersionReply& from_msg);
    ::uint32_t major_;
    ::uint32_t minor_;
    ::uint32_t patch_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestsBundle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.RequestsBundle) */ {
 public:
  inline RequestsBundle() : RequestsBundle(nullptr) {}
  ~RequestsBundle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RequestsBundle(
      ::google::protobuf::internal::ConstantInitialized);

  inline RequestsBundle(const RequestsBundle& from) : RequestsBundle(nullptr, from) {}
  inline RequestsBundle(RequestsBundle&& from) noexcept
      : RequestsBundle(nullptr, std::move(from)) {}
  inline RequestsBundle& operator=(const RequestsBundle& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestsBundle& operator=(RequestsBundle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestsBundle& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestsBundle* internal_default_instance() {
    return reinterpret_cast<const RequestsBundle*>(
        &_RequestsBundle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(RequestsBundle& a, RequestsBundle& b) { a.Swap(&b); }
  inline void Swap(RequestsBundle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestsBundle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestsBundle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RequestsBundle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestsBundle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RequestsBundle& from) { RequestsBundle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RequestsBundle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.RequestsBundle"; }

 protected:
  explicit RequestsBundle(::google::protobuf::Arena* arena);
  RequestsBundle(::google::protobuf::Arena* arena, const RequestsBundle& from);
  RequestsBundle(::google::protobuf::Arena* arena, RequestsBundle&& from) noexcept
      : RequestsBundle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated bytes requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;

  public:
  void clear_requests() ;
  const std::string& requests(int index) const;
  std::string* mutable_requests(int index);
  void set_requests(int index, const std::string& value);
  void set_requests(int index, std::string&& value);
  void set_requests(int index, const char* value);
  void set_requests(int index, const void* value, std::size_t size);
  void set_requests(int index, absl::string_view value);
  std::string* add_requests();
  void add_requests(const std::string& value);
  void add_requests(std::string&& value);
  void add_requests(const char* value);
  void add_requests(const void* value, std::size_t size);
  void add_requests(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& requests() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_requests();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_requests() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_requests();

  public:
  // @@protoc_insertion_point(class_scope:types.RequestsBundle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RequestsBundle_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RequestsBundle& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> requests_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class PeerInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.PeerInfo) */ {
 public:
  inline PeerInfo() : PeerInfo(nullptr) {}
  ~PeerInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PeerInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PeerInfo(const PeerInfo& from) : PeerInfo(nullptr, from) {}
  inline PeerInfo(PeerInfo&& from) noexcept
      : PeerInfo(nullptr, std::move(from)) {}
  inline PeerInfo& operator=(const PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerInfo& operator=(PeerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerInfo* internal_default_instance() {
    return reinterpret_cast<const PeerInfo*>(
        &_PeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(PeerInfo& a, PeerInfo& b) { a.Swap(&b); }
  inline void Swap(PeerInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PeerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PeerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PeerInfo& from) { PeerInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PeerInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.PeerInfo"; }

 protected:
  explicit PeerInfo(::google::protobuf::Arena* arena);
  PeerInfo(::google::protobuf::Arena* arena, const PeerInfo& from);
  PeerInfo(::google::protobuf::Arena* arena, PeerInfo&& from) noexcept
      : PeerInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCapsFieldNumber = 5,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kEnodeFieldNumber = 3,
    kEnrFieldNumber = 4,
    kConnLocalAddrFieldNumber = 6,
    kConnRemoteAddrFieldNumber = 7,
    kConnIsInboundFieldNumber = 8,
    kConnIsTrustedFieldNumber = 9,
    kConnIsStaticFieldNumber = 10,
  };
  // repeated string caps = 5;
  int caps_size() const;
  private:
  int _internal_caps_size() const;

  public:
  void clear_caps() ;
  const std::string& caps(int index) const;
  std::string* mutable_caps(int index);
  void set_caps(int index, const std::string& value);
  void set_caps(int index, std::string&& value);
  void set_caps(int index, const char* value);
  void set_caps(int index, const char* value, std::size_t size);
  void set_caps(int index, absl::string_view value);
  std::string* add_caps();
  void add_caps(const std::string& value);
  void add_caps(std::string&& value);
  void add_caps(const char* value);
  void add_caps(const char* value, std::size_t size);
  void add_caps(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& caps() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_caps();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_caps() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_caps();

  public:
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string enode = 3;
  void clear_enode() ;
  const std::string& enode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enode(Arg_&& arg, Args_... args);
  std::string* mutable_enode();
  PROTOBUF_NODISCARD std::string* release_enode();
  void set_allocated_enode(std::string* value);

  private:
  const std::string& _internal_enode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enode(
      const std::string& value);
  std::string* _internal_mutable_enode();

  public:
  // string enr = 4;
  void clear_enr() ;
  const std::string& enr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enr(Arg_&& arg, Args_... args);
  std::string* mutable_enr();
  PROTOBUF_NODISCARD std::string* release_enr();
  void set_allocated_enr(std::string* value);

  private:
  const std::string& _internal_enr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enr(
      const std::string& value);
  std::string* _internal_mutable_enr();

  public:
  // string conn_local_addr = 6;
  void clear_conn_local_addr() ;
  const std::string& conn_local_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_conn_local_addr(Arg_&& arg, Args_... args);
  std::string* mutable_conn_local_addr();
  PROTOBUF_NODISCARD std::string* release_conn_local_addr();
  void set_allocated_conn_local_addr(std::string* value);

  private:
  const std::string& _internal_conn_local_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conn_local_addr(
      const std::string& value);
  std::string* _internal_mutable_conn_local_addr();

  public:
  // string conn_remote_addr = 7;
  void clear_conn_remote_addr() ;
  const std::string& conn_remote_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_conn_remote_addr(Arg_&& arg, Args_... args);
  std::string* mutable_conn_remote_addr();
  PROTOBUF_NODISCARD std::string* release_conn_remote_addr();
  void set_allocated_conn_remote_addr(std::string* value);

  private:
  const std::string& _internal_conn_remote_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conn_remote_addr(
      const std::string& value);
  std::string* _internal_mutable_conn_remote_addr();

  public:
  // bool conn_is_inbound = 8;
  void clear_conn_is_inbound() ;
  bool conn_is_inbound() const;
  void set_conn_is_inbound(bool value);

  private:
  bool _internal_conn_is_inbound() const;
  void _internal_set_conn_is_inbound(bool value);

  public:
  // bool conn_is_trusted = 9;
  void clear_conn_is_trusted() ;
  bool conn_is_trusted() const;
  void set_conn_is_trusted(bool value);

  private:
  bool _internal_conn_is_trusted() const;
  void _internal_set_conn_is_trusted(bool value);

  public:
  // bool conn_is_static = 10;
  void clear_conn_is_static() ;
  bool conn_is_static() const;
  void set_conn_is_static(bool value);

  private:
  bool _internal_conn_is_static() const;
  void _internal_set_conn_is_static(bool value);

  public:
  // @@protoc_insertion_point(class_scope:types.PeerInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      80, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PeerInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PeerInfo& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> caps_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr enode_;
    ::google::protobuf::internal::ArenaStringPtr enr_;
    ::google::protobuf::internal::ArenaStringPtr conn_local_addr_;
    ::google::protobuf::internal::ArenaStringPtr conn_remote_addr_;
    bool conn_is_inbound_;
    bool conn_is_trusted_;
    bool conn_is_static_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoPorts final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.NodeInfoPorts) */ {
 public:
  inline NodeInfoPorts() : NodeInfoPorts(nullptr) {}
  ~NodeInfoPorts() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeInfoPorts(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeInfoPorts(const NodeInfoPorts& from) : NodeInfoPorts(nullptr, from) {}
  inline NodeInfoPorts(NodeInfoPorts&& from) noexcept
      : NodeInfoPorts(nullptr, std::move(from)) {}
  inline NodeInfoPorts& operator=(const NodeInfoPorts& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoPorts& operator=(NodeInfoPorts&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfoPorts& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfoPorts* internal_default_instance() {
    return reinterpret_cast<const NodeInfoPorts*>(
        &_NodeInfoPorts_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(NodeInfoPorts& a, NodeInfoPorts& b) { a.Swap(&b); }
  inline void Swap(NodeInfoPorts* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoPorts* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfoPorts* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeInfoPorts>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeInfoPorts& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeInfoPorts& from) { NodeInfoPorts::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeInfoPorts* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.NodeInfoPorts"; }

 protected:
  explicit NodeInfoPorts(::google::protobuf::Arena* arena);
  NodeInfoPorts(::google::protobuf::Arena* arena, const NodeInfoPorts& from);
  NodeInfoPorts(::google::protobuf::Arena* arena, NodeInfoPorts&& from) noexcept
      : NodeInfoPorts(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiscoveryFieldNumber = 1,
    kListenerFieldNumber = 2,
  };
  // uint32 discovery = 1;
  void clear_discovery() ;
  ::uint32_t discovery() const;
  void set_discovery(::uint32_t value);

  private:
  ::uint32_t _internal_discovery() const;
  void _internal_set_discovery(::uint32_t value);

  public:
  // uint32 listener = 2;
  void clear_listener() ;
  ::uint32_t listener() const;
  void set_listener(::uint32_t value);

  private:
  ::uint32_t _internal_listener() const;
  void _internal_set_listener(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:types.NodeInfoPorts)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NodeInfoPorts_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeInfoPorts& from_msg);
    ::uint32_t discovery_;
    ::uint32_t listener_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H128 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.H128) */ {
 public:
  inline H128() : H128(nullptr) {}
  ~H128() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR H128(
      ::google::protobuf::internal::ConstantInitialized);

  inline H128(const H128& from) : H128(nullptr, from) {}
  inline H128(H128&& from) noexcept
      : H128(nullptr, std::move(from)) {}
  inline H128& operator=(const H128& from) {
    CopyFrom(from);
    return *this;
  }
  inline H128& operator=(H128&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H128& default_instance() {
    return *internal_default_instance();
  }
  static inline const H128* internal_default_instance() {
    return reinterpret_cast<const H128*>(
        &_H128_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(H128& a, H128& b) { a.Swap(&b); }
  inline void Swap(H128* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H128* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H128* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<H128>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const H128& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const H128& from) { H128::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(H128* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.H128"; }

 protected:
  explicit H128(::google::protobuf::Arena* arena);
  H128(::google::protobuf::Arena* arena, const H128& from);
  H128(::google::protobuf::Arena* arena, H128&& from) noexcept
      : H128(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // uint64 hi = 1;
  void clear_hi() ;
  ::uint64_t hi() const;
  void set_hi(::uint64_t value);

  private:
  ::uint64_t _internal_hi() const;
  void _internal_set_hi(::uint64_t value);

  public:
  // uint64 lo = 2;
  void clear_lo() ;
  ::uint64_t lo() const;
  void set_lo(::uint64_t value);

  private:
  ::uint64_t _internal_lo() const;
  void _internal_set_lo(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:types.H128)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_H128_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const H128& from_msg);
    ::uint64_t hi_;
    ::uint64_t lo_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class BlobsBundleV1 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.BlobsBundleV1) */ {
 public:
  inline BlobsBundleV1() : BlobsBundleV1(nullptr) {}
  ~BlobsBundleV1() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlobsBundleV1(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlobsBundleV1(const BlobsBundleV1& from) : BlobsBundleV1(nullptr, from) {}
  inline BlobsBundleV1(BlobsBundleV1&& from) noexcept
      : BlobsBundleV1(nullptr, std::move(from)) {}
  inline BlobsBundleV1& operator=(const BlobsBundleV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobsBundleV1& operator=(BlobsBundleV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobsBundleV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobsBundleV1* internal_default_instance() {
    return reinterpret_cast<const BlobsBundleV1*>(
        &_BlobsBundleV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(BlobsBundleV1& a, BlobsBundleV1& b) { a.Swap(&b); }
  inline void Swap(BlobsBundleV1* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobsBundleV1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobsBundleV1* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BlobsBundleV1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlobsBundleV1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlobsBundleV1& from) { BlobsBundleV1::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlobsBundleV1* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.BlobsBundleV1"; }

 protected:
  explicit BlobsBundleV1(::google::protobuf::Arena* arena);
  BlobsBundleV1(::google::protobuf::Arena* arena, const BlobsBundleV1& from);
  BlobsBundleV1(::google::protobuf::Arena* arena, BlobsBundleV1&& from) noexcept
      : BlobsBundleV1(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommitmentsFieldNumber = 1,
    kBlobsFieldNumber = 2,
    kProofsFieldNumber = 3,
  };
  // repeated bytes commitments = 1;
  int commitments_size() const;
  private:
  int _internal_commitments_size() const;

  public:
  void clear_commitments() ;
  const std::string& commitments(int index) const;
  std::string* mutable_commitments(int index);
  void set_commitments(int index, const std::string& value);
  void set_commitments(int index, std::string&& value);
  void set_commitments(int index, const char* value);
  void set_commitments(int index, const void* value, std::size_t size);
  void set_commitments(int index, absl::string_view value);
  std::string* add_commitments();
  void add_commitments(const std::string& value);
  void add_commitments(std::string&& value);
  void add_commitments(const char* value);
  void add_commitments(const void* value, std::size_t size);
  void add_commitments(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& commitments() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_commitments();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_commitments() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_commitments();

  public:
  // repeated bytes blobs = 2;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;

  public:
  void clear_blobs() ;
  const std::string& blobs(int index) const;
  std::string* mutable_blobs(int index);
  void set_blobs(int index, const std::string& value);
  void set_blobs(int index, std::string&& value);
  void set_blobs(int index, const char* value);
  void set_blobs(int index, const void* value, std::size_t size);
  void set_blobs(int index, absl::string_view value);
  std::string* add_blobs();
  void add_blobs(const std::string& value);
  void add_blobs(std::string&& value);
  void add_blobs(const char* value);
  void add_blobs(const void* value, std::size_t size);
  void add_blobs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& blobs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_blobs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_blobs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_blobs();

  public:
  // repeated bytes proofs = 3;
  int proofs_size() const;
  private:
  int _internal_proofs_size() const;

  public:
  void clear_proofs() ;
  const std::string& proofs(int index) const;
  std::string* mutable_proofs(int index);
  void set_proofs(int index, const std::string& value);
  void set_proofs(int index, std::string&& value);
  void set_proofs(int index, const char* value);
  void set_proofs(int index, const void* value, std::size_t size);
  void set_proofs(int index, absl::string_view value);
  std::string* add_proofs();
  void add_proofs(const std::string& value);
  void add_proofs(std::string&& value);
  void add_proofs(const char* value);
  void add_proofs(const void* value, std::size_t size);
  void add_proofs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& proofs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_proofs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_proofs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_proofs();

  public:
  // @@protoc_insertion_point(class_scope:types.BlobsBundleV1)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BlobsBundleV1_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlobsBundleV1& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> commitments_;
    ::google::protobuf::RepeatedPtrField<std::string> blobs_;
    ::google::protobuf::RepeatedPtrField<std::string> proofs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.NodeInfoReply) */ {
 public:
  inline NodeInfoReply() : NodeInfoReply(nullptr) {}
  ~NodeInfoReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeInfoReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeInfoReply(const NodeInfoReply& from) : NodeInfoReply(nullptr, from) {}
  inline NodeInfoReply(NodeInfoReply&& from) noexcept
      : NodeInfoReply(nullptr, std::move(from)) {}
  inline NodeInfoReply& operator=(const NodeInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoReply& operator=(NodeInfoReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfoReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfoReply* internal_default_instance() {
    return reinterpret_cast<const NodeInfoReply*>(
        &_NodeInfoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(NodeInfoReply& a, NodeInfoReply& b) { a.Swap(&b); }
  inline void Swap(NodeInfoReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfoReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeInfoReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeInfoReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeInfoReply& from) { NodeInfoReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeInfoReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.NodeInfoReply"; }

 protected:
  explicit NodeInfoReply(::google::protobuf::Arena* arena);
  NodeInfoReply(::google::protobuf::Arena* arena, const NodeInfoReply& from);
  NodeInfoReply(::google::protobuf::Arena* arena, NodeInfoReply&& from) noexcept
      : NodeInfoReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kEnodeFieldNumber = 3,
    kEnrFieldNumber = 4,
    kListenerAddrFieldNumber = 6,
    kProtocolsFieldNumber = 7,
    kPortsFieldNumber = 5,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string enode = 3;
  void clear_enode() ;
  const std::string& enode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enode(Arg_&& arg, Args_... args);
  std::string* mutable_enode();
  PROTOBUF_NODISCARD std::string* release_enode();
  void set_allocated_enode(std::string* value);

  private:
  const std::string& _internal_enode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enode(
      const std::string& value);
  std::string* _internal_mutable_enode();

  public:
  // string enr = 4;
  void clear_enr() ;
  const std::string& enr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enr(Arg_&& arg, Args_... args);
  std::string* mutable_enr();
  PROTOBUF_NODISCARD std::string* release_enr();
  void set_allocated_enr(std::string* value);

  private:
  const std::string& _internal_enr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enr(
      const std::string& value);
  std::string* _internal_mutable_enr();

  public:
  // string listener_addr = 6;
  void clear_listener_addr() ;
  const std::string& listener_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_listener_addr(Arg_&& arg, Args_... args);
  std::string* mutable_listener_addr();
  PROTOBUF_NODISCARD std::string* release_listener_addr();
  void set_allocated_listener_addr(std::string* value);

  private:
  const std::string& _internal_listener_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_listener_addr(
      const std::string& value);
  std::string* _internal_mutable_listener_addr();

  public:
  // bytes protocols = 7;
  void clear_protocols() ;
  const std::string& protocols() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protocols(Arg_&& arg, Args_... args);
  std::string* mutable_protocols();
  PROTOBUF_NODISCARD std::string* release_protocols();
  void set_allocated_protocols(std::string* value);

  private:
  const std::string& _internal_protocols() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocols(
      const std::string& value);
  std::string* _internal_mutable_protocols();

  public:
  // .types.NodeInfoPorts ports = 5;
  bool has_ports() const;
  void clear_ports() ;
  const ::types::NodeInfoPorts& ports() const;
  PROTOBUF_NODISCARD ::types::NodeInfoPorts* release_ports();
  ::types::NodeInfoPorts* mutable_ports();
  void set_allocated_ports(::types::NodeInfoPorts* value);
  void unsafe_arena_set_allocated_ports(::types::NodeInfoPorts* value);
  ::types::NodeInfoPorts* unsafe_arena_release_ports();

  private:
  const ::types::NodeInfoPorts& _internal_ports() const;
  ::types::NodeInfoPorts* _internal_mutable_ports();

  public:
  // @@protoc_insertion_point(class_scope:types.NodeInfoReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      55, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NodeInfoReply_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeInfoReply& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr enode_;
    ::google::protobuf::internal::ArenaStringPtr enr_;
    ::google::protobuf::internal::ArenaStringPtr listener_addr_;
    ::google::protobuf::internal::ArenaStringPtr protocols_;
    ::types::NodeInfoPorts* ports_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H256 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.H256) */ {
 public:
  inline H256() : H256(nullptr) {}
  ~H256() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR H256(
      ::google::protobuf::internal::ConstantInitialized);

  inline H256(const H256& from) : H256(nullptr, from) {}
  inline H256(H256&& from) noexcept
      : H256(nullptr, std::move(from)) {}
  inline H256& operator=(const H256& from) {
    CopyFrom(from);
    return *this;
  }
  inline H256& operator=(H256&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H256& default_instance() {
    return *internal_default_instance();
  }
  static inline const H256* internal_default_instance() {
    return reinterpret_cast<const H256*>(
        &_H256_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(H256& a, H256& b) { a.Swap(&b); }
  inline void Swap(H256* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H256* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H256* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<H256>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const H256& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const H256& from) { H256::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(H256* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.H256"; }

 protected:
  explicit H256(::google::protobuf::Arena* arena);
  H256(::google::protobuf::Arena* arena, const H256& from);
  H256(::google::protobuf::Arena* arena, H256&& from) noexcept
      : H256(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H128 hi = 1;
  bool has_hi() const;
  void clear_hi() ;
  const ::types::H128& hi() const;
  PROTOBUF_NODISCARD ::types::H128* release_hi();
  ::types::H128* mutable_hi();
  void set_allocated_hi(::types::H128* value);
  void unsafe_arena_set_allocated_hi(::types::H128* value);
  ::types::H128* unsafe_arena_release_hi();

  private:
  const ::types::H128& _internal_hi() const;
  ::types::H128* _internal_mutable_hi();

  public:
  // .types.H128 lo = 2;
  bool has_lo() const;
  void clear_lo() ;
  const ::types::H128& lo() const;
  PROTOBUF_NODISCARD ::types::H128* release_lo();
  ::types::H128* mutable_lo();
  void set_allocated_lo(::types::H128* value);
  void unsafe_arena_set_allocated_lo(::types::H128* value);
  ::types::H128* unsafe_arena_release_lo();

  private:
  const ::types::H128& _internal_lo() const;
  ::types::H128* _internal_mutable_lo();

  public:
  // @@protoc_insertion_point(class_scope:types.H256)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_H256_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const H256& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H128* hi_;
    ::types::H128* lo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H160 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.H160) */ {
 public:
  inline H160() : H160(nullptr) {}
  ~H160() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR H160(
      ::google::protobuf::internal::ConstantInitialized);

  inline H160(const H160& from) : H160(nullptr, from) {}
  inline H160(H160&& from) noexcept
      : H160(nullptr, std::move(from)) {}
  inline H160& operator=(const H160& from) {
    CopyFrom(from);
    return *this;
  }
  inline H160& operator=(H160&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H160& default_instance() {
    return *internal_default_instance();
  }
  static inline const H160* internal_default_instance() {
    return reinterpret_cast<const H160*>(
        &_H160_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(H160& a, H160& b) { a.Swap(&b); }
  inline void Swap(H160* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H160* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H160* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<H160>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const H160& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const H160& from) { H160::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(H160* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.H160"; }

 protected:
  explicit H160(::google::protobuf::Arena* arena);
  H160(::google::protobuf::Arena* arena, const H160& from);
  H160(::google::protobuf::Arena* arena, H160&& from) noexcept
      : H160(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H128 hi = 1;
  bool has_hi() const;
  void clear_hi() ;
  const ::types::H128& hi() const;
  PROTOBUF_NODISCARD ::types::H128* release_hi();
  ::types::H128* mutable_hi();
  void set_allocated_hi(::types::H128* value);
  void unsafe_arena_set_allocated_hi(::types::H128* value);
  ::types::H128* unsafe_arena_release_hi();

  private:
  const ::types::H128& _internal_hi() const;
  ::types::H128* _internal_mutable_hi();

  public:
  // uint32 lo = 2;
  void clear_lo() ;
  ::uint32_t lo() const;
  void set_lo(::uint32_t value);

  private:
  ::uint32_t _internal_lo() const;
  void _internal_set_lo(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:types.H160)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_H160_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const H160& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H128* hi_;
    ::uint32_t lo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Withdrawal final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.Withdrawal) */ {
 public:
  inline Withdrawal() : Withdrawal(nullptr) {}
  ~Withdrawal() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Withdrawal(
      ::google::protobuf::internal::ConstantInitialized);

  inline Withdrawal(const Withdrawal& from) : Withdrawal(nullptr, from) {}
  inline Withdrawal(Withdrawal&& from) noexcept
      : Withdrawal(nullptr, std::move(from)) {}
  inline Withdrawal& operator=(const Withdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Withdrawal& operator=(Withdrawal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Withdrawal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Withdrawal* internal_default_instance() {
    return reinterpret_cast<const Withdrawal*>(
        &_Withdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Withdrawal& a, Withdrawal& b) { a.Swap(&b); }
  inline void Swap(Withdrawal* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Withdrawal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Withdrawal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Withdrawal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Withdrawal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Withdrawal& from) { Withdrawal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Withdrawal* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.Withdrawal"; }

 protected:
  explicit Withdrawal(::google::protobuf::Arena* arena);
  Withdrawal(::google::protobuf::Arena* arena, const Withdrawal& from);
  Withdrawal(::google::protobuf::Arena* arena, Withdrawal&& from) noexcept
      : Withdrawal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddressFieldNumber = 3,
    kIndexFieldNumber = 1,
    kValidatorIndexFieldNumber = 2,
    kAmountFieldNumber = 4,
  };
  // .types.H160 address = 3;
  bool has_address() const;
  void clear_address() ;
  const ::types::H160& address() const;
  PROTOBUF_NODISCARD ::types::H160* release_address();
  ::types::H160* mutable_address();
  void set_allocated_address(::types::H160* value);
  void unsafe_arena_set_allocated_address(::types::H160* value);
  ::types::H160* unsafe_arena_release_address();

  private:
  const ::types::H160& _internal_address() const;
  ::types::H160* _internal_mutable_address();

  public:
  // uint64 index = 1;
  void clear_index() ;
  ::uint64_t index() const;
  void set_index(::uint64_t value);

  private:
  ::uint64_t _internal_index() const;
  void _internal_set_index(::uint64_t value);

  public:
  // uint64 validator_index = 2;
  void clear_validator_index() ;
  ::uint64_t validator_index() const;
  void set_validator_index(::uint64_t value);

  private:
  ::uint64_t _internal_validator_index() const;
  void _internal_set_validator_index(::uint64_t value);

  public:
  // uint64 amount = 4;
  void clear_amount() ;
  ::uint64_t amount() const;
  void set_amount(::uint64_t value);

  private:
  ::uint64_t _internal_amount() const;
  void _internal_set_amount(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:types.Withdrawal)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Withdrawal_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Withdrawal& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H160* address_;
    ::uint64_t index_;
    ::uint64_t validator_index_;
    ::uint64_t amount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H512 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.H512) */ {
 public:
  inline H512() : H512(nullptr) {}
  ~H512() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR H512(
      ::google::protobuf::internal::ConstantInitialized);

  inline H512(const H512& from) : H512(nullptr, from) {}
  inline H512(H512&& from) noexcept
      : H512(nullptr, std::move(from)) {}
  inline H512& operator=(const H512& from) {
    CopyFrom(from);
    return *this;
  }
  inline H512& operator=(H512&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H512& default_instance() {
    return *internal_default_instance();
  }
  static inline const H512* internal_default_instance() {
    return reinterpret_cast<const H512*>(
        &_H512_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(H512& a, H512& b) { a.Swap(&b); }
  inline void Swap(H512* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H512* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H512* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<H512>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const H512& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const H512& from) { H512::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(H512* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.H512"; }

 protected:
  explicit H512(::google::protobuf::Arena* arena);
  H512(::google::protobuf::Arena* arena, const H512& from);
  H512(::google::protobuf::Arena* arena, H512&& from) noexcept
      : H512(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H256 hi = 1;
  bool has_hi() const;
  void clear_hi() ;
  const ::types::H256& hi() const;
  PROTOBUF_NODISCARD ::types::H256* release_hi();
  ::types::H256* mutable_hi();
  void set_allocated_hi(::types::H256* value);
  void unsafe_arena_set_allocated_hi(::types::H256* value);
  ::types::H256* unsafe_arena_release_hi();

  private:
  const ::types::H256& _internal_hi() const;
  ::types::H256* _internal_mutable_hi();

  public:
  // .types.H256 lo = 2;
  bool has_lo() const;
  void clear_lo() ;
  const ::types::H256& lo() const;
  PROTOBUF_NODISCARD ::types::H256* release_lo();
  ::types::H256* mutable_lo();
  void set_allocated_lo(::types::H256* value);
  void unsafe_arena_set_allocated_lo(::types::H256* value);
  ::types::H256* unsafe_arena_release_lo();

  private:
  const ::types::H256& _internal_lo() const;
  ::types::H256* _internal_mutable_lo();

  public:
  // @@protoc_insertion_point(class_scope:types.H512)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_H512_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const H512& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H256* hi_;
    ::types::H256* lo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H1024 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.H1024) */ {
 public:
  inline H1024() : H1024(nullptr) {}
  ~H1024() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR H1024(
      ::google::protobuf::internal::ConstantInitialized);

  inline H1024(const H1024& from) : H1024(nullptr, from) {}
  inline H1024(H1024&& from) noexcept
      : H1024(nullptr, std::move(from)) {}
  inline H1024& operator=(const H1024& from) {
    CopyFrom(from);
    return *this;
  }
  inline H1024& operator=(H1024&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H1024& default_instance() {
    return *internal_default_instance();
  }
  static inline const H1024* internal_default_instance() {
    return reinterpret_cast<const H1024*>(
        &_H1024_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(H1024& a, H1024& b) { a.Swap(&b); }
  inline void Swap(H1024* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H1024* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H1024* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<H1024>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const H1024& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const H1024& from) { H1024::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(H1024* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.H1024"; }

 protected:
  explicit H1024(::google::protobuf::Arena* arena);
  H1024(::google::protobuf::Arena* arena, const H1024& from);
  H1024(::google::protobuf::Arena* arena, H1024&& from) noexcept
      : H1024(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H512 hi = 1;
  bool has_hi() const;
  void clear_hi() ;
  const ::types::H512& hi() const;
  PROTOBUF_NODISCARD ::types::H512* release_hi();
  ::types::H512* mutable_hi();
  void set_allocated_hi(::types::H512* value);
  void unsafe_arena_set_allocated_hi(::types::H512* value);
  ::types::H512* unsafe_arena_release_hi();

  private:
  const ::types::H512& _internal_hi() const;
  ::types::H512* _internal_mutable_hi();

  public:
  // .types.H512 lo = 2;
  bool has_lo() const;
  void clear_lo() ;
  const ::types::H512& lo() const;
  PROTOBUF_NODISCARD ::types::H512* release_lo();
  ::types::H512* mutable_lo();
  void set_allocated_lo(::types::H512* value);
  void unsafe_arena_set_allocated_lo(::types::H512* value);
  ::types::H512* unsafe_arena_release_lo();

  private:
  const ::types::H512& _internal_lo() const;
  ::types::H512* _internal_mutable_lo();

  public:
  // @@protoc_insertion_point(class_scope:types.H1024)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_H1024_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const H1024& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H512* hi_;
    ::types::H512* lo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ExecutionPayloadBodyV1 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.ExecutionPayloadBodyV1) */ {
 public:
  inline ExecutionPayloadBodyV1() : ExecutionPayloadBodyV1(nullptr) {}
  ~ExecutionPayloadBodyV1() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExecutionPayloadBodyV1(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExecutionPayloadBodyV1(const ExecutionPayloadBodyV1& from) : ExecutionPayloadBodyV1(nullptr, from) {}
  inline ExecutionPayloadBodyV1(ExecutionPayloadBodyV1&& from) noexcept
      : ExecutionPayloadBodyV1(nullptr, std::move(from)) {}
  inline ExecutionPayloadBodyV1& operator=(const ExecutionPayloadBodyV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionPayloadBodyV1& operator=(ExecutionPayloadBodyV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionPayloadBodyV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionPayloadBodyV1* internal_default_instance() {
    return reinterpret_cast<const ExecutionPayloadBodyV1*>(
        &_ExecutionPayloadBodyV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ExecutionPayloadBodyV1& a, ExecutionPayloadBodyV1& b) { a.Swap(&b); }
  inline void Swap(ExecutionPayloadBodyV1* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionPayloadBodyV1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionPayloadBodyV1* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExecutionPayloadBodyV1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExecutionPayloadBodyV1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExecutionPayloadBodyV1& from) { ExecutionPayloadBodyV1::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExecutionPayloadBodyV1* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.ExecutionPayloadBodyV1"; }

 protected:
  explicit ExecutionPayloadBodyV1(::google::protobuf::Arena* arena);
  ExecutionPayloadBodyV1(::google::protobuf::Arena* arena, const ExecutionPayloadBodyV1& from);
  ExecutionPayloadBodyV1(::google::protobuf::Arena* arena, ExecutionPayloadBodyV1&& from) noexcept
      : ExecutionPayloadBodyV1(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionsFieldNumber = 1,
    kWithdrawalsFieldNumber = 2,
  };
  // repeated bytes transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;

  public:
  void clear_transactions() ;
  const std::string& transactions(int index) const;
  std::string* mutable_transactions(int index);
  void set_transactions(int index, const std::string& value);
  void set_transactions(int index, std::string&& value);
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, std::size_t size);
  void set_transactions(int index, absl::string_view value);
  std::string* add_transactions();
  void add_transactions(const std::string& value);
  void add_transactions(std::string&& value);
  void add_transactions(const char* value);
  void add_transactions(const void* value, std::size_t size);
  void add_transactions(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& transactions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_transactions();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_transactions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_transactions();

  public:
  // repeated .types.Withdrawal withdrawals = 2;
  int withdrawals_size() const;
  private:
  int _internal_withdrawals_size() const;

  public:
  void clear_withdrawals() ;
  ::types::Withdrawal* mutable_withdrawals(int index);
  ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* mutable_withdrawals();

  private:
  const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& _internal_withdrawals() const;
  ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* _internal_mutable_withdrawals();
  public:
  const ::types::Withdrawal& withdrawals(int index) const;
  ::types::Withdrawal* add_withdrawals();
  const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& withdrawals() const;
  // @@protoc_insertion_point(class_scope:types.ExecutionPayloadBodyV1)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ExecutionPayloadBodyV1_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExecutionPayloadBodyV1& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> transactions_;
    ::google::protobuf::RepeatedPtrField< ::types::Withdrawal > withdrawals_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H2048 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.H2048) */ {
 public:
  inline H2048() : H2048(nullptr) {}
  ~H2048() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR H2048(
      ::google::protobuf::internal::ConstantInitialized);

  inline H2048(const H2048& from) : H2048(nullptr, from) {}
  inline H2048(H2048&& from) noexcept
      : H2048(nullptr, std::move(from)) {}
  inline H2048& operator=(const H2048& from) {
    CopyFrom(from);
    return *this;
  }
  inline H2048& operator=(H2048&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H2048& default_instance() {
    return *internal_default_instance();
  }
  static inline const H2048* internal_default_instance() {
    return reinterpret_cast<const H2048*>(
        &_H2048_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(H2048& a, H2048& b) { a.Swap(&b); }
  inline void Swap(H2048* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H2048* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H2048* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<H2048>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const H2048& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const H2048& from) { H2048::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(H2048* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.H2048"; }

 protected:
  explicit H2048(::google::protobuf::Arena* arena);
  H2048(::google::protobuf::Arena* arena, const H2048& from);
  H2048(::google::protobuf::Arena* arena, H2048&& from) noexcept
      : H2048(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H1024 hi = 1;
  bool has_hi() const;
  void clear_hi() ;
  const ::types::H1024& hi() const;
  PROTOBUF_NODISCARD ::types::H1024* release_hi();
  ::types::H1024* mutable_hi();
  void set_allocated_hi(::types::H1024* value);
  void unsafe_arena_set_allocated_hi(::types::H1024* value);
  ::types::H1024* unsafe_arena_release_hi();

  private:
  const ::types::H1024& _internal_hi() const;
  ::types::H1024* _internal_mutable_hi();

  public:
  // .types.H1024 lo = 2;
  bool has_lo() const;
  void clear_lo() ;
  const ::types::H1024& lo() const;
  PROTOBUF_NODISCARD ::types::H1024* release_lo();
  ::types::H1024* mutable_lo();
  void set_allocated_lo(::types::H1024* value);
  void unsafe_arena_set_allocated_lo(::types::H1024* value);
  ::types::H1024* unsafe_arena_release_lo();

  private:
  const ::types::H1024& _internal_lo() const;
  ::types::H1024* _internal_mutable_lo();

  public:
  // @@protoc_insertion_point(class_scope:types.H2048)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_H2048_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const H2048& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::types::H1024* hi_;
    ::types::H1024* lo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ExecutionPayload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:types.ExecutionPayload) */ {
 public:
  inline ExecutionPayload() : ExecutionPayload(nullptr) {}
  ~ExecutionPayload() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExecutionPayload(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExecutionPayload(const ExecutionPayload& from) : ExecutionPayload(nullptr, from) {}
  inline ExecutionPayload(ExecutionPayload&& from) noexcept
      : ExecutionPayload(nullptr, std::move(from)) {}
  inline ExecutionPayload& operator=(const ExecutionPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionPayload& operator=(ExecutionPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionPayload* internal_default_instance() {
    return reinterpret_cast<const ExecutionPayload*>(
        &_ExecutionPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ExecutionPayload& a, ExecutionPayload& b) { a.Swap(&b); }
  inline void Swap(ExecutionPayload* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionPayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionPayload* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExecutionPayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExecutionPayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExecutionPayload& from) { ExecutionPayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExecutionPayload* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "types.ExecutionPayload"; }

 protected:
  explicit ExecutionPayload(::google::protobuf::Arena* arena);
  ExecutionPayload(::google::protobuf::Arena* arena, const ExecutionPayload& from);
  ExecutionPayload(::google::protobuf::Arena* arena, ExecutionPayload&& from) noexcept
      : ExecutionPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionsFieldNumber = 15,
    kWithdrawalsFieldNumber = 16,
    kExtraDataFieldNumber = 12,
    kParentHashFieldNumber = 2,
    kCoinbaseFieldNumber = 3,
    kStateRootFieldNumber = 4,
    kReceiptRootFieldNumber = 5,
    kLogsBloomFieldNumber = 6,
    kPrevRandaoFieldNumber = 7,
    kBaseFeePerGasFieldNumber = 13,
    kBlockHashFieldNumber = 14,
    kBlockNumberFieldNumber = 8,
    kGasLimitFieldNumber = 9,
    kGasUsedFieldNumber = 10,
    kTimestampFieldNumber = 11,
    kBlobGasUsedFieldNumber = 17,
    kExcessBlobGasFieldNumber = 18,
    kVersionFieldNumber = 1,
  };
  // repeated bytes transactions = 15;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;

  public:
  void clear_transactions() ;
  const std::string& transactions(int index) const;
  std::string* mutable_transactions(int index);
  void set_transactions(int index, const std::string& value);
  void set_transactions(int index, std::string&& value);
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, std::size_t size);
  void set_transactions(int index, absl::string_view value);
  std::string* add_transactions();
  void add_transactions(const std::string& value);
  void add_transactions(std::string&& value);
  void add_transactions(const char* value);
  void add_transactions(const void* value, std::size_t size);
  void add_transactions(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& transactions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_transactions();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_transactions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_transactions();

  public:
  // repeated .types.Withdrawal withdrawals = 16;
  int withdrawals_size() const;
  private:
  int _internal_withdrawals_size() const;

  public:
  void clear_withdrawals() ;
  ::types::Withdrawal* mutable_withdrawals(int index);
  ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* mutable_withdrawals();

  private:
  const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& _internal_withdrawals() const;
  ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* _internal_mutable_withdrawals();
  public:
  const ::types::Withdrawal& withdrawals(int index) const;
  ::types::Withdrawal* add_withdrawals();
  const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& withdrawals() const;
  // bytes extra_data = 12;
  void clear_extra_data() ;
  const std::string& extra_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extra_data(Arg_&& arg, Args_... args);
  std::string* mutable_extra_data();
  PROTOBUF_NODISCARD std::string* release_extra_data();
  void set_allocated_extra_data(std::string* value);

  private:
  const std::string& _internal_extra_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_data(
      const std::string& value);
  std::string* _internal_mutable_extra_data();

  public:
  // .types.H256 parent_hash = 2;
  bool has_parent_hash() const;
  void clear_parent_hash() ;
  const ::types::H256& parent_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_parent_hash();
  ::types::H256* mutable_parent_hash();
  void set_allocated_parent_hash(::types::H256* value);
  void unsafe_arena_set_allocated_parent_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_parent_hash();

  private:
  const ::types::H256& _internal_parent_hash() const;
  ::types::H256* _internal_mutable_parent_hash();

  public:
  // .types.H160 coinbase = 3;
  bool has_coinbase() const;
  void clear_coinbase() ;
  const ::types::H160& coinbase() const;
  PROTOBUF_NODISCARD ::types::H160* release_coinbase();
  ::types::H160* mutable_coinbase();
  void set_allocated_coinbase(::types::H160* value);
  void unsafe_arena_set_allocated_coinbase(::types::H160* value);
  ::types::H160* unsafe_arena_release_coinbase();

  private:
  const ::types::H160& _internal_coinbase() const;
  ::types::H160* _internal_mutable_coinbase();

  public:
  // .types.H256 state_root = 4;
  bool has_state_root() const;
  void clear_state_root() ;
  const ::types::H256& state_root() const;
  PROTOBUF_NODISCARD ::types::H256* release_state_root();
  ::types::H256* mutable_state_root();
  void set_allocated_state_root(::types::H256* value);
  void unsafe_arena_set_allocated_state_root(::types::H256* value);
  ::types::H256* unsafe_arena_release_state_root();

  private:
  const ::types::H256& _internal_state_root() const;
  ::types::H256* _internal_mutable_state_root();

  public:
  // .types.H256 receipt_root = 5;
  bool has_receipt_root() const;
  void clear_receipt_root() ;
  const ::types::H256& receipt_root() const;
  PROTOBUF_NODISCARD ::types::H256* release_receipt_root();
  ::types::H256* mutable_receipt_root();
  void set_allocated_receipt_root(::types::H256* value);
  void unsafe_arena_set_allocated_receipt_root(::types::H256* value);
  ::types::H256* unsafe_arena_release_receipt_root();

  private:
  const ::types::H256& _internal_receipt_root() const;
  ::types::H256* _internal_mutable_receipt_root();

  public:
  // .types.H2048 logs_bloom = 6;
  bool has_logs_bloom() const;
  void clear_logs_bloom() ;
  const ::types::H2048& logs_bloom() const;
  PROTOBUF_NODISCARD ::types::H2048* release_logs_bloom();
  ::types::H2048* mutable_logs_bloom();
  void set_allocated_logs_bloom(::types::H2048* value);
  void unsafe_arena_set_allocated_logs_bloom(::types::H2048* value);
  ::types::H2048* unsafe_arena_release_logs_bloom();

  private:
  const ::types::H2048& _internal_logs_bloom() const;
  ::types::H2048* _internal_mutable_logs_bloom();

  public:
  // .types.H256 prev_randao = 7;
  bool has_prev_randao() const;
  void clear_prev_randao() ;
  const ::types::H256& prev_randao() const;
  PROTOBUF_NODISCARD ::types::H256* release_prev_randao();
  ::types::H256* mutable_prev_randao();
  void set_allocated_prev_randao(::types::H256* value);
  void unsafe_arena_set_allocated_prev_randao(::types::H256* value);
  ::types::H256* unsafe_arena_release_prev_randao();

  private:
  const ::types::H256& _internal_prev_randao() const;
  ::types::H256* _internal_mutable_prev_randao();

  public:
  // .types.H256 base_fee_per_gas = 13;
  bool has_base_fee_per_gas() const;
  void clear_base_fee_per_gas() ;
  const ::types::H256& base_fee_per_gas() const;
  PROTOBUF_NODISCARD ::types::H256* release_base_fee_per_gas();
  ::types::H256* mutable_base_fee_per_gas();
  void set_allocated_base_fee_per_gas(::types::H256* value);
  void unsafe_arena_set_allocated_base_fee_per_gas(::types::H256* value);
  ::types::H256* unsafe_arena_release_base_fee_per_gas();

  private:
  const ::types::H256& _internal_base_fee_per_gas() const;
  ::types::H256* _internal_mutable_base_fee_per_gas();

  public:
  // .types.H256 block_hash = 14;
  bool has_block_hash() const;
  void clear_block_hash() ;
  const ::types::H256& block_hash() const;
  PROTOBUF_NODISCARD ::types::H256* release_block_hash();
  ::types::H256* mutable_block_hash();
  void set_allocated_block_hash(::types::H256* value);
  void unsafe_arena_set_allocated_block_hash(::types::H256* value);
  ::types::H256* unsafe_arena_release_block_hash();

  private:
  const ::types::H256& _internal_block_hash() const;
  ::types::H256* _internal_mutable_block_hash();

  public:
  // uint64 block_number = 8;
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // uint64 gas_limit = 9;
  void clear_gas_limit() ;
  ::uint64_t gas_limit() const;
  void set_gas_limit(::uint64_t value);

  private:
  ::uint64_t _internal_gas_limit() const;
  void _internal_set_gas_limit(::uint64_t value);

  public:
  // uint64 gas_used = 10;
  void clear_gas_used() ;
  ::uint64_t gas_used() const;
  void set_gas_used(::uint64_t value);

  private:
  ::uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(::uint64_t value);

  public:
  // uint64 timestamp = 11;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional uint64 blob_gas_used = 17;
  bool has_blob_gas_used() const;
  void clear_blob_gas_used() ;
  ::uint64_t blob_gas_used() const;
  void set_blob_gas_used(::uint64_t value);

  private:
  ::uint64_t _internal_blob_gas_used() const;
  void _internal_set_blob_gas_used(::uint64_t value);

  public:
  // optional uint64 excess_blob_gas = 18;
  bool has_excess_blob_gas() const;
  void clear_excess_blob_gas() ;
  ::uint64_t excess_blob_gas() const;
  void set_excess_blob_gas(::uint64_t value);

  private:
  ::uint64_t _internal_excess_blob_gas() const;
  void _internal_set_excess_blob_gas(::uint64_t value);

  public:
  // uint32 version = 1;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:types.ExecutionPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 18, 9,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ExecutionPayload_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExecutionPayload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> transactions_;
    ::google::protobuf::RepeatedPtrField< ::types::Withdrawal > withdrawals_;
    ::google::protobuf::internal::ArenaStringPtr extra_data_;
    ::types::H256* parent_hash_;
    ::types::H160* coinbase_;
    ::types::H256* state_root_;
    ::types::H256* receipt_root_;
    ::types::H2048* logs_bloom_;
    ::types::H256* prev_randao_;
    ::types::H256* base_fee_per_gas_;
    ::types::H256* block_hash_;
    ::uint64_t block_number_;
    ::uint64_t gas_limit_;
    ::uint64_t gas_used_;
    ::uint64_t timestamp_;
    ::uint64_t blob_gas_used_;
    ::uint64_t excess_blob_gas_;
    ::uint32_t version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};

// ===================================================================



static const int kServiceMajorVersionFieldNumber = 50001;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::FileOptions, ::google::protobuf::internal::PrimitiveTypeTraits< ::uint32_t >, 13,
    false>
    service_major_version;
static const int kServiceMinorVersionFieldNumber = 50002;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::FileOptions, ::google::protobuf::internal::PrimitiveTypeTraits< ::uint32_t >, 13,
    false>
    service_minor_version;
static const int kServicePatchVersionFieldNumber = 50003;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::FileOptions, ::google::protobuf::internal::PrimitiveTypeTraits< ::uint32_t >, 13,
    false>
    service_patch_version;

// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// H128

// uint64 hi = 1;
inline void H128::clear_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hi_ = ::uint64_t{0u};
}
inline ::uint64_t H128::hi() const {
  // @@protoc_insertion_point(field_get:types.H128.hi)
  return _internal_hi();
}
inline void H128::set_hi(::uint64_t value) {
  _internal_set_hi(value);
  // @@protoc_insertion_point(field_set:types.H128.hi)
}
inline ::uint64_t H128::_internal_hi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hi_;
}
inline void H128::_internal_set_hi(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hi_ = value;
}

// uint64 lo = 2;
inline void H128::clear_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lo_ = ::uint64_t{0u};
}
inline ::uint64_t H128::lo() const {
  // @@protoc_insertion_point(field_get:types.H128.lo)
  return _internal_lo();
}
inline void H128::set_lo(::uint64_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:types.H128.lo)
}
inline ::uint64_t H128::_internal_lo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lo_;
}
inline void H128::_internal_set_lo(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lo_ = value;
}

// -------------------------------------------------------------------

// H160

// .types.H128 hi = 1;
inline bool H160::has_hi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hi_ != nullptr);
  return value;
}
inline void H160::clear_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ != nullptr) _impl_.hi_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::types::H128& H160::_internal_hi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H128* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(::types::_H128_default_instance_);
}
inline const ::types::H128& H160::hi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H160.hi)
  return _internal_hi();
}
inline void H160::unsafe_arena_set_allocated_hi(::types::H128* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = reinterpret_cast<::types::H128*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H160.hi)
}
inline ::types::H128* H160::release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H128* released = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H128* H160::unsafe_arena_release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H160.hi)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H128* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H128* H160::_internal_mutable_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H128>(GetArena());
    _impl_.hi_ = reinterpret_cast<::types::H128*>(p);
  }
  return _impl_.hi_;
}
inline ::types::H128* H160::mutable_hi() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H128* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H160.hi)
  return _msg;
}
inline void H160::set_allocated_hi(::types::H128* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hi_ = reinterpret_cast<::types::H128*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H160.hi)
}

// uint32 lo = 2;
inline void H160::clear_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lo_ = 0u;
}
inline ::uint32_t H160::lo() const {
  // @@protoc_insertion_point(field_get:types.H160.lo)
  return _internal_lo();
}
inline void H160::set_lo(::uint32_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:types.H160.lo)
}
inline ::uint32_t H160::_internal_lo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lo_;
}
inline void H160::_internal_set_lo(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lo_ = value;
}

// -------------------------------------------------------------------

// H256

// .types.H128 hi = 1;
inline bool H256::has_hi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hi_ != nullptr);
  return value;
}
inline void H256::clear_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ != nullptr) _impl_.hi_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::types::H128& H256::_internal_hi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H128* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(::types::_H128_default_instance_);
}
inline const ::types::H128& H256::hi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H256.hi)
  return _internal_hi();
}
inline void H256::unsafe_arena_set_allocated_hi(::types::H128* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = reinterpret_cast<::types::H128*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H256.hi)
}
inline ::types::H128* H256::release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H128* released = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H128* H256::unsafe_arena_release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H256.hi)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H128* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H128* H256::_internal_mutable_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H128>(GetArena());
    _impl_.hi_ = reinterpret_cast<::types::H128*>(p);
  }
  return _impl_.hi_;
}
inline ::types::H128* H256::mutable_hi() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H128* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H256.hi)
  return _msg;
}
inline void H256::set_allocated_hi(::types::H128* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hi_ = reinterpret_cast<::types::H128*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H256.hi)
}

// .types.H128 lo = 2;
inline bool H256::has_lo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lo_ != nullptr);
  return value;
}
inline void H256::clear_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lo_ != nullptr) _impl_.lo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::types::H128& H256::_internal_lo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H128* p = _impl_.lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(::types::_H128_default_instance_);
}
inline const ::types::H128& H256::lo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H256.lo)
  return _internal_lo();
}
inline void H256::unsafe_arena_set_allocated_lo(::types::H128* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lo_);
  }
  _impl_.lo_ = reinterpret_cast<::types::H128*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H256.lo)
}
inline ::types::H128* H256::release_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H128* released = _impl_.lo_;
  _impl_.lo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H128* H256::unsafe_arena_release_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H256.lo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H128* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
  return temp;
}
inline ::types::H128* H256::_internal_mutable_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H128>(GetArena());
    _impl_.lo_ = reinterpret_cast<::types::H128*>(p);
  }
  return _impl_.lo_;
}
inline ::types::H128* H256::mutable_lo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H128* _msg = _internal_mutable_lo();
  // @@protoc_insertion_point(field_mutable:types.H256.lo)
  return _msg;
}
inline void H256::set_allocated_lo(::types::H128* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lo_ = reinterpret_cast<::types::H128*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H256.lo)
}

// -------------------------------------------------------------------

// H512

// .types.H256 hi = 1;
inline bool H512::has_hi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hi_ != nullptr);
  return value;
}
inline void H512::clear_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ != nullptr) _impl_.hi_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::types::H256& H512::_internal_hi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& H512::hi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H512.hi)
  return _internal_hi();
}
inline void H512::unsafe_arena_set_allocated_hi(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H512.hi)
}
inline ::types::H256* H512::release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* H512::unsafe_arena_release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H512.hi)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H256* H512::_internal_mutable_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.hi_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.hi_;
}
inline ::types::H256* H512::mutable_hi() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H512.hi)
  return _msg;
}
inline void H512::set_allocated_hi(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hi_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H512.hi)
}

// .types.H256 lo = 2;
inline bool H512::has_lo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lo_ != nullptr);
  return value;
}
inline void H512::clear_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lo_ != nullptr) _impl_.lo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::types::H256& H512::_internal_lo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& H512::lo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H512.lo)
  return _internal_lo();
}
inline void H512::unsafe_arena_set_allocated_lo(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lo_);
  }
  _impl_.lo_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H512.lo)
}
inline ::types::H256* H512::release_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* released = _impl_.lo_;
  _impl_.lo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* H512::unsafe_arena_release_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H512.lo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H256* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
  return temp;
}
inline ::types::H256* H512::_internal_mutable_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.lo_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.lo_;
}
inline ::types::H256* H512::mutable_lo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H256* _msg = _internal_mutable_lo();
  // @@protoc_insertion_point(field_mutable:types.H512.lo)
  return _msg;
}
inline void H512::set_allocated_lo(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lo_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H512.lo)
}

// -------------------------------------------------------------------

// H1024

// .types.H512 hi = 1;
inline bool H1024::has_hi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hi_ != nullptr);
  return value;
}
inline void H1024::clear_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ != nullptr) _impl_.hi_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::types::H512& H1024::_internal_hi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H512* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(::types::_H512_default_instance_);
}
inline const ::types::H512& H1024::hi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H1024.hi)
  return _internal_hi();
}
inline void H1024::unsafe_arena_set_allocated_hi(::types::H512* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = reinterpret_cast<::types::H512*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H1024.hi)
}
inline ::types::H512* H1024::release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H512* released = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H512* H1024::unsafe_arena_release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H1024.hi)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H512* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H512* H1024::_internal_mutable_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H512>(GetArena());
    _impl_.hi_ = reinterpret_cast<::types::H512*>(p);
  }
  return _impl_.hi_;
}
inline ::types::H512* H1024::mutable_hi() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H512* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H1024.hi)
  return _msg;
}
inline void H1024::set_allocated_hi(::types::H512* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hi_ = reinterpret_cast<::types::H512*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H1024.hi)
}

// .types.H512 lo = 2;
inline bool H1024::has_lo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lo_ != nullptr);
  return value;
}
inline void H1024::clear_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lo_ != nullptr) _impl_.lo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::types::H512& H1024::_internal_lo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H512* p = _impl_.lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(::types::_H512_default_instance_);
}
inline const ::types::H512& H1024::lo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H1024.lo)
  return _internal_lo();
}
inline void H1024::unsafe_arena_set_allocated_lo(::types::H512* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lo_);
  }
  _impl_.lo_ = reinterpret_cast<::types::H512*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H1024.lo)
}
inline ::types::H512* H1024::release_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H512* released = _impl_.lo_;
  _impl_.lo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H512* H1024::unsafe_arena_release_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H1024.lo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H512* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
  return temp;
}
inline ::types::H512* H1024::_internal_mutable_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H512>(GetArena());
    _impl_.lo_ = reinterpret_cast<::types::H512*>(p);
  }
  return _impl_.lo_;
}
inline ::types::H512* H1024::mutable_lo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H512* _msg = _internal_mutable_lo();
  // @@protoc_insertion_point(field_mutable:types.H1024.lo)
  return _msg;
}
inline void H1024::set_allocated_lo(::types::H512* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lo_ = reinterpret_cast<::types::H512*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H1024.lo)
}

// -------------------------------------------------------------------

// H2048

// .types.H1024 hi = 1;
inline bool H2048::has_hi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hi_ != nullptr);
  return value;
}
inline void H2048::clear_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ != nullptr) _impl_.hi_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::types::H1024& H2048::_internal_hi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H1024* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H1024&>(::types::_H1024_default_instance_);
}
inline const ::types::H1024& H2048::hi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H2048.hi)
  return _internal_hi();
}
inline void H2048::unsafe_arena_set_allocated_hi(::types::H1024* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = reinterpret_cast<::types::H1024*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H2048.hi)
}
inline ::types::H1024* H2048::release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H1024* released = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H1024* H2048::unsafe_arena_release_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H2048.hi)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H1024* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H1024* H2048::_internal_mutable_hi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H1024>(GetArena());
    _impl_.hi_ = reinterpret_cast<::types::H1024*>(p);
  }
  return _impl_.hi_;
}
inline ::types::H1024* H2048::mutable_hi() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H1024* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H2048.hi)
  return _msg;
}
inline void H2048::set_allocated_hi(::types::H1024* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hi_ = reinterpret_cast<::types::H1024*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H2048.hi)
}

// .types.H1024 lo = 2;
inline bool H2048::has_lo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lo_ != nullptr);
  return value;
}
inline void H2048::clear_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lo_ != nullptr) _impl_.lo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::types::H1024& H2048::_internal_lo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H1024* p = _impl_.lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H1024&>(::types::_H1024_default_instance_);
}
inline const ::types::H1024& H2048::lo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.H2048.lo)
  return _internal_lo();
}
inline void H2048::unsafe_arena_set_allocated_lo(::types::H1024* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lo_);
  }
  _impl_.lo_ = reinterpret_cast<::types::H1024*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H2048.lo)
}
inline ::types::H1024* H2048::release_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H1024* released = _impl_.lo_;
  _impl_.lo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H1024* H2048::unsafe_arena_release_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.H2048.lo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H1024* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
  return temp;
}
inline ::types::H1024* H2048::_internal_mutable_lo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H1024>(GetArena());
    _impl_.lo_ = reinterpret_cast<::types::H1024*>(p);
  }
  return _impl_.lo_;
}
inline ::types::H1024* H2048::mutable_lo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H1024* _msg = _internal_mutable_lo();
  // @@protoc_insertion_point(field_mutable:types.H2048.lo)
  return _msg;
}
inline void H2048::set_allocated_lo(::types::H1024* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lo_ = reinterpret_cast<::types::H1024*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.H2048.lo)
}

// -------------------------------------------------------------------

// VersionReply

// uint32 major = 1;
inline void VersionReply::clear_major() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.major_ = 0u;
}
inline ::uint32_t VersionReply::major() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.major)
  return _internal_major();
}
inline void VersionReply::set_major(::uint32_t value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.major)
}
inline ::uint32_t VersionReply::_internal_major() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.major_;
}
inline void VersionReply::_internal_set_major(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.major_ = value;
}

// uint32 minor = 2;
inline void VersionReply::clear_minor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minor_ = 0u;
}
inline ::uint32_t VersionReply::minor() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.minor)
  return _internal_minor();
}
inline void VersionReply::set_minor(::uint32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.minor)
}
inline ::uint32_t VersionReply::_internal_minor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.minor_;
}
inline void VersionReply::_internal_set_minor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minor_ = value;
}

// uint32 patch = 3;
inline void VersionReply::clear_patch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.patch_ = 0u;
}
inline ::uint32_t VersionReply::patch() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.patch)
  return _internal_patch();
}
inline void VersionReply::set_patch(::uint32_t value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.patch)
}
inline ::uint32_t VersionReply::_internal_patch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.patch_;
}
inline void VersionReply::_internal_set_patch(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.patch_ = value;
}

// -------------------------------------------------------------------

// ExecutionPayload

// uint32 version = 1;
inline void ExecutionPayload::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0u;
}
inline ::uint32_t ExecutionPayload::version() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.version)
  return _internal_version();
}
inline void ExecutionPayload::set_version(::uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.version)
}
inline ::uint32_t ExecutionPayload::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void ExecutionPayload::_internal_set_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// .types.H256 parent_hash = 2;
inline bool ExecutionPayload::has_parent_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_hash_ != nullptr);
  return value;
}
inline void ExecutionPayload::clear_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parent_hash_ != nullptr) _impl_.parent_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::types::H256& ExecutionPayload::_internal_parent_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.parent_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::parent_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.parent_hash)
  return _internal_parent_hash();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_parent_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_hash_);
  }
  _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.parent_hash)
}
inline ::types::H256* ExecutionPayload::release_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* released = _impl_.parent_hash_;
  _impl_.parent_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.parent_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H256* temp = _impl_.parent_hash_;
  _impl_.parent_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_parent_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parent_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.parent_hash_;
}
inline ::types::H256* ExecutionPayload::mutable_parent_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H256* _msg = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.parent_hash)
  return _msg;
}
inline void ExecutionPayload::set_allocated_parent_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parent_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.parent_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.parent_hash)
}

// .types.H160 coinbase = 3;
inline bool ExecutionPayload::has_coinbase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.coinbase_ != nullptr);
  return value;
}
inline void ExecutionPayload::clear_coinbase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.coinbase_ != nullptr) _impl_.coinbase_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::types::H160& ExecutionPayload::_internal_coinbase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H160* p = _impl_.coinbase_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(::types::_H160_default_instance_);
}
inline const ::types::H160& ExecutionPayload::coinbase() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.coinbase)
  return _internal_coinbase();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_coinbase(::types::H160* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.coinbase_);
  }
  _impl_.coinbase_ = reinterpret_cast<::types::H160*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.coinbase)
}
inline ::types::H160* ExecutionPayload::release_coinbase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H160* released = _impl_.coinbase_;
  _impl_.coinbase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H160* ExecutionPayload::unsafe_arena_release_coinbase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.coinbase)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::types::H160* temp = _impl_.coinbase_;
  _impl_.coinbase_ = nullptr;
  return temp;
}
inline ::types::H160* ExecutionPayload::_internal_mutable_coinbase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.coinbase_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H160>(GetArena());
    _impl_.coinbase_ = reinterpret_cast<::types::H160*>(p);
  }
  return _impl_.coinbase_;
}
inline ::types::H160* ExecutionPayload::mutable_coinbase() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::types::H160* _msg = _internal_mutable_coinbase();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.coinbase)
  return _msg;
}
inline void ExecutionPayload::set_allocated_coinbase(::types::H160* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.coinbase_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.coinbase_ = reinterpret_cast<::types::H160*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.coinbase)
}

// .types.H256 state_root = 4;
inline bool ExecutionPayload::has_state_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_root_ != nullptr);
  return value;
}
inline void ExecutionPayload::clear_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_root_ != nullptr) _impl_.state_root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::types::H256& ExecutionPayload::_internal_state_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::state_root() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.state_root)
  return _internal_state_root();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_state_root(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_root_);
  }
  _impl_.state_root_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.state_root)
}
inline ::types::H256* ExecutionPayload::release_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H256* released = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.state_root)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::types::H256* temp = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_root_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.state_root_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.state_root_;
}
inline ::types::H256* ExecutionPayload::mutable_state_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::types::H256* _msg = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.state_root)
  return _msg;
}
inline void ExecutionPayload::set_allocated_state_root(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.state_root_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.state_root_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.state_root)
}

// .types.H256 receipt_root = 5;
inline bool ExecutionPayload::has_receipt_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receipt_root_ != nullptr);
  return value;
}
inline void ExecutionPayload::clear_receipt_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.receipt_root_ != nullptr) _impl_.receipt_root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::types::H256& ExecutionPayload::_internal_receipt_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.receipt_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::receipt_root() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.receipt_root)
  return _internal_receipt_root();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_receipt_root(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receipt_root_);
  }
  _impl_.receipt_root_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.receipt_root)
}
inline ::types::H256* ExecutionPayload::release_receipt_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::types::H256* released = _impl_.receipt_root_;
  _impl_.receipt_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_receipt_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.receipt_root)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::types::H256* temp = _impl_.receipt_root_;
  _impl_.receipt_root_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_receipt_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.receipt_root_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.receipt_root_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.receipt_root_;
}
inline ::types::H256* ExecutionPayload::mutable_receipt_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::types::H256* _msg = _internal_mutable_receipt_root();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.receipt_root)
  return _msg;
}
inline void ExecutionPayload::set_allocated_receipt_root(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.receipt_root_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.receipt_root_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.receipt_root)
}

// .types.H2048 logs_bloom = 6;
inline bool ExecutionPayload::has_logs_bloom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logs_bloom_ != nullptr);
  return value;
}
inline void ExecutionPayload::clear_logs_bloom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logs_bloom_ != nullptr) _impl_.logs_bloom_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::types::H2048& ExecutionPayload::_internal_logs_bloom() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H2048* p = _impl_.logs_bloom_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H2048&>(::types::_H2048_default_instance_);
}
inline const ::types::H2048& ExecutionPayload::logs_bloom() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.logs_bloom)
  return _internal_logs_bloom();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_logs_bloom(::types::H2048* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logs_bloom_);
  }
  _impl_.logs_bloom_ = reinterpret_cast<::types::H2048*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.logs_bloom)
}
inline ::types::H2048* ExecutionPayload::release_logs_bloom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::types::H2048* released = _impl_.logs_bloom_;
  _impl_.logs_bloom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H2048* ExecutionPayload::unsafe_arena_release_logs_bloom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.logs_bloom)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::types::H2048* temp = _impl_.logs_bloom_;
  _impl_.logs_bloom_ = nullptr;
  return temp;
}
inline ::types::H2048* ExecutionPayload::_internal_mutable_logs_bloom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logs_bloom_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H2048>(GetArena());
    _impl_.logs_bloom_ = reinterpret_cast<::types::H2048*>(p);
  }
  return _impl_.logs_bloom_;
}
inline ::types::H2048* ExecutionPayload::mutable_logs_bloom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::types::H2048* _msg = _internal_mutable_logs_bloom();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.logs_bloom)
  return _msg;
}
inline void ExecutionPayload::set_allocated_logs_bloom(::types::H2048* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.logs_bloom_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.logs_bloom_ = reinterpret_cast<::types::H2048*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.logs_bloom)
}

// .types.H256 prev_randao = 7;
inline bool ExecutionPayload::has_prev_randao() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prev_randao_ != nullptr);
  return value;
}
inline void ExecutionPayload::clear_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.prev_randao_ != nullptr) _impl_.prev_randao_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::types::H256& ExecutionPayload::_internal_prev_randao() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.prev_randao_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::prev_randao() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.prev_randao)
  return _internal_prev_randao();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_prev_randao(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prev_randao_);
  }
  _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.prev_randao)
}
inline ::types::H256* ExecutionPayload::release_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::types::H256* released = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.prev_randao)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::types::H256* temp = _impl_.prev_randao_;
  _impl_.prev_randao_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_prev_randao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.prev_randao_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.prev_randao_;
}
inline ::types::H256* ExecutionPayload::mutable_prev_randao() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::types::H256* _msg = _internal_mutable_prev_randao();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.prev_randao)
  return _msg;
}
inline void ExecutionPayload::set_allocated_prev_randao(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.prev_randao_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.prev_randao_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.prev_randao)
}

// uint64 block_number = 8;
inline void ExecutionPayload::clear_block_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t ExecutionPayload::block_number() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.block_number)
  return _internal_block_number();
}
inline void ExecutionPayload::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.block_number)
}
inline ::uint64_t ExecutionPayload::_internal_block_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_number_;
}
inline void ExecutionPayload::_internal_set_block_number(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_number_ = value;
}

// uint64 gas_limit = 9;
inline void ExecutionPayload::clear_gas_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_limit_ = ::uint64_t{0u};
}
inline ::uint64_t ExecutionPayload::gas_limit() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.gas_limit)
  return _internal_gas_limit();
}
inline void ExecutionPayload::set_gas_limit(::uint64_t value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.gas_limit)
}
inline ::uint64_t ExecutionPayload::_internal_gas_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gas_limit_;
}
inline void ExecutionPayload::_internal_set_gas_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_limit_ = value;
}

// uint64 gas_used = 10;
inline void ExecutionPayload::clear_gas_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_used_ = ::uint64_t{0u};
}
inline ::uint64_t ExecutionPayload::gas_used() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.gas_used)
  return _internal_gas_used();
}
inline void ExecutionPayload::set_gas_used(::uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.gas_used)
}
inline ::uint64_t ExecutionPayload::_internal_gas_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gas_used_;
}
inline void ExecutionPayload::_internal_set_gas_used(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_used_ = value;
}

// uint64 timestamp = 11;
inline void ExecutionPayload::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t ExecutionPayload::timestamp() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.timestamp)
  return _internal_timestamp();
}
inline void ExecutionPayload::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.timestamp)
}
inline ::uint64_t ExecutionPayload::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void ExecutionPayload::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// bytes extra_data = 12;
inline void ExecutionPayload::clear_extra_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_data_.ClearToEmpty();
}
inline const std::string& ExecutionPayload::extra_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.extra_data)
  return _internal_extra_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecutionPayload::set_extra_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.extra_data)
}
inline std::string* ExecutionPayload::mutable_extra_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extra_data();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.extra_data)
  return _s;
}
inline const std::string& ExecutionPayload::_internal_extra_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extra_data_.Get();
}
inline void ExecutionPayload::_internal_set_extra_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_data_.Set(value, GetArena());
}
inline std::string* ExecutionPayload::_internal_mutable_extra_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.extra_data_.Mutable( GetArena());
}
inline std::string* ExecutionPayload::release_extra_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.extra_data)
  return _impl_.extra_data_.Release();
}
inline void ExecutionPayload::set_allocated_extra_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extra_data_.IsDefault()) {
          _impl_.extra_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.extra_data)
}

// .types.H256 base_fee_per_gas = 13;
inline bool ExecutionPayload::has_base_fee_per_gas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_fee_per_gas_ != nullptr);
  return value;
}
inline void ExecutionPayload::clear_base_fee_per_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_fee_per_gas_ != nullptr) _impl_.base_fee_per_gas_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::types::H256& ExecutionPayload::_internal_base_fee_per_gas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.base_fee_per_gas_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::base_fee_per_gas() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.base_fee_per_gas)
  return _internal_base_fee_per_gas();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_base_fee_per_gas(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_fee_per_gas_);
  }
  _impl_.base_fee_per_gas_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.base_fee_per_gas)
}
inline ::types::H256* ExecutionPayload::release_base_fee_per_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::types::H256* released = _impl_.base_fee_per_gas_;
  _impl_.base_fee_per_gas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_base_fee_per_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.base_fee_per_gas)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::types::H256* temp = _impl_.base_fee_per_gas_;
  _impl_.base_fee_per_gas_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_base_fee_per_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_fee_per_gas_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.base_fee_per_gas_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.base_fee_per_gas_;
}
inline ::types::H256* ExecutionPayload::mutable_base_fee_per_gas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::types::H256* _msg = _internal_mutable_base_fee_per_gas();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.base_fee_per_gas)
  return _msg;
}
inline void ExecutionPayload::set_allocated_base_fee_per_gas(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.base_fee_per_gas_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.base_fee_per_gas_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.base_fee_per_gas)
}

// .types.H256 block_hash = 14;
inline bool ExecutionPayload::has_block_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_hash_ != nullptr);
  return value;
}
inline void ExecutionPayload::clear_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_hash_ != nullptr) _impl_.block_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::types::H256& ExecutionPayload::_internal_block_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H256* p = _impl_.block_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::block_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.block_hash)
  return _internal_block_hash();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_block_hash(::types::H256* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_hash_);
  }
  _impl_.block_hash_ = reinterpret_cast<::types::H256*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.block_hash)
}
inline ::types::H256* ExecutionPayload::release_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::types::H256* released = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.block_hash)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::types::H256* temp = _impl_.block_hash_;
  _impl_.block_hash_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_block_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H256>(GetArena());
    _impl_.block_hash_ = reinterpret_cast<::types::H256*>(p);
  }
  return _impl_.block_hash_;
}
inline ::types::H256* ExecutionPayload::mutable_block_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::types::H256* _msg = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.block_hash)
  return _msg;
}
inline void ExecutionPayload::set_allocated_block_hash(::types::H256* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.block_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.block_hash_ = reinterpret_cast<::types::H256*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.block_hash)
}

// repeated bytes transactions = 15;
inline int ExecutionPayload::_internal_transactions_size() const {
  return _internal_transactions().size();
}
inline int ExecutionPayload::transactions_size() const {
  return _internal_transactions_size();
}
inline void ExecutionPayload::clear_transactions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transactions_.Clear();
}
inline std::string* ExecutionPayload::add_transactions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_transactions()->Add();
  // @@protoc_insertion_point(field_add_mutable:types.ExecutionPayload.transactions)
  return _s;
}
inline const std::string& ExecutionPayload::transactions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.transactions)
  return _internal_transactions().Get(index);
}
inline std::string* ExecutionPayload::mutable_transactions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.transactions)
  return _internal_mutable_transactions()->Mutable(index);
}
inline void ExecutionPayload::set_transactions(int index, const std::string& value) {
  _internal_mutable_transactions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::set_transactions(int index, std::string&& value) {
  _internal_mutable_transactions()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::set_transactions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transactions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::set_transactions(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_transactions()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::set_transactions(int index, absl::string_view value) {
  _internal_mutable_transactions()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::add_transactions(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::add_transactions(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::add_transactions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::add_transactions(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::add_transactions(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:types.ExecutionPayload.transactions)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExecutionPayload::transactions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.ExecutionPayload.transactions)
  return _internal_transactions();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExecutionPayload::mutable_transactions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.ExecutionPayload.transactions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_transactions();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExecutionPayload::_internal_transactions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transactions_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExecutionPayload::_internal_mutable_transactions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.transactions_;
}

// repeated .types.Withdrawal withdrawals = 16;
inline int ExecutionPayload::_internal_withdrawals_size() const {
  return _internal_withdrawals().size();
}
inline int ExecutionPayload::withdrawals_size() const {
  return _internal_withdrawals_size();
}
inline void ExecutionPayload::clear_withdrawals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.withdrawals_.Clear();
}
inline ::types::Withdrawal* ExecutionPayload::mutable_withdrawals(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.withdrawals)
  return _internal_mutable_withdrawals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* ExecutionPayload::mutable_withdrawals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.ExecutionPayload.withdrawals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_withdrawals();
}
inline const ::types::Withdrawal& ExecutionPayload::withdrawals(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.withdrawals)
  return _internal_withdrawals().Get(index);
}
inline ::types::Withdrawal* ExecutionPayload::add_withdrawals() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::types::Withdrawal* _add = _internal_mutable_withdrawals()->Add();
  // @@protoc_insertion_point(field_add:types.ExecutionPayload.withdrawals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& ExecutionPayload::withdrawals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.ExecutionPayload.withdrawals)
  return _internal_withdrawals();
}
inline const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>&
ExecutionPayload::_internal_withdrawals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.withdrawals_;
}
inline ::google::protobuf::RepeatedPtrField<::types::Withdrawal>*
ExecutionPayload::_internal_mutable_withdrawals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.withdrawals_;
}

// optional uint64 blob_gas_used = 17;
inline bool ExecutionPayload::has_blob_gas_used() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ExecutionPayload::clear_blob_gas_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blob_gas_used_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t ExecutionPayload::blob_gas_used() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.blob_gas_used)
  return _internal_blob_gas_used();
}
inline void ExecutionPayload::set_blob_gas_used(::uint64_t value) {
  _internal_set_blob_gas_used(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.blob_gas_used)
}
inline ::uint64_t ExecutionPayload::_internal_blob_gas_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blob_gas_used_;
}
inline void ExecutionPayload::_internal_set_blob_gas_used(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blob_gas_used_ = value;
}

// optional uint64 excess_blob_gas = 18;
inline bool ExecutionPayload::has_excess_blob_gas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ExecutionPayload::clear_excess_blob_gas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.excess_blob_gas_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t ExecutionPayload::excess_blob_gas() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.excess_blob_gas)
  return _internal_excess_blob_gas();
}
inline void ExecutionPayload::set_excess_blob_gas(::uint64_t value) {
  _internal_set_excess_blob_gas(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.excess_blob_gas)
}
inline ::uint64_t ExecutionPayload::_internal_excess_blob_gas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.excess_blob_gas_;
}
inline void ExecutionPayload::_internal_set_excess_blob_gas(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.excess_blob_gas_ = value;
}

// -------------------------------------------------------------------

// Withdrawal

// uint64 index = 1;
inline void Withdrawal::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = ::uint64_t{0u};
}
inline ::uint64_t Withdrawal::index() const {
  // @@protoc_insertion_point(field_get:types.Withdrawal.index)
  return _internal_index();
}
inline void Withdrawal::set_index(::uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:types.Withdrawal.index)
}
inline ::uint64_t Withdrawal::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void Withdrawal::_internal_set_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// uint64 validator_index = 2;
inline void Withdrawal::clear_validator_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_index_ = ::uint64_t{0u};
}
inline ::uint64_t Withdrawal::validator_index() const {
  // @@protoc_insertion_point(field_get:types.Withdrawal.validator_index)
  return _internal_validator_index();
}
inline void Withdrawal::set_validator_index(::uint64_t value) {
  _internal_set_validator_index(value);
  // @@protoc_insertion_point(field_set:types.Withdrawal.validator_index)
}
inline ::uint64_t Withdrawal::_internal_validator_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validator_index_;
}
inline void Withdrawal::_internal_set_validator_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_index_ = value;
}

// .types.H160 address = 3;
inline bool Withdrawal::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline void Withdrawal::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ != nullptr) _impl_.address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::types::H160& Withdrawal::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::H160* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(::types::_H160_default_instance_);
}
inline const ::types::H160& Withdrawal::address() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.Withdrawal.address)
  return _internal_address();
}
inline void Withdrawal::unsafe_arena_set_allocated_address(::types::H160* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::types::H160*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.Withdrawal.address)
}
inline ::types::H160* Withdrawal::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H160* released = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::H160* Withdrawal::unsafe_arena_release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.Withdrawal.address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::types::H160* Withdrawal::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::H160>(GetArena());
    _impl_.address_ = reinterpret_cast<::types::H160*>(p);
  }
  return _impl_.address_;
}
inline ::types::H160* Withdrawal::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::H160* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:types.Withdrawal.address)
  return _msg;
}
inline void Withdrawal::set_allocated_address(::types::H160* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.address_ = reinterpret_cast<::types::H160*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.Withdrawal.address)
}

// uint64 amount = 4;
inline void Withdrawal::clear_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amount_ = ::uint64_t{0u};
}
inline ::uint64_t Withdrawal::amount() const {
  // @@protoc_insertion_point(field_get:types.Withdrawal.amount)
  return _internal_amount();
}
inline void Withdrawal::set_amount(::uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:types.Withdrawal.amount)
}
inline ::uint64_t Withdrawal::_internal_amount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.amount_;
}
inline void Withdrawal::_internal_set_amount(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amount_ = value;
}

// -------------------------------------------------------------------

// BlobsBundleV1

// repeated bytes commitments = 1;
inline int BlobsBundleV1::_internal_commitments_size() const {
  return _internal_commitments().size();
}
inline int BlobsBundleV1::commitments_size() const {
  return _internal_commitments_size();
}
inline void BlobsBundleV1::clear_commitments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitments_.Clear();
}
inline std::string* BlobsBundleV1::add_commitments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_commitments()->Add();
  // @@protoc_insertion_point(field_add_mutable:types.BlobsBundleV1.commitments)
  return _s;
}
inline const std::string& BlobsBundleV1::commitments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.BlobsBundleV1.commitments)
  return _internal_commitments().Get(index);
}
inline std::string* BlobsBundleV1::mutable_commitments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.BlobsBundleV1.commitments)
  return _internal_mutable_commitments()->Mutable(index);
}
inline void BlobsBundleV1::set_commitments(int index, const std::string& value) {
  _internal_mutable_commitments()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::set_commitments(int index, std::string&& value) {
  _internal_mutable_commitments()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::set_commitments(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_commitments()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::set_commitments(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_commitments()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::set_commitments(int index, absl::string_view value) {
  _internal_mutable_commitments()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::add_commitments(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_commitments()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::add_commitments(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_commitments()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::add_commitments(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_commitments()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::add_commitments(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_commitments()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.BlobsBundleV1.commitments)
}
inline void BlobsBundleV1::add_commitments(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_commitments()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:types.BlobsBundleV1.commitments)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlobsBundleV1::commitments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.BlobsBundleV1.commitments)
  return _internal_commitments();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlobsBundleV1::mutable_commitments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.BlobsBundleV1.commitments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_commitments();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlobsBundleV1::_internal_commitments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.commitments_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlobsBundleV1::_internal_mutable_commitments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.commitments_;
}

// repeated bytes blobs = 2;
inline int BlobsBundleV1::_internal_blobs_size() const {
  return _internal_blobs().size();
}
inline int BlobsBundleV1::blobs_size() const {
  return _internal_blobs_size();
}
inline void BlobsBundleV1::clear_blobs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blobs_.Clear();
}
inline std::string* BlobsBundleV1::add_blobs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_blobs()->Add();
  // @@protoc_insertion_point(field_add_mutable:types.BlobsBundleV1.blobs)
  return _s;
}
inline const std::string& BlobsBundleV1::blobs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.BlobsBundleV1.blobs)
  return _internal_blobs().Get(index);
}
inline std::string* BlobsBundleV1::mutable_blobs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.BlobsBundleV1.blobs)
  return _internal_mutable_blobs()->Mutable(index);
}
inline void BlobsBundleV1::set_blobs(int index, const std::string& value) {
  _internal_mutable_blobs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::set_blobs(int index, std::string&& value) {
  _internal_mutable_blobs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::set_blobs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_blobs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::set_blobs(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_blobs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::set_blobs(int index, absl::string_view value) {
  _internal_mutable_blobs()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::add_blobs(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_blobs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::add_blobs(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_blobs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::add_blobs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_blobs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::add_blobs(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_blobs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.BlobsBundleV1.blobs)
}
inline void BlobsBundleV1::add_blobs(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_blobs()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:types.BlobsBundleV1.blobs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlobsBundleV1::blobs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.BlobsBundleV1.blobs)
  return _internal_blobs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlobsBundleV1::mutable_blobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.BlobsBundleV1.blobs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_blobs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlobsBundleV1::_internal_blobs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blobs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlobsBundleV1::_internal_mutable_blobs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.blobs_;
}

// repeated bytes proofs = 3;
inline int BlobsBundleV1::_internal_proofs_size() const {
  return _internal_proofs().size();
}
inline int BlobsBundleV1::proofs_size() const {
  return _internal_proofs_size();
}
inline void BlobsBundleV1::clear_proofs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proofs_.Clear();
}
inline std::string* BlobsBundleV1::add_proofs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_proofs()->Add();
  // @@protoc_insertion_point(field_add_mutable:types.BlobsBundleV1.proofs)
  return _s;
}
inline const std::string& BlobsBundleV1::proofs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.BlobsBundleV1.proofs)
  return _internal_proofs().Get(index);
}
inline std::string* BlobsBundleV1::mutable_proofs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.BlobsBundleV1.proofs)
  return _internal_mutable_proofs()->Mutable(index);
}
inline void BlobsBundleV1::set_proofs(int index, const std::string& value) {
  _internal_mutable_proofs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::set_proofs(int index, std::string&& value) {
  _internal_mutable_proofs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::set_proofs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_proofs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::set_proofs(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_proofs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::set_proofs(int index, absl::string_view value) {
  _internal_mutable_proofs()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::add_proofs(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_proofs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::add_proofs(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_proofs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::add_proofs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_proofs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::add_proofs(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_proofs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.BlobsBundleV1.proofs)
}
inline void BlobsBundleV1::add_proofs(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_proofs()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:types.BlobsBundleV1.proofs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlobsBundleV1::proofs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.BlobsBundleV1.proofs)
  return _internal_proofs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlobsBundleV1::mutable_proofs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.BlobsBundleV1.proofs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_proofs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BlobsBundleV1::_internal_proofs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.proofs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BlobsBundleV1::_internal_mutable_proofs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.proofs_;
}

// -------------------------------------------------------------------

// RequestsBundle

// repeated bytes requests = 1;
inline int RequestsBundle::_internal_requests_size() const {
  return _internal_requests().size();
}
inline int RequestsBundle::requests_size() const {
  return _internal_requests_size();
}
inline void RequestsBundle::clear_requests() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requests_.Clear();
}
inline std::string* RequestsBundle::add_requests()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_requests()->Add();
  // @@protoc_insertion_point(field_add_mutable:types.RequestsBundle.requests)
  return _s;
}
inline const std::string& RequestsBundle::requests(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.RequestsBundle.requests)
  return _internal_requests().Get(index);
}
inline std::string* RequestsBundle::mutable_requests(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.RequestsBundle.requests)
  return _internal_mutable_requests()->Mutable(index);
}
inline void RequestsBundle::set_requests(int index, const std::string& value) {
  _internal_mutable_requests()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.RequestsBundle.requests)
}
inline void RequestsBundle::set_requests(int index, std::string&& value) {
  _internal_mutable_requests()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.RequestsBundle.requests)
}
inline void RequestsBundle::set_requests(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_requests()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.RequestsBundle.requests)
}
inline void RequestsBundle::set_requests(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_requests()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.RequestsBundle.requests)
}
inline void RequestsBundle::set_requests(int index, absl::string_view value) {
  _internal_mutable_requests()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:types.RequestsBundle.requests)
}
inline void RequestsBundle::add_requests(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_requests()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.RequestsBundle.requests)
}
inline void RequestsBundle::add_requests(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_requests()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.RequestsBundle.requests)
}
inline void RequestsBundle::add_requests(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_requests()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.RequestsBundle.requests)
}
inline void RequestsBundle::add_requests(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_requests()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.RequestsBundle.requests)
}
inline void RequestsBundle::add_requests(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_requests()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:types.RequestsBundle.requests)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RequestsBundle::requests() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.RequestsBundle.requests)
  return _internal_requests();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RequestsBundle::mutable_requests() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.RequestsBundle.requests)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_requests();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RequestsBundle::_internal_requests() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requests_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RequestsBundle::_internal_mutable_requests() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.requests_;
}

// -------------------------------------------------------------------

// NodeInfoPorts

// uint32 discovery = 1;
inline void NodeInfoPorts::clear_discovery() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.discovery_ = 0u;
}
inline ::uint32_t NodeInfoPorts::discovery() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoPorts.discovery)
  return _internal_discovery();
}
inline void NodeInfoPorts::set_discovery(::uint32_t value) {
  _internal_set_discovery(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoPorts.discovery)
}
inline ::uint32_t NodeInfoPorts::_internal_discovery() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.discovery_;
}
inline void NodeInfoPorts::_internal_set_discovery(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.discovery_ = value;
}

// uint32 listener = 2;
inline void NodeInfoPorts::clear_listener() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listener_ = 0u;
}
inline ::uint32_t NodeInfoPorts::listener() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoPorts.listener)
  return _internal_listener();
}
inline void NodeInfoPorts::set_listener(::uint32_t value) {
  _internal_set_listener(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoPorts.listener)
}
inline ::uint32_t NodeInfoPorts::_internal_listener() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.listener_;
}
inline void NodeInfoPorts::_internal_set_listener(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listener_ = value;
}

// -------------------------------------------------------------------

// NodeInfoReply

// string id = 1;
inline void NodeInfoReply::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfoReply::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.id)
}
inline std::string* NodeInfoReply::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.id)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void NodeInfoReply::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NodeInfoReply::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NodeInfoReply::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.id)
  return _impl_.id_.Release();
}
inline void NodeInfoReply::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.id)
}

// string name = 2;
inline void NodeInfoReply::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfoReply::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.name)
}
inline std::string* NodeInfoReply::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.name)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NodeInfoReply::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeInfoReply::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeInfoReply::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.name)
  return _impl_.name_.Release();
}
inline void NodeInfoReply::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.name)
}

// string enode = 3;
inline void NodeInfoReply::clear_enode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enode_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::enode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.enode)
  return _internal_enode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfoReply::set_enode(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.enode)
}
inline std::string* NodeInfoReply::mutable_enode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enode();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.enode)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_enode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enode_.Get();
}
inline void NodeInfoReply::_internal_set_enode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enode_.Set(value, GetArena());
}
inline std::string* NodeInfoReply::_internal_mutable_enode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.enode_.Mutable( GetArena());
}
inline std::string* NodeInfoReply::release_enode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.enode)
  return _impl_.enode_.Release();
}
inline void NodeInfoReply::set_allocated_enode(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enode_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.enode_.IsDefault()) {
          _impl_.enode_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.enode)
}

// string enr = 4;
inline void NodeInfoReply::clear_enr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enr_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::enr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.enr)
  return _internal_enr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfoReply::set_enr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.enr)
}
inline std::string* NodeInfoReply::mutable_enr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enr();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.enr)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_enr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enr_.Get();
}
inline void NodeInfoReply::_internal_set_enr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enr_.Set(value, GetArena());
}
inline std::string* NodeInfoReply::_internal_mutable_enr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.enr_.Mutable( GetArena());
}
inline std::string* NodeInfoReply::release_enr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.enr)
  return _impl_.enr_.Release();
}
inline void NodeInfoReply::set_allocated_enr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.enr_.IsDefault()) {
          _impl_.enr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.enr)
}

// .types.NodeInfoPorts ports = 5;
inline bool NodeInfoReply::has_ports() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ports_ != nullptr);
  return value;
}
inline void NodeInfoReply::clear_ports() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ports_ != nullptr) _impl_.ports_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::types::NodeInfoPorts& NodeInfoReply::_internal_ports() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::types::NodeInfoPorts* p = _impl_.ports_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::NodeInfoPorts&>(::types::_NodeInfoPorts_default_instance_);
}
inline const ::types::NodeInfoPorts& NodeInfoReply::ports() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.ports)
  return _internal_ports();
}
inline void NodeInfoReply::unsafe_arena_set_allocated_ports(::types::NodeInfoPorts* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ports_);
  }
  _impl_.ports_ = reinterpret_cast<::types::NodeInfoPorts*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.NodeInfoReply.ports)
}
inline ::types::NodeInfoPorts* NodeInfoReply::release_ports() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::NodeInfoPorts* released = _impl_.ports_;
  _impl_.ports_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::types::NodeInfoPorts* NodeInfoReply::unsafe_arena_release_ports() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.ports)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::types::NodeInfoPorts* temp = _impl_.ports_;
  _impl_.ports_ = nullptr;
  return temp;
}
inline ::types::NodeInfoPorts* NodeInfoReply::_internal_mutable_ports() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ports_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::types::NodeInfoPorts>(GetArena());
    _impl_.ports_ = reinterpret_cast<::types::NodeInfoPorts*>(p);
  }
  return _impl_.ports_;
}
inline ::types::NodeInfoPorts* NodeInfoReply::mutable_ports() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::types::NodeInfoPorts* _msg = _internal_mutable_ports();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.ports)
  return _msg;
}
inline void NodeInfoReply::set_allocated_ports(::types::NodeInfoPorts* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.ports_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ports_ = reinterpret_cast<::types::NodeInfoPorts*>(value);
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.ports)
}

// string listener_addr = 6;
inline void NodeInfoReply::clear_listener_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listener_addr_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::listener_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.listener_addr)
  return _internal_listener_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfoReply::set_listener_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listener_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.listener_addr)
}
inline std::string* NodeInfoReply::mutable_listener_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_listener_addr();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.listener_addr)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_listener_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.listener_addr_.Get();
}
inline void NodeInfoReply::_internal_set_listener_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listener_addr_.Set(value, GetArena());
}
inline std::string* NodeInfoReply::_internal_mutable_listener_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.listener_addr_.Mutable( GetArena());
}
inline std::string* NodeInfoReply::release_listener_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.listener_addr)
  return _impl_.listener_addr_.Release();
}
inline void NodeInfoReply::set_allocated_listener_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listener_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.listener_addr_.IsDefault()) {
          _impl_.listener_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.listener_addr)
}

// bytes protocols = 7;
inline void NodeInfoReply::clear_protocols() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocols_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::protocols() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.protocols)
  return _internal_protocols();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfoReply::set_protocols(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocols_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.protocols)
}
inline std::string* NodeInfoReply::mutable_protocols() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protocols();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.protocols)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_protocols() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocols_.Get();
}
inline void NodeInfoReply::_internal_set_protocols(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocols_.Set(value, GetArena());
}
inline std::string* NodeInfoReply::_internal_mutable_protocols() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.protocols_.Mutable( GetArena());
}
inline std::string* NodeInfoReply::release_protocols() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.protocols)
  return _impl_.protocols_.Release();
}
inline void NodeInfoReply::set_allocated_protocols(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocols_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.protocols_.IsDefault()) {
          _impl_.protocols_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.protocols)
}

// -------------------------------------------------------------------

// PeerInfo

// string id = 1;
inline void PeerInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PeerInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.PeerInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerInfo::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.PeerInfo.id)
}
inline std::string* PeerInfo::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.id)
  return _s;
}
inline const std::string& PeerInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void PeerInfo::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* PeerInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* PeerInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.PeerInfo.id)
  return _impl_.id_.Release();
}
inline void PeerInfo::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.id)
}

// string name = 2;
inline void PeerInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PeerInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.PeerInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.PeerInfo.name)
}
inline std::string* PeerInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.name)
  return _s;
}
inline const std::string& PeerInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void PeerInfo::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PeerInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PeerInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.PeerInfo.name)
  return _impl_.name_.Release();
}
inline void PeerInfo::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.name)
}

// string enode = 3;
inline void PeerInfo::clear_enode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enode_.ClearToEmpty();
}
inline const std::string& PeerInfo::enode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.PeerInfo.enode)
  return _internal_enode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerInfo::set_enode(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.PeerInfo.enode)
}
inline std::string* PeerInfo::mutable_enode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enode();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.enode)
  return _s;
}
inline const std::string& PeerInfo::_internal_enode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enode_.Get();
}
inline void PeerInfo::_internal_set_enode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enode_.Set(value, GetArena());
}
inline std::string* PeerInfo::_internal_mutable_enode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.enode_.Mutable( GetArena());
}
inline std::string* PeerInfo::release_enode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.PeerInfo.enode)
  return _impl_.enode_.Release();
}
inline void PeerInfo::set_allocated_enode(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enode_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.enode_.IsDefault()) {
          _impl_.enode_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.enode)
}

// string enr = 4;
inline void PeerInfo::clear_enr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enr_.ClearToEmpty();
}
inline const std::string& PeerInfo::enr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.PeerInfo.enr)
  return _internal_enr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerInfo::set_enr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.PeerInfo.enr)
}
inline std::string* PeerInfo::mutable_enr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enr();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.enr)
  return _s;
}
inline const std::string& PeerInfo::_internal_enr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enr_.Get();
}
inline void PeerInfo::_internal_set_enr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enr_.Set(value, GetArena());
}
inline std::string* PeerInfo::_internal_mutable_enr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.enr_.Mutable( GetArena());
}
inline std::string* PeerInfo::release_enr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.PeerInfo.enr)
  return _impl_.enr_.Release();
}
inline void PeerInfo::set_allocated_enr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.enr_.IsDefault()) {
          _impl_.enr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.enr)
}

// repeated string caps = 5;
inline int PeerInfo::_internal_caps_size() const {
  return _internal_caps().size();
}
inline int PeerInfo::caps_size() const {
  return _internal_caps_size();
}
inline void PeerInfo::clear_caps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.caps_.Clear();
}
inline std::string* PeerInfo::add_caps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_caps()->Add();
  // @@protoc_insertion_point(field_add_mutable:types.PeerInfo.caps)
  return _s;
}
inline const std::string& PeerInfo::caps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.PeerInfo.caps)
  return _internal_caps().Get(index);
}
inline std::string* PeerInfo::mutable_caps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.caps)
  return _internal_mutable_caps()->Mutable(index);
}
inline void PeerInfo::set_caps(int index, const std::string& value) {
  _internal_mutable_caps()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.PeerInfo.caps)
}
inline void PeerInfo::set_caps(int index, std::string&& value) {
  _internal_mutable_caps()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.PeerInfo.caps)
}
inline void PeerInfo::set_caps(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_caps()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.PeerInfo.caps)
}
inline void PeerInfo::set_caps(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_caps()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.PeerInfo.caps)
}
inline void PeerInfo::set_caps(int index, absl::string_view value) {
  _internal_mutable_caps()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:types.PeerInfo.caps)
}
inline void PeerInfo::add_caps(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_caps()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.PeerInfo.caps)
}
inline void PeerInfo::add_caps(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_caps()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.PeerInfo.caps)
}
inline void PeerInfo::add_caps(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_caps()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.PeerInfo.caps)
}
inline void PeerInfo::add_caps(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_caps()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.PeerInfo.caps)
}
inline void PeerInfo::add_caps(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_caps()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:types.PeerInfo.caps)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PeerInfo::caps() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.PeerInfo.caps)
  return _internal_caps();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PeerInfo::mutable_caps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.PeerInfo.caps)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_caps();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PeerInfo::_internal_caps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.caps_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PeerInfo::_internal_mutable_caps() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.caps_;
}

// string conn_local_addr = 6;
inline void PeerInfo::clear_conn_local_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_local_addr_.ClearToEmpty();
}
inline const std::string& PeerInfo::conn_local_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.PeerInfo.conn_local_addr)
  return _internal_conn_local_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerInfo::set_conn_local_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_local_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.PeerInfo.conn_local_addr)
}
inline std::string* PeerInfo::mutable_conn_local_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_conn_local_addr();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.conn_local_addr)
  return _s;
}
inline const std::string& PeerInfo::_internal_conn_local_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conn_local_addr_.Get();
}
inline void PeerInfo::_internal_set_conn_local_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_local_addr_.Set(value, GetArena());
}
inline std::string* PeerInfo::_internal_mutable_conn_local_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.conn_local_addr_.Mutable( GetArena());
}
inline std::string* PeerInfo::release_conn_local_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.PeerInfo.conn_local_addr)
  return _impl_.conn_local_addr_.Release();
}
inline void PeerInfo::set_allocated_conn_local_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_local_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.conn_local_addr_.IsDefault()) {
          _impl_.conn_local_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.conn_local_addr)
}

// string conn_remote_addr = 7;
inline void PeerInfo::clear_conn_remote_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_remote_addr_.ClearToEmpty();
}
inline const std::string& PeerInfo::conn_remote_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.PeerInfo.conn_remote_addr)
  return _internal_conn_remote_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerInfo::set_conn_remote_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_remote_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:types.PeerInfo.conn_remote_addr)
}
inline std::string* PeerInfo::mutable_conn_remote_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_conn_remote_addr();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.conn_remote_addr)
  return _s;
}
inline const std::string& PeerInfo::_internal_conn_remote_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conn_remote_addr_.Get();
}
inline void PeerInfo::_internal_set_conn_remote_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_remote_addr_.Set(value, GetArena());
}
inline std::string* PeerInfo::_internal_mutable_conn_remote_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.conn_remote_addr_.Mutable( GetArena());
}
inline std::string* PeerInfo::release_conn_remote_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:types.PeerInfo.conn_remote_addr)
  return _impl_.conn_remote_addr_.Release();
}
inline void PeerInfo::set_allocated_conn_remote_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_remote_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.conn_remote_addr_.IsDefault()) {
          _impl_.conn_remote_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.conn_remote_addr)
}

// bool conn_is_inbound = 8;
inline void PeerInfo::clear_conn_is_inbound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_is_inbound_ = false;
}
inline bool PeerInfo::conn_is_inbound() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.conn_is_inbound)
  return _internal_conn_is_inbound();
}
inline void PeerInfo::set_conn_is_inbound(bool value) {
  _internal_set_conn_is_inbound(value);
  // @@protoc_insertion_point(field_set:types.PeerInfo.conn_is_inbound)
}
inline bool PeerInfo::_internal_conn_is_inbound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conn_is_inbound_;
}
inline void PeerInfo::_internal_set_conn_is_inbound(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_is_inbound_ = value;
}

// bool conn_is_trusted = 9;
inline void PeerInfo::clear_conn_is_trusted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_is_trusted_ = false;
}
inline bool PeerInfo::conn_is_trusted() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.conn_is_trusted)
  return _internal_conn_is_trusted();
}
inline void PeerInfo::set_conn_is_trusted(bool value) {
  _internal_set_conn_is_trusted(value);
  // @@protoc_insertion_point(field_set:types.PeerInfo.conn_is_trusted)
}
inline bool PeerInfo::_internal_conn_is_trusted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conn_is_trusted_;
}
inline void PeerInfo::_internal_set_conn_is_trusted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_is_trusted_ = value;
}

// bool conn_is_static = 10;
inline void PeerInfo::clear_conn_is_static() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_is_static_ = false;
}
inline bool PeerInfo::conn_is_static() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.conn_is_static)
  return _internal_conn_is_static();
}
inline void PeerInfo::set_conn_is_static(bool value) {
  _internal_set_conn_is_static(value);
  // @@protoc_insertion_point(field_set:types.PeerInfo.conn_is_static)
}
inline bool PeerInfo::_internal_conn_is_static() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conn_is_static_;
}
inline void PeerInfo::_internal_set_conn_is_static(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conn_is_static_ = value;
}

// -------------------------------------------------------------------

// ExecutionPayloadBodyV1

// repeated bytes transactions = 1;
inline int ExecutionPayloadBodyV1::_internal_transactions_size() const {
  return _internal_transactions().size();
}
inline int ExecutionPayloadBodyV1::transactions_size() const {
  return _internal_transactions_size();
}
inline void ExecutionPayloadBodyV1::clear_transactions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transactions_.Clear();
}
inline std::string* ExecutionPayloadBodyV1::add_transactions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_transactions()->Add();
  // @@protoc_insertion_point(field_add_mutable:types.ExecutionPayloadBodyV1.transactions)
  return _s;
}
inline const std::string& ExecutionPayloadBodyV1::transactions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayloadBodyV1.transactions)
  return _internal_transactions().Get(index);
}
inline std::string* ExecutionPayloadBodyV1::mutable_transactions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayloadBodyV1.transactions)
  return _internal_mutable_transactions()->Mutable(index);
}
inline void ExecutionPayloadBodyV1::set_transactions(int index, const std::string& value) {
  _internal_mutable_transactions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::set_transactions(int index, std::string&& value) {
  _internal_mutable_transactions()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::set_transactions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transactions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::set_transactions(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_transactions()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::set_transactions(int index, absl::string_view value) {
  _internal_mutable_transactions()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::add_transactions(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::add_transactions(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::add_transactions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::add_transactions(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.ExecutionPayloadBodyV1.transactions)
}
inline void ExecutionPayloadBodyV1::add_transactions(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transactions()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:types.ExecutionPayloadBodyV1.transactions)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExecutionPayloadBodyV1::transactions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.ExecutionPayloadBodyV1.transactions)
  return _internal_transactions();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExecutionPayloadBodyV1::mutable_transactions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.ExecutionPayloadBodyV1.transactions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_transactions();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExecutionPayloadBodyV1::_internal_transactions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transactions_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExecutionPayloadBodyV1::_internal_mutable_transactions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.transactions_;
}

// repeated .types.Withdrawal withdrawals = 2;
inline int ExecutionPayloadBodyV1::_internal_withdrawals_size() const {
  return _internal_withdrawals().size();
}
inline int ExecutionPayloadBodyV1::withdrawals_size() const {
  return _internal_withdrawals_size();
}
inline void ExecutionPayloadBodyV1::clear_withdrawals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.withdrawals_.Clear();
}
inline ::types::Withdrawal* ExecutionPayloadBodyV1::mutable_withdrawals(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayloadBodyV1.withdrawals)
  return _internal_mutable_withdrawals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::types::Withdrawal>* ExecutionPayloadBodyV1::mutable_withdrawals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:types.ExecutionPayloadBodyV1.withdrawals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_withdrawals();
}
inline const ::types::Withdrawal& ExecutionPayloadBodyV1::withdrawals(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:types.ExecutionPayloadBodyV1.withdrawals)
  return _internal_withdrawals().Get(index);
}
inline ::types::Withdrawal* ExecutionPayloadBodyV1::add_withdrawals() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::types::Withdrawal* _add = _internal_mutable_withdrawals()->Add();
  // @@protoc_insertion_point(field_add:types.ExecutionPayloadBodyV1.withdrawals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>& ExecutionPayloadBodyV1::withdrawals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:types.ExecutionPayloadBodyV1.withdrawals)
  return _internal_withdrawals();
}
inline const ::google::protobuf::RepeatedPtrField<::types::Withdrawal>&
ExecutionPayloadBodyV1::_internal_withdrawals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.withdrawals_;
}
inline ::google::protobuf::RepeatedPtrField<::types::Withdrawal>*
ExecutionPayloadBodyV1::_internal_mutable_withdrawals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.withdrawals_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace types


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto_2epb_2eh
