// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remote/ethbackend.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_remote_2fethbackend_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_remote_2fethbackend_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_remote_2fethbackend_2eproto;
namespace remote {
class ClientVersionReply;
struct ClientVersionReplyDefaultTypeInternal;
extern ClientVersionReplyDefaultTypeInternal _ClientVersionReply_default_instance_;
class ClientVersionRequest;
struct ClientVersionRequestDefaultTypeInternal;
extern ClientVersionRequestDefaultTypeInternal _ClientVersionRequest_default_instance_;
class EtherbaseReply;
struct EtherbaseReplyDefaultTypeInternal;
extern EtherbaseReplyDefaultTypeInternal _EtherbaseReply_default_instance_;
class EtherbaseRequest;
struct EtherbaseRequestDefaultTypeInternal;
extern EtherbaseRequestDefaultTypeInternal _EtherbaseRequest_default_instance_;
class NetPeerCountReply;
struct NetPeerCountReplyDefaultTypeInternal;
extern NetPeerCountReplyDefaultTypeInternal _NetPeerCountReply_default_instance_;
class NetPeerCountRequest;
struct NetPeerCountRequestDefaultTypeInternal;
extern NetPeerCountRequestDefaultTypeInternal _NetPeerCountRequest_default_instance_;
class NetVersionReply;
struct NetVersionReplyDefaultTypeInternal;
extern NetVersionReplyDefaultTypeInternal _NetVersionReply_default_instance_;
class NetVersionRequest;
struct NetVersionRequestDefaultTypeInternal;
extern NetVersionRequestDefaultTypeInternal _NetVersionRequest_default_instance_;
class NodesInfoReply;
struct NodesInfoReplyDefaultTypeInternal;
extern NodesInfoReplyDefaultTypeInternal _NodesInfoReply_default_instance_;
class NodesInfoRequest;
struct NodesInfoRequestDefaultTypeInternal;
extern NodesInfoRequestDefaultTypeInternal _NodesInfoRequest_default_instance_;
class ProtocolVersionReply;
struct ProtocolVersionReplyDefaultTypeInternal;
extern ProtocolVersionReplyDefaultTypeInternal _ProtocolVersionReply_default_instance_;
class ProtocolVersionRequest;
struct ProtocolVersionRequestDefaultTypeInternal;
extern ProtocolVersionRequestDefaultTypeInternal _ProtocolVersionRequest_default_instance_;
class SubscribeReply;
struct SubscribeReplyDefaultTypeInternal;
extern SubscribeReplyDefaultTypeInternal _SubscribeReply_default_instance_;
class SubscribeRequest;
struct SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
}  // namespace remote
PROTOBUF_NAMESPACE_OPEN
template<> ::remote::ClientVersionReply* Arena::CreateMaybeMessage<::remote::ClientVersionReply>(Arena*);
template<> ::remote::ClientVersionRequest* Arena::CreateMaybeMessage<::remote::ClientVersionRequest>(Arena*);
template<> ::remote::EtherbaseReply* Arena::CreateMaybeMessage<::remote::EtherbaseReply>(Arena*);
template<> ::remote::EtherbaseRequest* Arena::CreateMaybeMessage<::remote::EtherbaseRequest>(Arena*);
template<> ::remote::NetPeerCountReply* Arena::CreateMaybeMessage<::remote::NetPeerCountReply>(Arena*);
template<> ::remote::NetPeerCountRequest* Arena::CreateMaybeMessage<::remote::NetPeerCountRequest>(Arena*);
template<> ::remote::NetVersionReply* Arena::CreateMaybeMessage<::remote::NetVersionReply>(Arena*);
template<> ::remote::NetVersionRequest* Arena::CreateMaybeMessage<::remote::NetVersionRequest>(Arena*);
template<> ::remote::NodesInfoReply* Arena::CreateMaybeMessage<::remote::NodesInfoReply>(Arena*);
template<> ::remote::NodesInfoRequest* Arena::CreateMaybeMessage<::remote::NodesInfoRequest>(Arena*);
template<> ::remote::ProtocolVersionReply* Arena::CreateMaybeMessage<::remote::ProtocolVersionReply>(Arena*);
template<> ::remote::ProtocolVersionRequest* Arena::CreateMaybeMessage<::remote::ProtocolVersionRequest>(Arena*);
template<> ::remote::SubscribeReply* Arena::CreateMaybeMessage<::remote::SubscribeReply>(Arena*);
template<> ::remote::SubscribeRequest* Arena::CreateMaybeMessage<::remote::SubscribeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace remote {

enum Event : int {
  HEADER = 0,
  PENDING_LOGS = 1,
  PENDING_BLOCK = 2,
  Event_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Event_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Event_IsValid(int value);
constexpr Event Event_MIN = HEADER;
constexpr Event Event_MAX = PENDING_BLOCK;
constexpr int Event_ARRAYSIZE = Event_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Event_descriptor();
template<typename T>
inline const std::string& Event_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Event>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Event_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Event_descriptor(), enum_t_value);
}
inline bool Event_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Event* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Event>(
    Event_descriptor(), name, value);
}
// ===================================================================

class EtherbaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.EtherbaseRequest) */ {
 public:
  inline EtherbaseRequest() : EtherbaseRequest(nullptr) {}
  explicit constexpr EtherbaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EtherbaseRequest(const EtherbaseRequest& from);
  EtherbaseRequest(EtherbaseRequest&& from) noexcept
    : EtherbaseRequest() {
    *this = ::std::move(from);
  }

  inline EtherbaseRequest& operator=(const EtherbaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EtherbaseRequest& operator=(EtherbaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EtherbaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EtherbaseRequest* internal_default_instance() {
    return reinterpret_cast<const EtherbaseRequest*>(
               &_EtherbaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EtherbaseRequest& a, EtherbaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EtherbaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EtherbaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EtherbaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EtherbaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EtherbaseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EtherbaseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EtherbaseRequest";
  }
  protected:
  explicit EtherbaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.EtherbaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EtherbaseReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EtherbaseReply) */ {
 public:
  inline EtherbaseReply() : EtherbaseReply(nullptr) {}
  ~EtherbaseReply() override;
  explicit constexpr EtherbaseReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EtherbaseReply(const EtherbaseReply& from);
  EtherbaseReply(EtherbaseReply&& from) noexcept
    : EtherbaseReply() {
    *this = ::std::move(from);
  }

  inline EtherbaseReply& operator=(const EtherbaseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline EtherbaseReply& operator=(EtherbaseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EtherbaseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const EtherbaseReply* internal_default_instance() {
    return reinterpret_cast<const EtherbaseReply*>(
               &_EtherbaseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EtherbaseReply& a, EtherbaseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(EtherbaseReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EtherbaseReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EtherbaseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EtherbaseReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EtherbaseReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EtherbaseReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EtherbaseReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EtherbaseReply";
  }
  protected:
  explicit EtherbaseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // .types.H160 address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::types::H160& address() const;
  PROTOBUF_NODISCARD ::types::H160* release_address();
  ::types::H160* mutable_address();
  void set_allocated_address(::types::H160* address);
  private:
  const ::types::H160& _internal_address() const;
  ::types::H160* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::types::H160* address);
  ::types::H160* unsafe_arena_release_address();

  // @@protoc_insertion_point(class_scope:remote.EtherbaseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H160* address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetVersionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.NetVersionRequest) */ {
 public:
  inline NetVersionRequest() : NetVersionRequest(nullptr) {}
  explicit constexpr NetVersionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetVersionRequest(const NetVersionRequest& from);
  NetVersionRequest(NetVersionRequest&& from) noexcept
    : NetVersionRequest() {
    *this = ::std::move(from);
  }

  inline NetVersionRequest& operator=(const NetVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetVersionRequest& operator=(NetVersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetVersionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetVersionRequest* internal_default_instance() {
    return reinterpret_cast<const NetVersionRequest*>(
               &_NetVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NetVersionRequest& a, NetVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NetVersionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetVersionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NetVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NetVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetVersionRequest";
  }
  protected:
  explicit NetVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.NetVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetVersionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NetVersionReply) */ {
 public:
  inline NetVersionReply() : NetVersionReply(nullptr) {}
  ~NetVersionReply() override;
  explicit constexpr NetVersionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetVersionReply(const NetVersionReply& from);
  NetVersionReply(NetVersionReply&& from) noexcept
    : NetVersionReply() {
    *this = ::std::move(from);
  }

  inline NetVersionReply& operator=(const NetVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetVersionReply& operator=(NetVersionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetVersionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetVersionReply* internal_default_instance() {
    return reinterpret_cast<const NetVersionReply*>(
               &_NetVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NetVersionReply& a, NetVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NetVersionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetVersionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetVersionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetVersionReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetVersionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetVersionReply";
  }
  protected:
  explicit NetVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.NetVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetPeerCountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.NetPeerCountRequest) */ {
 public:
  inline NetPeerCountRequest() : NetPeerCountRequest(nullptr) {}
  explicit constexpr NetPeerCountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetPeerCountRequest(const NetPeerCountRequest& from);
  NetPeerCountRequest(NetPeerCountRequest&& from) noexcept
    : NetPeerCountRequest() {
    *this = ::std::move(from);
  }

  inline NetPeerCountRequest& operator=(const NetPeerCountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetPeerCountRequest& operator=(NetPeerCountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetPeerCountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetPeerCountRequest* internal_default_instance() {
    return reinterpret_cast<const NetPeerCountRequest*>(
               &_NetPeerCountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NetPeerCountRequest& a, NetPeerCountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NetPeerCountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetPeerCountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetPeerCountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetPeerCountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NetPeerCountRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NetPeerCountRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetPeerCountRequest";
  }
  protected:
  explicit NetPeerCountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.NetPeerCountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetPeerCountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NetPeerCountReply) */ {
 public:
  inline NetPeerCountReply() : NetPeerCountReply(nullptr) {}
  ~NetPeerCountReply() override;
  explicit constexpr NetPeerCountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetPeerCountReply(const NetPeerCountReply& from);
  NetPeerCountReply(NetPeerCountReply&& from) noexcept
    : NetPeerCountReply() {
    *this = ::std::move(from);
  }

  inline NetPeerCountReply& operator=(const NetPeerCountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetPeerCountReply& operator=(NetPeerCountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetPeerCountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetPeerCountReply* internal_default_instance() {
    return reinterpret_cast<const NetPeerCountReply*>(
               &_NetPeerCountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NetPeerCountReply& a, NetPeerCountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NetPeerCountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetPeerCountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetPeerCountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetPeerCountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetPeerCountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetPeerCountReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetPeerCountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetPeerCountReply";
  }
  protected:
  explicit NetPeerCountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // uint64 count = 1;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.NetPeerCountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ProtocolVersionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.ProtocolVersionRequest) */ {
 public:
  inline ProtocolVersionRequest() : ProtocolVersionRequest(nullptr) {}
  explicit constexpr ProtocolVersionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolVersionRequest(const ProtocolVersionRequest& from);
  ProtocolVersionRequest(ProtocolVersionRequest&& from) noexcept
    : ProtocolVersionRequest() {
    *this = ::std::move(from);
  }

  inline ProtocolVersionRequest& operator=(const ProtocolVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolVersionRequest& operator=(ProtocolVersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolVersionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolVersionRequest* internal_default_instance() {
    return reinterpret_cast<const ProtocolVersionRequest*>(
               &_ProtocolVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ProtocolVersionRequest& a, ProtocolVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolVersionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtocolVersionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ProtocolVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ProtocolVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ProtocolVersionRequest";
  }
  protected:
  explicit ProtocolVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.ProtocolVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ProtocolVersionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.ProtocolVersionReply) */ {
 public:
  inline ProtocolVersionReply() : ProtocolVersionReply(nullptr) {}
  ~ProtocolVersionReply() override;
  explicit constexpr ProtocolVersionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolVersionReply(const ProtocolVersionReply& from);
  ProtocolVersionReply(ProtocolVersionReply&& from) noexcept
    : ProtocolVersionReply() {
    *this = ::std::move(from);
  }

  inline ProtocolVersionReply& operator=(const ProtocolVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolVersionReply& operator=(ProtocolVersionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolVersionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolVersionReply* internal_default_instance() {
    return reinterpret_cast<const ProtocolVersionReply*>(
               &_ProtocolVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProtocolVersionReply& a, ProtocolVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolVersionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtocolVersionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtocolVersionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProtocolVersionReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolVersionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ProtocolVersionReply";
  }
  protected:
  explicit ProtocolVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.ProtocolVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientVersionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.ClientVersionRequest) */ {
 public:
  inline ClientVersionRequest() : ClientVersionRequest(nullptr) {}
  explicit constexpr ClientVersionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientVersionRequest(const ClientVersionRequest& from);
  ClientVersionRequest(ClientVersionRequest&& from) noexcept
    : ClientVersionRequest() {
    *this = ::std::move(from);
  }

  inline ClientVersionRequest& operator=(const ClientVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientVersionRequest& operator=(ClientVersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientVersionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientVersionRequest* internal_default_instance() {
    return reinterpret_cast<const ClientVersionRequest*>(
               &_ClientVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClientVersionRequest& a, ClientVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientVersionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientVersionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClientVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClientVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ClientVersionRequest";
  }
  protected:
  explicit ClientVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.ClientVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientVersionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.ClientVersionReply) */ {
 public:
  inline ClientVersionReply() : ClientVersionReply(nullptr) {}
  ~ClientVersionReply() override;
  explicit constexpr ClientVersionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientVersionReply(const ClientVersionReply& from);
  ClientVersionReply(ClientVersionReply&& from) noexcept
    : ClientVersionReply() {
    *this = ::std::move(from);
  }

  inline ClientVersionReply& operator=(const ClientVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientVersionReply& operator=(ClientVersionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientVersionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientVersionReply* internal_default_instance() {
    return reinterpret_cast<const ClientVersionReply*>(
               &_ClientVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClientVersionReply& a, ClientVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientVersionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientVersionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientVersionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientVersionReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientVersionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ClientVersionReply";
  }
  protected:
  explicit ClientVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 1,
  };
  // string nodeName = 1;
  void clear_nodename();
  const std::string& nodename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodename();
  PROTOBUF_NODISCARD std::string* release_nodename();
  void set_allocated_nodename(std::string* nodename);
  private:
  const std::string& _internal_nodename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodename(const std::string& value);
  std::string* _internal_mutable_nodename();
  public:

  // @@protoc_insertion_point(class_scope:remote.ClientVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {}
  ~SubscribeRequest() override;
  explicit constexpr SubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .remote.Event type = 1;
  void clear_type();
  ::remote::Event type() const;
  void set_type(::remote::Event value);
  private:
  ::remote::Event _internal_type() const;
  void _internal_set_type(::remote::Event value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubscribeReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubscribeReply) */ {
 public:
  inline SubscribeReply() : SubscribeReply(nullptr) {}
  ~SubscribeReply() override;
  explicit constexpr SubscribeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeReply(const SubscribeReply& from);
  SubscribeReply(SubscribeReply&& from) noexcept
    : SubscribeReply() {
    *this = ::std::move(from);
  }

  inline SubscribeReply& operator=(const SubscribeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeReply& operator=(SubscribeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeReply* internal_default_instance() {
    return reinterpret_cast<const SubscribeReply*>(
               &_SubscribeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SubscribeReply& a, SubscribeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubscribeReply";
  }
  protected:
  explicit SubscribeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .remote.Event type = 1;
  void clear_type();
  ::remote::Event type() const;
  void set_type(::remote::Event value);
  private:
  ::remote::Event _internal_type() const;
  void _internal_set_type(::remote::Event value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubscribeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NodesInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NodesInfoRequest) */ {
 public:
  inline NodesInfoRequest() : NodesInfoRequest(nullptr) {}
  ~NodesInfoRequest() override;
  explicit constexpr NodesInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodesInfoRequest(const NodesInfoRequest& from);
  NodesInfoRequest(NodesInfoRequest&& from) noexcept
    : NodesInfoRequest() {
    *this = ::std::move(from);
  }

  inline NodesInfoRequest& operator=(const NodesInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodesInfoRequest& operator=(NodesInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodesInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodesInfoRequest* internal_default_instance() {
    return reinterpret_cast<const NodesInfoRequest*>(
               &_NodesInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NodesInfoRequest& a, NodesInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodesInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodesInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodesInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodesInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodesInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodesInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodesInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NodesInfoRequest";
  }
  protected:
  explicit NodesInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitFieldNumber = 1,
  };
  // uint32 limit = 1;
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.NodesInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NodesInfoReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NodesInfoReply) */ {
 public:
  inline NodesInfoReply() : NodesInfoReply(nullptr) {}
  ~NodesInfoReply() override;
  explicit constexpr NodesInfoReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodesInfoReply(const NodesInfoReply& from);
  NodesInfoReply(NodesInfoReply&& from) noexcept
    : NodesInfoReply() {
    *this = ::std::move(from);
  }

  inline NodesInfoReply& operator=(const NodesInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodesInfoReply& operator=(NodesInfoReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodesInfoReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodesInfoReply* internal_default_instance() {
    return reinterpret_cast<const NodesInfoReply*>(
               &_NodesInfoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NodesInfoReply& a, NodesInfoReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NodesInfoReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodesInfoReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodesInfoReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodesInfoReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodesInfoReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodesInfoReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodesInfoReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NodesInfoReply";
  }
  protected:
  explicit NodesInfoReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesInfoFieldNumber = 1,
  };
  // repeated .types.NodeInfoReply nodesInfo = 1;
  int nodesinfo_size() const;
  private:
  int _internal_nodesinfo_size() const;
  public:
  void clear_nodesinfo();
  ::types::NodeInfoReply* mutable_nodesinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply >*
      mutable_nodesinfo();
  private:
  const ::types::NodeInfoReply& _internal_nodesinfo(int index) const;
  ::types::NodeInfoReply* _internal_add_nodesinfo();
  public:
  const ::types::NodeInfoReply& nodesinfo(int index) const;
  ::types::NodeInfoReply* add_nodesinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply >&
      nodesinfo() const;

  // @@protoc_insertion_point(class_scope:remote.NodesInfoReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply > nodesinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EtherbaseRequest

// -------------------------------------------------------------------

// EtherbaseReply

// .types.H160 address = 1;
inline bool EtherbaseReply::_internal_has_address() const {
  return this != internal_default_instance() && address_ != nullptr;
}
inline bool EtherbaseReply::has_address() const {
  return _internal_has_address();
}
inline const ::types::H160& EtherbaseReply::_internal_address() const {
  const ::types::H160* p = address_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& EtherbaseReply::address() const {
  // @@protoc_insertion_point(field_get:remote.EtherbaseReply.address)
  return _internal_address();
}
inline void EtherbaseReply::unsafe_arena_set_allocated_address(
    ::types::H160* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address_);
  }
  address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EtherbaseReply.address)
}
inline ::types::H160* EtherbaseReply::release_address() {
  
  ::types::H160* temp = address_;
  address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* EtherbaseReply::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:remote.EtherbaseReply.address)
  
  ::types::H160* temp = address_;
  address_ = nullptr;
  return temp;
}
inline ::types::H160* EtherbaseReply::_internal_mutable_address() {
  
  if (address_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    address_ = p;
  }
  return address_;
}
inline ::types::H160* EtherbaseReply::mutable_address() {
  ::types::H160* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:remote.EtherbaseReply.address)
  return _msg;
}
inline void EtherbaseReply::set_allocated_address(::types::H160* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(address_);
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address));
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:remote.EtherbaseReply.address)
}

// -------------------------------------------------------------------

// NetVersionRequest

// -------------------------------------------------------------------

// NetVersionReply

// uint64 id = 1;
inline void NetVersionReply::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t NetVersionReply::_internal_id() const {
  return id_;
}
inline uint64_t NetVersionReply::id() const {
  // @@protoc_insertion_point(field_get:remote.NetVersionReply.id)
  return _internal_id();
}
inline void NetVersionReply::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void NetVersionReply::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.NetVersionReply.id)
}

// -------------------------------------------------------------------

// NetPeerCountRequest

// -------------------------------------------------------------------

// NetPeerCountReply

// uint64 count = 1;
inline void NetPeerCountReply::clear_count() {
  count_ = uint64_t{0u};
}
inline uint64_t NetPeerCountReply::_internal_count() const {
  return count_;
}
inline uint64_t NetPeerCountReply::count() const {
  // @@protoc_insertion_point(field_get:remote.NetPeerCountReply.count)
  return _internal_count();
}
inline void NetPeerCountReply::_internal_set_count(uint64_t value) {
  
  count_ = value;
}
inline void NetPeerCountReply::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:remote.NetPeerCountReply.count)
}

// -------------------------------------------------------------------

// ProtocolVersionRequest

// -------------------------------------------------------------------

// ProtocolVersionReply

// uint64 id = 1;
inline void ProtocolVersionReply::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t ProtocolVersionReply::_internal_id() const {
  return id_;
}
inline uint64_t ProtocolVersionReply::id() const {
  // @@protoc_insertion_point(field_get:remote.ProtocolVersionReply.id)
  return _internal_id();
}
inline void ProtocolVersionReply::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void ProtocolVersionReply::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.ProtocolVersionReply.id)
}

// -------------------------------------------------------------------

// ClientVersionRequest

// -------------------------------------------------------------------

// ClientVersionReply

// string nodeName = 1;
inline void ClientVersionReply::clear_nodename() {
  nodename_.ClearToEmpty();
}
inline const std::string& ClientVersionReply::nodename() const {
  // @@protoc_insertion_point(field_get:remote.ClientVersionReply.nodeName)
  return _internal_nodename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientVersionReply::set_nodename(ArgT0&& arg0, ArgT... args) {
 
 nodename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.ClientVersionReply.nodeName)
}
inline std::string* ClientVersionReply::mutable_nodename() {
  std::string* _s = _internal_mutable_nodename();
  // @@protoc_insertion_point(field_mutable:remote.ClientVersionReply.nodeName)
  return _s;
}
inline const std::string& ClientVersionReply::_internal_nodename() const {
  return nodename_.Get();
}
inline void ClientVersionReply::_internal_set_nodename(const std::string& value) {
  
  nodename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientVersionReply::_internal_mutable_nodename() {
  
  return nodename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientVersionReply::release_nodename() {
  // @@protoc_insertion_point(field_release:remote.ClientVersionReply.nodeName)
  return nodename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientVersionReply::set_allocated_nodename(std::string* nodename) {
  if (nodename != nullptr) {
    
  } else {
    
  }
  nodename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nodename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.ClientVersionReply.nodeName)
}

// -------------------------------------------------------------------

// SubscribeRequest

// .remote.Event type = 1;
inline void SubscribeRequest::clear_type() {
  type_ = 0;
}
inline ::remote::Event SubscribeRequest::_internal_type() const {
  return static_cast< ::remote::Event >(type_);
}
inline ::remote::Event SubscribeRequest::type() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeRequest.type)
  return _internal_type();
}
inline void SubscribeRequest::_internal_set_type(::remote::Event value) {
  
  type_ = value;
}
inline void SubscribeRequest::set_type(::remote::Event value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeRequest.type)
}

// -------------------------------------------------------------------

// SubscribeReply

// .remote.Event type = 1;
inline void SubscribeReply::clear_type() {
  type_ = 0;
}
inline ::remote::Event SubscribeReply::_internal_type() const {
  return static_cast< ::remote::Event >(type_);
}
inline ::remote::Event SubscribeReply::type() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeReply.type)
  return _internal_type();
}
inline void SubscribeReply::_internal_set_type(::remote::Event value) {
  
  type_ = value;
}
inline void SubscribeReply::set_type(::remote::Event value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeReply.type)
}

// bytes data = 2;
inline void SubscribeReply::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& SubscribeReply::data() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeReply.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeReply::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.SubscribeReply.data)
}
inline std::string* SubscribeReply::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:remote.SubscribeReply.data)
  return _s;
}
inline const std::string& SubscribeReply::_internal_data() const {
  return data_.Get();
}
inline void SubscribeReply::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeReply::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeReply::release_data() {
  // @@protoc_insertion_point(field_release:remote.SubscribeReply.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeReply::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.SubscribeReply.data)
}

// -------------------------------------------------------------------

// NodesInfoRequest

// uint32 limit = 1;
inline void NodesInfoRequest::clear_limit() {
  limit_ = 0u;
}
inline uint32_t NodesInfoRequest::_internal_limit() const {
  return limit_;
}
inline uint32_t NodesInfoRequest::limit() const {
  // @@protoc_insertion_point(field_get:remote.NodesInfoRequest.limit)
  return _internal_limit();
}
inline void NodesInfoRequest::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void NodesInfoRequest::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:remote.NodesInfoRequest.limit)
}

// -------------------------------------------------------------------

// NodesInfoReply

// repeated .types.NodeInfoReply nodesInfo = 1;
inline int NodesInfoReply::_internal_nodesinfo_size() const {
  return nodesinfo_.size();
}
inline int NodesInfoReply::nodesinfo_size() const {
  return _internal_nodesinfo_size();
}
inline ::types::NodeInfoReply* NodesInfoReply::mutable_nodesinfo(int index) {
  // @@protoc_insertion_point(field_mutable:remote.NodesInfoReply.nodesInfo)
  return nodesinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply >*
NodesInfoReply::mutable_nodesinfo() {
  // @@protoc_insertion_point(field_mutable_list:remote.NodesInfoReply.nodesInfo)
  return &nodesinfo_;
}
inline const ::types::NodeInfoReply& NodesInfoReply::_internal_nodesinfo(int index) const {
  return nodesinfo_.Get(index);
}
inline const ::types::NodeInfoReply& NodesInfoReply::nodesinfo(int index) const {
  // @@protoc_insertion_point(field_get:remote.NodesInfoReply.nodesInfo)
  return _internal_nodesinfo(index);
}
inline ::types::NodeInfoReply* NodesInfoReply::_internal_add_nodesinfo() {
  return nodesinfo_.Add();
}
inline ::types::NodeInfoReply* NodesInfoReply::add_nodesinfo() {
  ::types::NodeInfoReply* _add = _internal_add_nodesinfo();
  // @@protoc_insertion_point(field_add:remote.NodesInfoReply.nodesInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::NodeInfoReply >&
NodesInfoReply::nodesinfo() const {
  // @@protoc_insertion_point(field_list:remote.NodesInfoReply.nodesInfo)
  return nodesinfo_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace remote

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::remote::Event> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Event>() {
  return ::remote::Event_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto
