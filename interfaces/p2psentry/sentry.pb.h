// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: p2psentry/sentry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_p2psentry_2fsentry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_p2psentry_2fsentry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_p2psentry_2fsentry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_p2psentry_2fsentry_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_p2psentry_2fsentry_2eproto;
namespace sentry {
class Forks;
class ForksDefaultTypeInternal;
extern ForksDefaultTypeInternal _Forks_default_instance_;
class HandShakeReply;
class HandShakeReplyDefaultTypeInternal;
extern HandShakeReplyDefaultTypeInternal _HandShakeReply_default_instance_;
class InboundMessage;
class InboundMessageDefaultTypeInternal;
extern InboundMessageDefaultTypeInternal _InboundMessage_default_instance_;
class MessagesRequest;
class MessagesRequestDefaultTypeInternal;
extern MessagesRequestDefaultTypeInternal _MessagesRequest_default_instance_;
class OutboundMessageData;
class OutboundMessageDataDefaultTypeInternal;
extern OutboundMessageDataDefaultTypeInternal _OutboundMessageData_default_instance_;
class PeerCountReply;
class PeerCountReplyDefaultTypeInternal;
extern PeerCountReplyDefaultTypeInternal _PeerCountReply_default_instance_;
class PeerCountRequest;
class PeerCountRequestDefaultTypeInternal;
extern PeerCountRequestDefaultTypeInternal _PeerCountRequest_default_instance_;
class PeerMinBlockRequest;
class PeerMinBlockRequestDefaultTypeInternal;
extern PeerMinBlockRequestDefaultTypeInternal _PeerMinBlockRequest_default_instance_;
class PeersReply;
class PeersReplyDefaultTypeInternal;
extern PeersReplyDefaultTypeInternal _PeersReply_default_instance_;
class PeersRequest;
class PeersRequestDefaultTypeInternal;
extern PeersRequestDefaultTypeInternal _PeersRequest_default_instance_;
class PenalizePeerRequest;
class PenalizePeerRequestDefaultTypeInternal;
extern PenalizePeerRequestDefaultTypeInternal _PenalizePeerRequest_default_instance_;
class SendMessageByIdRequest;
class SendMessageByIdRequestDefaultTypeInternal;
extern SendMessageByIdRequestDefaultTypeInternal _SendMessageByIdRequest_default_instance_;
class SendMessageByMinBlockRequest;
class SendMessageByMinBlockRequestDefaultTypeInternal;
extern SendMessageByMinBlockRequestDefaultTypeInternal _SendMessageByMinBlockRequest_default_instance_;
class SendMessageToRandomPeersRequest;
class SendMessageToRandomPeersRequestDefaultTypeInternal;
extern SendMessageToRandomPeersRequestDefaultTypeInternal _SendMessageToRandomPeersRequest_default_instance_;
class SentPeers;
class SentPeersDefaultTypeInternal;
extern SentPeersDefaultTypeInternal _SentPeers_default_instance_;
class SetStatusReply;
class SetStatusReplyDefaultTypeInternal;
extern SetStatusReplyDefaultTypeInternal _SetStatusReply_default_instance_;
class StatusData;
class StatusDataDefaultTypeInternal;
extern StatusDataDefaultTypeInternal _StatusData_default_instance_;
}  // namespace sentry
PROTOBUF_NAMESPACE_OPEN
template<> ::sentry::Forks* Arena::CreateMaybeMessage<::sentry::Forks>(Arena*);
template<> ::sentry::HandShakeReply* Arena::CreateMaybeMessage<::sentry::HandShakeReply>(Arena*);
template<> ::sentry::InboundMessage* Arena::CreateMaybeMessage<::sentry::InboundMessage>(Arena*);
template<> ::sentry::MessagesRequest* Arena::CreateMaybeMessage<::sentry::MessagesRequest>(Arena*);
template<> ::sentry::OutboundMessageData* Arena::CreateMaybeMessage<::sentry::OutboundMessageData>(Arena*);
template<> ::sentry::PeerCountReply* Arena::CreateMaybeMessage<::sentry::PeerCountReply>(Arena*);
template<> ::sentry::PeerCountRequest* Arena::CreateMaybeMessage<::sentry::PeerCountRequest>(Arena*);
template<> ::sentry::PeerMinBlockRequest* Arena::CreateMaybeMessage<::sentry::PeerMinBlockRequest>(Arena*);
template<> ::sentry::PeersReply* Arena::CreateMaybeMessage<::sentry::PeersReply>(Arena*);
template<> ::sentry::PeersRequest* Arena::CreateMaybeMessage<::sentry::PeersRequest>(Arena*);
template<> ::sentry::PenalizePeerRequest* Arena::CreateMaybeMessage<::sentry::PenalizePeerRequest>(Arena*);
template<> ::sentry::SendMessageByIdRequest* Arena::CreateMaybeMessage<::sentry::SendMessageByIdRequest>(Arena*);
template<> ::sentry::SendMessageByMinBlockRequest* Arena::CreateMaybeMessage<::sentry::SendMessageByMinBlockRequest>(Arena*);
template<> ::sentry::SendMessageToRandomPeersRequest* Arena::CreateMaybeMessage<::sentry::SendMessageToRandomPeersRequest>(Arena*);
template<> ::sentry::SentPeers* Arena::CreateMaybeMessage<::sentry::SentPeers>(Arena*);
template<> ::sentry::SetStatusReply* Arena::CreateMaybeMessage<::sentry::SetStatusReply>(Arena*);
template<> ::sentry::StatusData* Arena::CreateMaybeMessage<::sentry::StatusData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sentry {

enum PeersReply_PeerEvent : int {
  PeersReply_PeerEvent_Connect = 0,
  PeersReply_PeerEvent_Disconnect = 1,
  PeersReply_PeerEvent_PeersReply_PeerEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PeersReply_PeerEvent_PeersReply_PeerEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PeersReply_PeerEvent_IsValid(int value);
constexpr PeersReply_PeerEvent PeersReply_PeerEvent_PeerEvent_MIN = PeersReply_PeerEvent_Connect;
constexpr PeersReply_PeerEvent PeersReply_PeerEvent_PeerEvent_MAX = PeersReply_PeerEvent_Disconnect;
constexpr int PeersReply_PeerEvent_PeerEvent_ARRAYSIZE = PeersReply_PeerEvent_PeerEvent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeersReply_PeerEvent_descriptor();
template<typename T>
inline const std::string& PeersReply_PeerEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeersReply_PeerEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeersReply_PeerEvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PeersReply_PeerEvent_descriptor(), enum_t_value);
}
inline bool PeersReply_PeerEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeersReply_PeerEvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PeersReply_PeerEvent>(
    PeersReply_PeerEvent_descriptor(), name, value);
}
enum MessageId : int {
  STATUS_65 = 0,
  GET_BLOCK_HEADERS_65 = 1,
  BLOCK_HEADERS_65 = 2,
  BLOCK_HASHES_65 = 3,
  GET_BLOCK_BODIES_65 = 4,
  BLOCK_BODIES_65 = 5,
  GET_NODE_DATA_65 = 6,
  NODE_DATA_65 = 7,
  GET_RECEIPTS_65 = 8,
  RECEIPTS_65 = 9,
  NEW_BLOCK_HASHES_65 = 10,
  NEW_BLOCK_65 = 11,
  TRANSACTIONS_65 = 12,
  NEW_POOLED_TRANSACTION_HASHES_65 = 13,
  GET_POOLED_TRANSACTIONS_65 = 14,
  POOLED_TRANSACTIONS_65 = 15,
  STATUS_66 = 17,
  NEW_BLOCK_HASHES_66 = 18,
  NEW_BLOCK_66 = 19,
  TRANSACTIONS_66 = 20,
  NEW_POOLED_TRANSACTION_HASHES_66 = 21,
  GET_BLOCK_HEADERS_66 = 22,
  GET_BLOCK_BODIES_66 = 23,
  GET_NODE_DATA_66 = 24,
  GET_RECEIPTS_66 = 25,
  GET_POOLED_TRANSACTIONS_66 = 26,
  BLOCK_HEADERS_66 = 27,
  BLOCK_BODIES_66 = 28,
  NODE_DATA_66 = 29,
  RECEIPTS_66 = 30,
  POOLED_TRANSACTIONS_66 = 31,
  MessageId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageId_IsValid(int value);
constexpr MessageId MessageId_MIN = STATUS_65;
constexpr MessageId MessageId_MAX = POOLED_TRANSACTIONS_66;
constexpr int MessageId_ARRAYSIZE = MessageId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageId_descriptor();
template<typename T>
inline const std::string& MessageId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageId_descriptor(), enum_t_value);
}
inline bool MessageId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageId>(
    MessageId_descriptor(), name, value);
}
enum PenaltyKind : int {
  Kick = 0,
  PenaltyKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PenaltyKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PenaltyKind_IsValid(int value);
constexpr PenaltyKind PenaltyKind_MIN = Kick;
constexpr PenaltyKind PenaltyKind_MAX = Kick;
constexpr int PenaltyKind_ARRAYSIZE = PenaltyKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PenaltyKind_descriptor();
template<typename T>
inline const std::string& PenaltyKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PenaltyKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PenaltyKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PenaltyKind_descriptor(), enum_t_value);
}
inline bool PenaltyKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PenaltyKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PenaltyKind>(
    PenaltyKind_descriptor(), name, value);
}
enum Protocol : int {
  ETH65 = 0,
  ETH66 = 1,
  Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Protocol_IsValid(int value);
constexpr Protocol Protocol_MIN = ETH65;
constexpr Protocol Protocol_MAX = ETH66;
constexpr int Protocol_ARRAYSIZE = Protocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Protocol_descriptor();
template<typename T>
inline const std::string& Protocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Protocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Protocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Protocol_descriptor(), enum_t_value);
}
inline bool Protocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Protocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Protocol>(
    Protocol_descriptor(), name, value);
}
// ===================================================================

class OutboundMessageData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.OutboundMessageData) */ {
 public:
  inline OutboundMessageData() : OutboundMessageData(nullptr) {}
  virtual ~OutboundMessageData();

  OutboundMessageData(const OutboundMessageData& from);
  OutboundMessageData(OutboundMessageData&& from) noexcept
    : OutboundMessageData() {
    *this = ::std::move(from);
  }

  inline OutboundMessageData& operator=(const OutboundMessageData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutboundMessageData& operator=(OutboundMessageData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OutboundMessageData& default_instance();

  static inline const OutboundMessageData* internal_default_instance() {
    return reinterpret_cast<const OutboundMessageData*>(
               &_OutboundMessageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OutboundMessageData& a, OutboundMessageData& b) {
    a.Swap(&b);
  }
  inline void Swap(OutboundMessageData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutboundMessageData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutboundMessageData* New() const final {
    return CreateMaybeMessage<OutboundMessageData>(nullptr);
  }

  OutboundMessageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutboundMessageData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OutboundMessageData& from);
  void MergeFrom(const OutboundMessageData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutboundMessageData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.OutboundMessageData";
  }
  protected:
  explicit OutboundMessageData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .sentry.MessageId id = 1;
  void clear_id();
  ::sentry::MessageId id() const;
  void set_id(::sentry::MessageId value);
  private:
  ::sentry::MessageId _internal_id() const;
  void _internal_set_id(::sentry::MessageId value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.OutboundMessageData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SendMessageByMinBlockRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SendMessageByMinBlockRequest) */ {
 public:
  inline SendMessageByMinBlockRequest() : SendMessageByMinBlockRequest(nullptr) {}
  virtual ~SendMessageByMinBlockRequest();

  SendMessageByMinBlockRequest(const SendMessageByMinBlockRequest& from);
  SendMessageByMinBlockRequest(SendMessageByMinBlockRequest&& from) noexcept
    : SendMessageByMinBlockRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageByMinBlockRequest& operator=(const SendMessageByMinBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageByMinBlockRequest& operator=(SendMessageByMinBlockRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SendMessageByMinBlockRequest& default_instance();

  static inline const SendMessageByMinBlockRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageByMinBlockRequest*>(
               &_SendMessageByMinBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SendMessageByMinBlockRequest& a, SendMessageByMinBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageByMinBlockRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageByMinBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendMessageByMinBlockRequest* New() const final {
    return CreateMaybeMessage<SendMessageByMinBlockRequest>(nullptr);
  }

  SendMessageByMinBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendMessageByMinBlockRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SendMessageByMinBlockRequest& from);
  void MergeFrom(const SendMessageByMinBlockRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageByMinBlockRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SendMessageByMinBlockRequest";
  }
  protected:
  explicit SendMessageByMinBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kMinBlockFieldNumber = 2,
  };
  // .sentry.OutboundMessageData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::sentry::OutboundMessageData& data() const;
  ::sentry::OutboundMessageData* release_data();
  ::sentry::OutboundMessageData* mutable_data();
  void set_allocated_data(::sentry::OutboundMessageData* data);
  private:
  const ::sentry::OutboundMessageData& _internal_data() const;
  ::sentry::OutboundMessageData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::sentry::OutboundMessageData* data);
  ::sentry::OutboundMessageData* unsafe_arena_release_data();

  // uint64 min_block = 2;
  void clear_min_block();
  ::PROTOBUF_NAMESPACE_ID::uint64 min_block() const;
  void set_min_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_min_block() const;
  void _internal_set_min_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.SendMessageByMinBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sentry::OutboundMessageData* data_;
  ::PROTOBUF_NAMESPACE_ID::uint64 min_block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SendMessageByIdRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SendMessageByIdRequest) */ {
 public:
  inline SendMessageByIdRequest() : SendMessageByIdRequest(nullptr) {}
  virtual ~SendMessageByIdRequest();

  SendMessageByIdRequest(const SendMessageByIdRequest& from);
  SendMessageByIdRequest(SendMessageByIdRequest&& from) noexcept
    : SendMessageByIdRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageByIdRequest& operator=(const SendMessageByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageByIdRequest& operator=(SendMessageByIdRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SendMessageByIdRequest& default_instance();

  static inline const SendMessageByIdRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageByIdRequest*>(
               &_SendMessageByIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SendMessageByIdRequest& a, SendMessageByIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageByIdRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageByIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendMessageByIdRequest* New() const final {
    return CreateMaybeMessage<SendMessageByIdRequest>(nullptr);
  }

  SendMessageByIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendMessageByIdRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SendMessageByIdRequest& from);
  void MergeFrom(const SendMessageByIdRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageByIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SendMessageByIdRequest";
  }
  protected:
  explicit SendMessageByIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kPeerIdFieldNumber = 2,
  };
  // .sentry.OutboundMessageData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::sentry::OutboundMessageData& data() const;
  ::sentry::OutboundMessageData* release_data();
  ::sentry::OutboundMessageData* mutable_data();
  void set_allocated_data(::sentry::OutboundMessageData* data);
  private:
  const ::sentry::OutboundMessageData& _internal_data() const;
  ::sentry::OutboundMessageData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::sentry::OutboundMessageData* data);
  ::sentry::OutboundMessageData* unsafe_arena_release_data();

  // .types.H512 peer_id = 2;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // @@protoc_insertion_point(class_scope:sentry.SendMessageByIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sentry::OutboundMessageData* data_;
  ::types::H512* peer_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SendMessageToRandomPeersRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SendMessageToRandomPeersRequest) */ {
 public:
  inline SendMessageToRandomPeersRequest() : SendMessageToRandomPeersRequest(nullptr) {}
  virtual ~SendMessageToRandomPeersRequest();

  SendMessageToRandomPeersRequest(const SendMessageToRandomPeersRequest& from);
  SendMessageToRandomPeersRequest(SendMessageToRandomPeersRequest&& from) noexcept
    : SendMessageToRandomPeersRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageToRandomPeersRequest& operator=(const SendMessageToRandomPeersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageToRandomPeersRequest& operator=(SendMessageToRandomPeersRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SendMessageToRandomPeersRequest& default_instance();

  static inline const SendMessageToRandomPeersRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageToRandomPeersRequest*>(
               &_SendMessageToRandomPeersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SendMessageToRandomPeersRequest& a, SendMessageToRandomPeersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageToRandomPeersRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageToRandomPeersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendMessageToRandomPeersRequest* New() const final {
    return CreateMaybeMessage<SendMessageToRandomPeersRequest>(nullptr);
  }

  SendMessageToRandomPeersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendMessageToRandomPeersRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SendMessageToRandomPeersRequest& from);
  void MergeFrom(const SendMessageToRandomPeersRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageToRandomPeersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SendMessageToRandomPeersRequest";
  }
  protected:
  explicit SendMessageToRandomPeersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kMaxPeersFieldNumber = 2,
  };
  // .sentry.OutboundMessageData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::sentry::OutboundMessageData& data() const;
  ::sentry::OutboundMessageData* release_data();
  ::sentry::OutboundMessageData* mutable_data();
  void set_allocated_data(::sentry::OutboundMessageData* data);
  private:
  const ::sentry::OutboundMessageData& _internal_data() const;
  ::sentry::OutboundMessageData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::sentry::OutboundMessageData* data);
  ::sentry::OutboundMessageData* unsafe_arena_release_data();

  // uint64 max_peers = 2;
  void clear_max_peers();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_peers() const;
  void set_max_peers(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_peers() const;
  void _internal_set_max_peers(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.SendMessageToRandomPeersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sentry::OutboundMessageData* data_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_peers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SentPeers PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SentPeers) */ {
 public:
  inline SentPeers() : SentPeers(nullptr) {}
  virtual ~SentPeers();

  SentPeers(const SentPeers& from);
  SentPeers(SentPeers&& from) noexcept
    : SentPeers() {
    *this = ::std::move(from);
  }

  inline SentPeers& operator=(const SentPeers& from) {
    CopyFrom(from);
    return *this;
  }
  inline SentPeers& operator=(SentPeers&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SentPeers& default_instance();

  static inline const SentPeers* internal_default_instance() {
    return reinterpret_cast<const SentPeers*>(
               &_SentPeers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SentPeers& a, SentPeers& b) {
    a.Swap(&b);
  }
  inline void Swap(SentPeers* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SentPeers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SentPeers* New() const final {
    return CreateMaybeMessage<SentPeers>(nullptr);
  }

  SentPeers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SentPeers>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SentPeers& from);
  void MergeFrom(const SentPeers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SentPeers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SentPeers";
  }
  protected:
  explicit SentPeers(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
  };
  // repeated .types.H512 peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::types::H512* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 >*
      mutable_peers();
  private:
  const ::types::H512& _internal_peers(int index) const;
  ::types::H512* _internal_add_peers();
  public:
  const ::types::H512& peers(int index) const;
  ::types::H512* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 >&
      peers() const;

  // @@protoc_insertion_point(class_scope:sentry.SentPeers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 > peers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PenalizePeerRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PenalizePeerRequest) */ {
 public:
  inline PenalizePeerRequest() : PenalizePeerRequest(nullptr) {}
  virtual ~PenalizePeerRequest();

  PenalizePeerRequest(const PenalizePeerRequest& from);
  PenalizePeerRequest(PenalizePeerRequest&& from) noexcept
    : PenalizePeerRequest() {
    *this = ::std::move(from);
  }

  inline PenalizePeerRequest& operator=(const PenalizePeerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PenalizePeerRequest& operator=(PenalizePeerRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PenalizePeerRequest& default_instance();

  static inline const PenalizePeerRequest* internal_default_instance() {
    return reinterpret_cast<const PenalizePeerRequest*>(
               &_PenalizePeerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PenalizePeerRequest& a, PenalizePeerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PenalizePeerRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PenalizePeerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PenalizePeerRequest* New() const final {
    return CreateMaybeMessage<PenalizePeerRequest>(nullptr);
  }

  PenalizePeerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PenalizePeerRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PenalizePeerRequest& from);
  void MergeFrom(const PenalizePeerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PenalizePeerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PenalizePeerRequest";
  }
  protected:
  explicit PenalizePeerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kPenaltyFieldNumber = 2,
  };
  // .types.H512 peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // .sentry.PenaltyKind penalty = 2;
  void clear_penalty();
  ::sentry::PenaltyKind penalty() const;
  void set_penalty(::sentry::PenaltyKind value);
  private:
  ::sentry::PenaltyKind _internal_penalty() const;
  void _internal_set_penalty(::sentry::PenaltyKind value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PenalizePeerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H512* peer_id_;
  int penalty_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerMinBlockRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerMinBlockRequest) */ {
 public:
  inline PeerMinBlockRequest() : PeerMinBlockRequest(nullptr) {}
  virtual ~PeerMinBlockRequest();

  PeerMinBlockRequest(const PeerMinBlockRequest& from);
  PeerMinBlockRequest(PeerMinBlockRequest&& from) noexcept
    : PeerMinBlockRequest() {
    *this = ::std::move(from);
  }

  inline PeerMinBlockRequest& operator=(const PeerMinBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerMinBlockRequest& operator=(PeerMinBlockRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeerMinBlockRequest& default_instance();

  static inline const PeerMinBlockRequest* internal_default_instance() {
    return reinterpret_cast<const PeerMinBlockRequest*>(
               &_PeerMinBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PeerMinBlockRequest& a, PeerMinBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerMinBlockRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerMinBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeerMinBlockRequest* New() const final {
    return CreateMaybeMessage<PeerMinBlockRequest>(nullptr);
  }

  PeerMinBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeerMinBlockRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeerMinBlockRequest& from);
  void MergeFrom(const PeerMinBlockRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerMinBlockRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerMinBlockRequest";
  }
  protected:
  explicit PeerMinBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kMinBlockFieldNumber = 2,
  };
  // .types.H512 peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // uint64 min_block = 2;
  void clear_min_block();
  ::PROTOBUF_NAMESPACE_ID::uint64 min_block() const;
  void set_min_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_min_block() const;
  void _internal_set_min_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PeerMinBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H512* peer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 min_block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class InboundMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.InboundMessage) */ {
 public:
  inline InboundMessage() : InboundMessage(nullptr) {}
  virtual ~InboundMessage();

  InboundMessage(const InboundMessage& from);
  InboundMessage(InboundMessage&& from) noexcept
    : InboundMessage() {
    *this = ::std::move(from);
  }

  inline InboundMessage& operator=(const InboundMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InboundMessage& operator=(InboundMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InboundMessage& default_instance();

  static inline const InboundMessage* internal_default_instance() {
    return reinterpret_cast<const InboundMessage*>(
               &_InboundMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InboundMessage& a, InboundMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InboundMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InboundMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InboundMessage* New() const final {
    return CreateMaybeMessage<InboundMessage>(nullptr);
  }

  InboundMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InboundMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InboundMessage& from);
  void MergeFrom(const InboundMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InboundMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.InboundMessage";
  }
  protected:
  explicit InboundMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPeerIdFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .types.H512 peer_id = 3;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // .sentry.MessageId id = 1;
  void clear_id();
  ::sentry::MessageId id() const;
  void set_id(::sentry::MessageId value);
  private:
  ::sentry::MessageId _internal_id() const;
  void _internal_set_id(::sentry::MessageId value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.InboundMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::types::H512* peer_id_;
  int id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class Forks PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.Forks) */ {
 public:
  inline Forks() : Forks(nullptr) {}
  virtual ~Forks();

  Forks(const Forks& from);
  Forks(Forks&& from) noexcept
    : Forks() {
    *this = ::std::move(from);
  }

  inline Forks& operator=(const Forks& from) {
    CopyFrom(from);
    return *this;
  }
  inline Forks& operator=(Forks&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Forks& default_instance();

  static inline const Forks* internal_default_instance() {
    return reinterpret_cast<const Forks*>(
               &_Forks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Forks& a, Forks& b) {
    a.Swap(&b);
  }
  inline void Swap(Forks* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Forks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Forks* New() const final {
    return CreateMaybeMessage<Forks>(nullptr);
  }

  Forks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Forks>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Forks& from);
  void MergeFrom(const Forks& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Forks* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.Forks";
  }
  protected:
  explicit Forks(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForksFieldNumber = 2,
    kGenesisFieldNumber = 1,
  };
  // repeated uint64 forks = 2;
  int forks_size() const;
  private:
  int _internal_forks_size() const;
  public:
  void clear_forks();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_forks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_forks() const;
  void _internal_add_forks(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_forks();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 forks(int index) const;
  void set_forks(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_forks(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      forks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_forks();

  // .types.H256 genesis = 1;
  bool has_genesis() const;
  private:
  bool _internal_has_genesis() const;
  public:
  void clear_genesis();
  const ::types::H256& genesis() const;
  ::types::H256* release_genesis();
  ::types::H256* mutable_genesis();
  void set_allocated_genesis(::types::H256* genesis);
  private:
  const ::types::H256& _internal_genesis() const;
  ::types::H256* _internal_mutable_genesis();
  public:
  void unsafe_arena_set_allocated_genesis(
      ::types::H256* genesis);
  ::types::H256* unsafe_arena_release_genesis();

  // @@protoc_insertion_point(class_scope:sentry.Forks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > forks_;
  mutable std::atomic<int> _forks_cached_byte_size_;
  ::types::H256* genesis_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class StatusData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.StatusData) */ {
 public:
  inline StatusData() : StatusData(nullptr) {}
  virtual ~StatusData();

  StatusData(const StatusData& from);
  StatusData(StatusData&& from) noexcept
    : StatusData() {
    *this = ::std::move(from);
  }

  inline StatusData& operator=(const StatusData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusData& operator=(StatusData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusData& default_instance();

  static inline const StatusData* internal_default_instance() {
    return reinterpret_cast<const StatusData*>(
               &_StatusData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StatusData& a, StatusData& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusData* New() const final {
    return CreateMaybeMessage<StatusData>(nullptr);
  }

  StatusData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusData& from);
  void MergeFrom(const StatusData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.StatusData";
  }
  protected:
  explicit StatusData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalDifficultyFieldNumber = 2,
    kBestHashFieldNumber = 3,
    kForkDataFieldNumber = 4,
    kNetworkIdFieldNumber = 1,
    kMaxBlockFieldNumber = 5,
  };
  // .types.H256 total_difficulty = 2;
  bool has_total_difficulty() const;
  private:
  bool _internal_has_total_difficulty() const;
  public:
  void clear_total_difficulty();
  const ::types::H256& total_difficulty() const;
  ::types::H256* release_total_difficulty();
  ::types::H256* mutable_total_difficulty();
  void set_allocated_total_difficulty(::types::H256* total_difficulty);
  private:
  const ::types::H256& _internal_total_difficulty() const;
  ::types::H256* _internal_mutable_total_difficulty();
  public:
  void unsafe_arena_set_allocated_total_difficulty(
      ::types::H256* total_difficulty);
  ::types::H256* unsafe_arena_release_total_difficulty();

  // .types.H256 best_hash = 3;
  bool has_best_hash() const;
  private:
  bool _internal_has_best_hash() const;
  public:
  void clear_best_hash();
  const ::types::H256& best_hash() const;
  ::types::H256* release_best_hash();
  ::types::H256* mutable_best_hash();
  void set_allocated_best_hash(::types::H256* best_hash);
  private:
  const ::types::H256& _internal_best_hash() const;
  ::types::H256* _internal_mutable_best_hash();
  public:
  void unsafe_arena_set_allocated_best_hash(
      ::types::H256* best_hash);
  ::types::H256* unsafe_arena_release_best_hash();

  // .sentry.Forks fork_data = 4;
  bool has_fork_data() const;
  private:
  bool _internal_has_fork_data() const;
  public:
  void clear_fork_data();
  const ::sentry::Forks& fork_data() const;
  ::sentry::Forks* release_fork_data();
  ::sentry::Forks* mutable_fork_data();
  void set_allocated_fork_data(::sentry::Forks* fork_data);
  private:
  const ::sentry::Forks& _internal_fork_data() const;
  ::sentry::Forks* _internal_mutable_fork_data();
  public:
  void unsafe_arena_set_allocated_fork_data(
      ::sentry::Forks* fork_data);
  ::sentry::Forks* unsafe_arena_release_fork_data();

  // uint64 network_id = 1;
  void clear_network_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 network_id() const;
  void set_network_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_network_id() const;
  void _internal_set_network_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 max_block = 5;
  void clear_max_block();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_block() const;
  void set_max_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_block() const;
  void _internal_set_max_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.StatusData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H256* total_difficulty_;
  ::types::H256* best_hash_;
  ::sentry::Forks* fork_data_;
  ::PROTOBUF_NAMESPACE_ID::uint64 network_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class SetStatusReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.SetStatusReply) */ {
 public:
  inline SetStatusReply() : SetStatusReply(nullptr) {}
  virtual ~SetStatusReply();

  SetStatusReply(const SetStatusReply& from);
  SetStatusReply(SetStatusReply&& from) noexcept
    : SetStatusReply() {
    *this = ::std::move(from);
  }

  inline SetStatusReply& operator=(const SetStatusReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetStatusReply& operator=(SetStatusReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetStatusReply& default_instance();

  static inline const SetStatusReply* internal_default_instance() {
    return reinterpret_cast<const SetStatusReply*>(
               &_SetStatusReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetStatusReply& a, SetStatusReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetStatusReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetStatusReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetStatusReply* New() const final {
    return CreateMaybeMessage<SetStatusReply>(nullptr);
  }

  SetStatusReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetStatusReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetStatusReply& from);
  void MergeFrom(const SetStatusReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetStatusReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.SetStatusReply";
  }
  protected:
  explicit SetStatusReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sentry.SetStatusReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class HandShakeReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.HandShakeReply) */ {
 public:
  inline HandShakeReply() : HandShakeReply(nullptr) {}
  virtual ~HandShakeReply();

  HandShakeReply(const HandShakeReply& from);
  HandShakeReply(HandShakeReply&& from) noexcept
    : HandShakeReply() {
    *this = ::std::move(from);
  }

  inline HandShakeReply& operator=(const HandShakeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandShakeReply& operator=(HandShakeReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HandShakeReply& default_instance();

  static inline const HandShakeReply* internal_default_instance() {
    return reinterpret_cast<const HandShakeReply*>(
               &_HandShakeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HandShakeReply& a, HandShakeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HandShakeReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandShakeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HandShakeReply* New() const final {
    return CreateMaybeMessage<HandShakeReply>(nullptr);
  }

  HandShakeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HandShakeReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HandShakeReply& from);
  void MergeFrom(const HandShakeReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandShakeReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.HandShakeReply";
  }
  protected:
  explicit HandShakeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolFieldNumber = 1,
  };
  // .sentry.Protocol protocol = 1;
  void clear_protocol();
  ::sentry::Protocol protocol() const;
  void set_protocol(::sentry::Protocol value);
  private:
  ::sentry::Protocol _internal_protocol() const;
  void _internal_set_protocol(::sentry::Protocol value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.HandShakeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int protocol_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class MessagesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.MessagesRequest) */ {
 public:
  inline MessagesRequest() : MessagesRequest(nullptr) {}
  virtual ~MessagesRequest();

  MessagesRequest(const MessagesRequest& from);
  MessagesRequest(MessagesRequest&& from) noexcept
    : MessagesRequest() {
    *this = ::std::move(from);
  }

  inline MessagesRequest& operator=(const MessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagesRequest& operator=(MessagesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessagesRequest& default_instance();

  static inline const MessagesRequest* internal_default_instance() {
    return reinterpret_cast<const MessagesRequest*>(
               &_MessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MessagesRequest& a, MessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessagesRequest* New() const final {
    return CreateMaybeMessage<MessagesRequest>(nullptr);
  }

  MessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessagesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessagesRequest& from);
  void MergeFrom(const MessagesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.MessagesRequest";
  }
  protected:
  explicit MessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated .sentry.MessageId ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  ::sentry::MessageId _internal_ids(int index) const;
  void _internal_add_ids(::sentry::MessageId value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_ids();
  public:
  ::sentry::MessageId ids(int index) const;
  void set_ids(int index, ::sentry::MessageId value);
  void add_ids(::sentry::MessageId value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ids();

  // @@protoc_insertion_point(class_scope:sentry.MessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ids_;
  mutable std::atomic<int> _ids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerCountRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerCountRequest) */ {
 public:
  inline PeerCountRequest() : PeerCountRequest(nullptr) {}
  virtual ~PeerCountRequest();

  PeerCountRequest(const PeerCountRequest& from);
  PeerCountRequest(PeerCountRequest&& from) noexcept
    : PeerCountRequest() {
    *this = ::std::move(from);
  }

  inline PeerCountRequest& operator=(const PeerCountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerCountRequest& operator=(PeerCountRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeerCountRequest& default_instance();

  static inline const PeerCountRequest* internal_default_instance() {
    return reinterpret_cast<const PeerCountRequest*>(
               &_PeerCountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PeerCountRequest& a, PeerCountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerCountRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerCountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeerCountRequest* New() const final {
    return CreateMaybeMessage<PeerCountRequest>(nullptr);
  }

  PeerCountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeerCountRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeerCountRequest& from);
  void MergeFrom(const PeerCountRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerCountRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerCountRequest";
  }
  protected:
  explicit PeerCountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sentry.PeerCountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeerCountReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeerCountReply) */ {
 public:
  inline PeerCountReply() : PeerCountReply(nullptr) {}
  virtual ~PeerCountReply();

  PeerCountReply(const PeerCountReply& from);
  PeerCountReply(PeerCountReply&& from) noexcept
    : PeerCountReply() {
    *this = ::std::move(from);
  }

  inline PeerCountReply& operator=(const PeerCountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerCountReply& operator=(PeerCountReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeerCountReply& default_instance();

  static inline const PeerCountReply* internal_default_instance() {
    return reinterpret_cast<const PeerCountReply*>(
               &_PeerCountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PeerCountReply& a, PeerCountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerCountReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerCountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeerCountReply* New() const final {
    return CreateMaybeMessage<PeerCountReply>(nullptr);
  }

  PeerCountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeerCountReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeerCountReply& from);
  void MergeFrom(const PeerCountReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerCountReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeerCountReply";
  }
  protected:
  explicit PeerCountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // uint64 count = 1;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PeerCountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeersRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeersRequest) */ {
 public:
  inline PeersRequest() : PeersRequest(nullptr) {}
  virtual ~PeersRequest();

  PeersRequest(const PeersRequest& from);
  PeersRequest(PeersRequest&& from) noexcept
    : PeersRequest() {
    *this = ::std::move(from);
  }

  inline PeersRequest& operator=(const PeersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeersRequest& operator=(PeersRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeersRequest& default_instance();

  static inline const PeersRequest* internal_default_instance() {
    return reinterpret_cast<const PeersRequest*>(
               &_PeersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PeersRequest& a, PeersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeersRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeersRequest* New() const final {
    return CreateMaybeMessage<PeersRequest>(nullptr);
  }

  PeersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeersRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeersRequest& from);
  void MergeFrom(const PeersRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeersRequest";
  }
  protected:
  explicit PeersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sentry.PeersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// -------------------------------------------------------------------

class PeersReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentry.PeersReply) */ {
 public:
  inline PeersReply() : PeersReply(nullptr) {}
  virtual ~PeersReply();

  PeersReply(const PeersReply& from);
  PeersReply(PeersReply&& from) noexcept
    : PeersReply() {
    *this = ::std::move(from);
  }

  inline PeersReply& operator=(const PeersReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeersReply& operator=(PeersReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeersReply& default_instance();

  static inline const PeersReply* internal_default_instance() {
    return reinterpret_cast<const PeersReply*>(
               &_PeersReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PeersReply& a, PeersReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PeersReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeersReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeersReply* New() const final {
    return CreateMaybeMessage<PeersReply>(nullptr);
  }

  PeersReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeersReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeersReply& from);
  void MergeFrom(const PeersReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeersReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentry.PeersReply";
  }
  protected:
  explicit PeersReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_p2psentry_2fsentry_2eproto);
    return ::descriptor_table_p2psentry_2fsentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PeersReply_PeerEvent PeerEvent;
  static constexpr PeerEvent Connect =
    PeersReply_PeerEvent_Connect;
  static constexpr PeerEvent Disconnect =
    PeersReply_PeerEvent_Disconnect;
  static inline bool PeerEvent_IsValid(int value) {
    return PeersReply_PeerEvent_IsValid(value);
  }
  static constexpr PeerEvent PeerEvent_MIN =
    PeersReply_PeerEvent_PeerEvent_MIN;
  static constexpr PeerEvent PeerEvent_MAX =
    PeersReply_PeerEvent_PeerEvent_MAX;
  static constexpr int PeerEvent_ARRAYSIZE =
    PeersReply_PeerEvent_PeerEvent_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PeerEvent_descriptor() {
    return PeersReply_PeerEvent_descriptor();
  }
  template<typename T>
  static inline const std::string& PeerEvent_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PeerEvent>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PeerEvent_Name.");
    return PeersReply_PeerEvent_Name(enum_t_value);
  }
  static inline bool PeerEvent_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PeerEvent* value) {
    return PeersReply_PeerEvent_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kEventFieldNumber = 2,
  };
  // .types.H512 peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const ::types::H512& peer_id() const;
  ::types::H512* release_peer_id();
  ::types::H512* mutable_peer_id();
  void set_allocated_peer_id(::types::H512* peer_id);
  private:
  const ::types::H512& _internal_peer_id() const;
  ::types::H512* _internal_mutable_peer_id();
  public:
  void unsafe_arena_set_allocated_peer_id(
      ::types::H512* peer_id);
  ::types::H512* unsafe_arena_release_peer_id();

  // .sentry.PeersReply.PeerEvent event = 2;
  void clear_event();
  ::sentry::PeersReply_PeerEvent event() const;
  void set_event(::sentry::PeersReply_PeerEvent value);
  private:
  ::sentry::PeersReply_PeerEvent _internal_event() const;
  void _internal_set_event(::sentry::PeersReply_PeerEvent value);
  public:

  // @@protoc_insertion_point(class_scope:sentry.PeersReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H512* peer_id_;
  int event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p2psentry_2fsentry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OutboundMessageData

// .sentry.MessageId id = 1;
inline void OutboundMessageData::clear_id() {
  id_ = 0;
}
inline ::sentry::MessageId OutboundMessageData::_internal_id() const {
  return static_cast< ::sentry::MessageId >(id_);
}
inline ::sentry::MessageId OutboundMessageData::id() const {
  // @@protoc_insertion_point(field_get:sentry.OutboundMessageData.id)
  return _internal_id();
}
inline void OutboundMessageData::_internal_set_id(::sentry::MessageId value) {
  
  id_ = value;
}
inline void OutboundMessageData::set_id(::sentry::MessageId value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sentry.OutboundMessageData.id)
}

// bytes data = 2;
inline void OutboundMessageData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& OutboundMessageData::data() const {
  // @@protoc_insertion_point(field_get:sentry.OutboundMessageData.data)
  return _internal_data();
}
inline void OutboundMessageData::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:sentry.OutboundMessageData.data)
}
inline std::string* OutboundMessageData::mutable_data() {
  // @@protoc_insertion_point(field_mutable:sentry.OutboundMessageData.data)
  return _internal_mutable_data();
}
inline const std::string& OutboundMessageData::_internal_data() const {
  return data_.Get();
}
inline void OutboundMessageData::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void OutboundMessageData::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:sentry.OutboundMessageData.data)
}
inline void OutboundMessageData::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:sentry.OutboundMessageData.data)
}
inline void OutboundMessageData::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:sentry.OutboundMessageData.data)
}
inline std::string* OutboundMessageData::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* OutboundMessageData::release_data() {
  // @@protoc_insertion_point(field_release:sentry.OutboundMessageData.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OutboundMessageData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sentry.OutboundMessageData.data)
}

// -------------------------------------------------------------------

// SendMessageByMinBlockRequest

// .sentry.OutboundMessageData data = 1;
inline bool SendMessageByMinBlockRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool SendMessageByMinBlockRequest::has_data() const {
  return _internal_has_data();
}
inline void SendMessageByMinBlockRequest::clear_data() {
  if (GetArena() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::sentry::OutboundMessageData& SendMessageByMinBlockRequest::_internal_data() const {
  const ::sentry::OutboundMessageData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentry::OutboundMessageData&>(
      ::sentry::_OutboundMessageData_default_instance_);
}
inline const ::sentry::OutboundMessageData& SendMessageByMinBlockRequest::data() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByMinBlockRequest.data)
  return _internal_data();
}
inline void SendMessageByMinBlockRequest::unsafe_arena_set_allocated_data(
    ::sentry::OutboundMessageData* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.SendMessageByMinBlockRequest.data)
}
inline ::sentry::OutboundMessageData* SendMessageByMinBlockRequest::release_data() {
  
  ::sentry::OutboundMessageData* temp = data_;
  data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageByMinBlockRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:sentry.SendMessageByMinBlockRequest.data)
  
  ::sentry::OutboundMessageData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageByMinBlockRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentry::OutboundMessageData>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::sentry::OutboundMessageData* SendMessageByMinBlockRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable:sentry.SendMessageByMinBlockRequest.data)
  return _internal_mutable_data();
}
inline void SendMessageByMinBlockRequest::set_allocated_data(::sentry::OutboundMessageData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:sentry.SendMessageByMinBlockRequest.data)
}

// uint64 min_block = 2;
inline void SendMessageByMinBlockRequest::clear_min_block() {
  min_block_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SendMessageByMinBlockRequest::_internal_min_block() const {
  return min_block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SendMessageByMinBlockRequest::min_block() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByMinBlockRequest.min_block)
  return _internal_min_block();
}
inline void SendMessageByMinBlockRequest::_internal_set_min_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  min_block_ = value;
}
inline void SendMessageByMinBlockRequest::set_min_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_min_block(value);
  // @@protoc_insertion_point(field_set:sentry.SendMessageByMinBlockRequest.min_block)
}

// -------------------------------------------------------------------

// SendMessageByIdRequest

// .sentry.OutboundMessageData data = 1;
inline bool SendMessageByIdRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool SendMessageByIdRequest::has_data() const {
  return _internal_has_data();
}
inline void SendMessageByIdRequest::clear_data() {
  if (GetArena() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::sentry::OutboundMessageData& SendMessageByIdRequest::_internal_data() const {
  const ::sentry::OutboundMessageData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentry::OutboundMessageData&>(
      ::sentry::_OutboundMessageData_default_instance_);
}
inline const ::sentry::OutboundMessageData& SendMessageByIdRequest::data() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByIdRequest.data)
  return _internal_data();
}
inline void SendMessageByIdRequest::unsafe_arena_set_allocated_data(
    ::sentry::OutboundMessageData* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.SendMessageByIdRequest.data)
}
inline ::sentry::OutboundMessageData* SendMessageByIdRequest::release_data() {
  
  ::sentry::OutboundMessageData* temp = data_;
  data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageByIdRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:sentry.SendMessageByIdRequest.data)
  
  ::sentry::OutboundMessageData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageByIdRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentry::OutboundMessageData>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::sentry::OutboundMessageData* SendMessageByIdRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable:sentry.SendMessageByIdRequest.data)
  return _internal_mutable_data();
}
inline void SendMessageByIdRequest::set_allocated_data(::sentry::OutboundMessageData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:sentry.SendMessageByIdRequest.data)
}

// .types.H512 peer_id = 2;
inline bool SendMessageByIdRequest::_internal_has_peer_id() const {
  return this != internal_default_instance() && peer_id_ != nullptr;
}
inline bool SendMessageByIdRequest::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& SendMessageByIdRequest::_internal_peer_id() const {
  const ::types::H512* p = peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& SendMessageByIdRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageByIdRequest.peer_id)
  return _internal_peer_id();
}
inline void SendMessageByIdRequest::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.SendMessageByIdRequest.peer_id)
}
inline ::types::H512* SendMessageByIdRequest::release_peer_id() {
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H512* SendMessageByIdRequest::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.SendMessageByIdRequest.peer_id)
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* SendMessageByIdRequest::_internal_mutable_peer_id() {
  
  if (peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArena());
    peer_id_ = p;
  }
  return peer_id_;
}
inline ::types::H512* SendMessageByIdRequest::mutable_peer_id() {
  // @@protoc_insertion_point(field_mutable:sentry.SendMessageByIdRequest.peer_id)
  return _internal_mutable_peer_id();
}
inline void SendMessageByIdRequest::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id)->GetArena();
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.SendMessageByIdRequest.peer_id)
}

// -------------------------------------------------------------------

// SendMessageToRandomPeersRequest

// .sentry.OutboundMessageData data = 1;
inline bool SendMessageToRandomPeersRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool SendMessageToRandomPeersRequest::has_data() const {
  return _internal_has_data();
}
inline void SendMessageToRandomPeersRequest::clear_data() {
  if (GetArena() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::sentry::OutboundMessageData& SendMessageToRandomPeersRequest::_internal_data() const {
  const ::sentry::OutboundMessageData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentry::OutboundMessageData&>(
      ::sentry::_OutboundMessageData_default_instance_);
}
inline const ::sentry::OutboundMessageData& SendMessageToRandomPeersRequest::data() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageToRandomPeersRequest.data)
  return _internal_data();
}
inline void SendMessageToRandomPeersRequest::unsafe_arena_set_allocated_data(
    ::sentry::OutboundMessageData* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.SendMessageToRandomPeersRequest.data)
}
inline ::sentry::OutboundMessageData* SendMessageToRandomPeersRequest::release_data() {
  
  ::sentry::OutboundMessageData* temp = data_;
  data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageToRandomPeersRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:sentry.SendMessageToRandomPeersRequest.data)
  
  ::sentry::OutboundMessageData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::sentry::OutboundMessageData* SendMessageToRandomPeersRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentry::OutboundMessageData>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::sentry::OutboundMessageData* SendMessageToRandomPeersRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable:sentry.SendMessageToRandomPeersRequest.data)
  return _internal_mutable_data();
}
inline void SendMessageToRandomPeersRequest::set_allocated_data(::sentry::OutboundMessageData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:sentry.SendMessageToRandomPeersRequest.data)
}

// uint64 max_peers = 2;
inline void SendMessageToRandomPeersRequest::clear_max_peers() {
  max_peers_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SendMessageToRandomPeersRequest::_internal_max_peers() const {
  return max_peers_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SendMessageToRandomPeersRequest::max_peers() const {
  // @@protoc_insertion_point(field_get:sentry.SendMessageToRandomPeersRequest.max_peers)
  return _internal_max_peers();
}
inline void SendMessageToRandomPeersRequest::_internal_set_max_peers(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  max_peers_ = value;
}
inline void SendMessageToRandomPeersRequest::set_max_peers(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_peers(value);
  // @@protoc_insertion_point(field_set:sentry.SendMessageToRandomPeersRequest.max_peers)
}

// -------------------------------------------------------------------

// SentPeers

// repeated .types.H512 peers = 1;
inline int SentPeers::_internal_peers_size() const {
  return peers_.size();
}
inline int SentPeers::peers_size() const {
  return _internal_peers_size();
}
inline ::types::H512* SentPeers::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:sentry.SentPeers.peers)
  return peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 >*
SentPeers::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:sentry.SentPeers.peers)
  return &peers_;
}
inline const ::types::H512& SentPeers::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const ::types::H512& SentPeers::peers(int index) const {
  // @@protoc_insertion_point(field_get:sentry.SentPeers.peers)
  return _internal_peers(index);
}
inline ::types::H512* SentPeers::_internal_add_peers() {
  return peers_.Add();
}
inline ::types::H512* SentPeers::add_peers() {
  // @@protoc_insertion_point(field_add:sentry.SentPeers.peers)
  return _internal_add_peers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::H512 >&
SentPeers::peers() const {
  // @@protoc_insertion_point(field_list:sentry.SentPeers.peers)
  return peers_;
}

// -------------------------------------------------------------------

// PenalizePeerRequest

// .types.H512 peer_id = 1;
inline bool PenalizePeerRequest::_internal_has_peer_id() const {
  return this != internal_default_instance() && peer_id_ != nullptr;
}
inline bool PenalizePeerRequest::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& PenalizePeerRequest::_internal_peer_id() const {
  const ::types::H512* p = peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& PenalizePeerRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.PenalizePeerRequest.peer_id)
  return _internal_peer_id();
}
inline void PenalizePeerRequest::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.PenalizePeerRequest.peer_id)
}
inline ::types::H512* PenalizePeerRequest::release_peer_id() {
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H512* PenalizePeerRequest::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.PenalizePeerRequest.peer_id)
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* PenalizePeerRequest::_internal_mutable_peer_id() {
  
  if (peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArena());
    peer_id_ = p;
  }
  return peer_id_;
}
inline ::types::H512* PenalizePeerRequest::mutable_peer_id() {
  // @@protoc_insertion_point(field_mutable:sentry.PenalizePeerRequest.peer_id)
  return _internal_mutable_peer_id();
}
inline void PenalizePeerRequest::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id)->GetArena();
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.PenalizePeerRequest.peer_id)
}

// .sentry.PenaltyKind penalty = 2;
inline void PenalizePeerRequest::clear_penalty() {
  penalty_ = 0;
}
inline ::sentry::PenaltyKind PenalizePeerRequest::_internal_penalty() const {
  return static_cast< ::sentry::PenaltyKind >(penalty_);
}
inline ::sentry::PenaltyKind PenalizePeerRequest::penalty() const {
  // @@protoc_insertion_point(field_get:sentry.PenalizePeerRequest.penalty)
  return _internal_penalty();
}
inline void PenalizePeerRequest::_internal_set_penalty(::sentry::PenaltyKind value) {
  
  penalty_ = value;
}
inline void PenalizePeerRequest::set_penalty(::sentry::PenaltyKind value) {
  _internal_set_penalty(value);
  // @@protoc_insertion_point(field_set:sentry.PenalizePeerRequest.penalty)
}

// -------------------------------------------------------------------

// PeerMinBlockRequest

// .types.H512 peer_id = 1;
inline bool PeerMinBlockRequest::_internal_has_peer_id() const {
  return this != internal_default_instance() && peer_id_ != nullptr;
}
inline bool PeerMinBlockRequest::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& PeerMinBlockRequest::_internal_peer_id() const {
  const ::types::H512* p = peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& PeerMinBlockRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.PeerMinBlockRequest.peer_id)
  return _internal_peer_id();
}
inline void PeerMinBlockRequest::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.PeerMinBlockRequest.peer_id)
}
inline ::types::H512* PeerMinBlockRequest::release_peer_id() {
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H512* PeerMinBlockRequest::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.PeerMinBlockRequest.peer_id)
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* PeerMinBlockRequest::_internal_mutable_peer_id() {
  
  if (peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArena());
    peer_id_ = p;
  }
  return peer_id_;
}
inline ::types::H512* PeerMinBlockRequest::mutable_peer_id() {
  // @@protoc_insertion_point(field_mutable:sentry.PeerMinBlockRequest.peer_id)
  return _internal_mutable_peer_id();
}
inline void PeerMinBlockRequest::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id)->GetArena();
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.PeerMinBlockRequest.peer_id)
}

// uint64 min_block = 2;
inline void PeerMinBlockRequest::clear_min_block() {
  min_block_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PeerMinBlockRequest::_internal_min_block() const {
  return min_block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PeerMinBlockRequest::min_block() const {
  // @@protoc_insertion_point(field_get:sentry.PeerMinBlockRequest.min_block)
  return _internal_min_block();
}
inline void PeerMinBlockRequest::_internal_set_min_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  min_block_ = value;
}
inline void PeerMinBlockRequest::set_min_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_min_block(value);
  // @@protoc_insertion_point(field_set:sentry.PeerMinBlockRequest.min_block)
}

// -------------------------------------------------------------------

// InboundMessage

// .sentry.MessageId id = 1;
inline void InboundMessage::clear_id() {
  id_ = 0;
}
inline ::sentry::MessageId InboundMessage::_internal_id() const {
  return static_cast< ::sentry::MessageId >(id_);
}
inline ::sentry::MessageId InboundMessage::id() const {
  // @@protoc_insertion_point(field_get:sentry.InboundMessage.id)
  return _internal_id();
}
inline void InboundMessage::_internal_set_id(::sentry::MessageId value) {
  
  id_ = value;
}
inline void InboundMessage::set_id(::sentry::MessageId value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sentry.InboundMessage.id)
}

// bytes data = 2;
inline void InboundMessage::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& InboundMessage::data() const {
  // @@protoc_insertion_point(field_get:sentry.InboundMessage.data)
  return _internal_data();
}
inline void InboundMessage::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:sentry.InboundMessage.data)
}
inline std::string* InboundMessage::mutable_data() {
  // @@protoc_insertion_point(field_mutable:sentry.InboundMessage.data)
  return _internal_mutable_data();
}
inline const std::string& InboundMessage::_internal_data() const {
  return data_.Get();
}
inline void InboundMessage::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InboundMessage::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:sentry.InboundMessage.data)
}
inline void InboundMessage::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:sentry.InboundMessage.data)
}
inline void InboundMessage::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:sentry.InboundMessage.data)
}
inline std::string* InboundMessage::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InboundMessage::release_data() {
  // @@protoc_insertion_point(field_release:sentry.InboundMessage.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InboundMessage::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sentry.InboundMessage.data)
}

// .types.H512 peer_id = 3;
inline bool InboundMessage::_internal_has_peer_id() const {
  return this != internal_default_instance() && peer_id_ != nullptr;
}
inline bool InboundMessage::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& InboundMessage::_internal_peer_id() const {
  const ::types::H512* p = peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& InboundMessage::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.InboundMessage.peer_id)
  return _internal_peer_id();
}
inline void InboundMessage::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.InboundMessage.peer_id)
}
inline ::types::H512* InboundMessage::release_peer_id() {
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H512* InboundMessage::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.InboundMessage.peer_id)
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* InboundMessage::_internal_mutable_peer_id() {
  
  if (peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArena());
    peer_id_ = p;
  }
  return peer_id_;
}
inline ::types::H512* InboundMessage::mutable_peer_id() {
  // @@protoc_insertion_point(field_mutable:sentry.InboundMessage.peer_id)
  return _internal_mutable_peer_id();
}
inline void InboundMessage::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id)->GetArena();
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.InboundMessage.peer_id)
}

// -------------------------------------------------------------------

// Forks

// .types.H256 genesis = 1;
inline bool Forks::_internal_has_genesis() const {
  return this != internal_default_instance() && genesis_ != nullptr;
}
inline bool Forks::has_genesis() const {
  return _internal_has_genesis();
}
inline const ::types::H256& Forks::_internal_genesis() const {
  const ::types::H256* p = genesis_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Forks::genesis() const {
  // @@protoc_insertion_point(field_get:sentry.Forks.genesis)
  return _internal_genesis();
}
inline void Forks::unsafe_arena_set_allocated_genesis(
    ::types::H256* genesis) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(genesis_);
  }
  genesis_ = genesis;
  if (genesis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.Forks.genesis)
}
inline ::types::H256* Forks::release_genesis() {
  
  ::types::H256* temp = genesis_;
  genesis_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H256* Forks::unsafe_arena_release_genesis() {
  // @@protoc_insertion_point(field_release:sentry.Forks.genesis)
  
  ::types::H256* temp = genesis_;
  genesis_ = nullptr;
  return temp;
}
inline ::types::H256* Forks::_internal_mutable_genesis() {
  
  if (genesis_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArena());
    genesis_ = p;
  }
  return genesis_;
}
inline ::types::H256* Forks::mutable_genesis() {
  // @@protoc_insertion_point(field_mutable:sentry.Forks.genesis)
  return _internal_mutable_genesis();
}
inline void Forks::set_allocated_genesis(::types::H256* genesis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(genesis_);
  }
  if (genesis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(genesis)->GetArena();
    if (message_arena != submessage_arena) {
      genesis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, genesis, submessage_arena);
    }
    
  } else {
    
  }
  genesis_ = genesis;
  // @@protoc_insertion_point(field_set_allocated:sentry.Forks.genesis)
}

// repeated uint64 forks = 2;
inline int Forks::_internal_forks_size() const {
  return forks_.size();
}
inline int Forks::forks_size() const {
  return _internal_forks_size();
}
inline void Forks::clear_forks() {
  forks_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Forks::_internal_forks(int index) const {
  return forks_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Forks::forks(int index) const {
  // @@protoc_insertion_point(field_get:sentry.Forks.forks)
  return _internal_forks(index);
}
inline void Forks::set_forks(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  forks_.Set(index, value);
  // @@protoc_insertion_point(field_set:sentry.Forks.forks)
}
inline void Forks::_internal_add_forks(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  forks_.Add(value);
}
inline void Forks::add_forks(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_forks(value);
  // @@protoc_insertion_point(field_add:sentry.Forks.forks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
Forks::_internal_forks() const {
  return forks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
Forks::forks() const {
  // @@protoc_insertion_point(field_list:sentry.Forks.forks)
  return _internal_forks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
Forks::_internal_mutable_forks() {
  return &forks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
Forks::mutable_forks() {
  // @@protoc_insertion_point(field_mutable_list:sentry.Forks.forks)
  return _internal_mutable_forks();
}

// -------------------------------------------------------------------

// StatusData

// uint64 network_id = 1;
inline void StatusData::clear_network_id() {
  network_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StatusData::_internal_network_id() const {
  return network_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StatusData::network_id() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.network_id)
  return _internal_network_id();
}
inline void StatusData::_internal_set_network_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  network_id_ = value;
}
inline void StatusData::set_network_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_network_id(value);
  // @@protoc_insertion_point(field_set:sentry.StatusData.network_id)
}

// .types.H256 total_difficulty = 2;
inline bool StatusData::_internal_has_total_difficulty() const {
  return this != internal_default_instance() && total_difficulty_ != nullptr;
}
inline bool StatusData::has_total_difficulty() const {
  return _internal_has_total_difficulty();
}
inline const ::types::H256& StatusData::_internal_total_difficulty() const {
  const ::types::H256* p = total_difficulty_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& StatusData::total_difficulty() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.total_difficulty)
  return _internal_total_difficulty();
}
inline void StatusData::unsafe_arena_set_allocated_total_difficulty(
    ::types::H256* total_difficulty) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_difficulty_);
  }
  total_difficulty_ = total_difficulty;
  if (total_difficulty) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.StatusData.total_difficulty)
}
inline ::types::H256* StatusData::release_total_difficulty() {
  
  ::types::H256* temp = total_difficulty_;
  total_difficulty_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H256* StatusData::unsafe_arena_release_total_difficulty() {
  // @@protoc_insertion_point(field_release:sentry.StatusData.total_difficulty)
  
  ::types::H256* temp = total_difficulty_;
  total_difficulty_ = nullptr;
  return temp;
}
inline ::types::H256* StatusData::_internal_mutable_total_difficulty() {
  
  if (total_difficulty_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArena());
    total_difficulty_ = p;
  }
  return total_difficulty_;
}
inline ::types::H256* StatusData::mutable_total_difficulty() {
  // @@protoc_insertion_point(field_mutable:sentry.StatusData.total_difficulty)
  return _internal_mutable_total_difficulty();
}
inline void StatusData::set_allocated_total_difficulty(::types::H256* total_difficulty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_difficulty_);
  }
  if (total_difficulty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_difficulty)->GetArena();
    if (message_arena != submessage_arena) {
      total_difficulty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, total_difficulty, submessage_arena);
    }
    
  } else {
    
  }
  total_difficulty_ = total_difficulty;
  // @@protoc_insertion_point(field_set_allocated:sentry.StatusData.total_difficulty)
}

// .types.H256 best_hash = 3;
inline bool StatusData::_internal_has_best_hash() const {
  return this != internal_default_instance() && best_hash_ != nullptr;
}
inline bool StatusData::has_best_hash() const {
  return _internal_has_best_hash();
}
inline const ::types::H256& StatusData::_internal_best_hash() const {
  const ::types::H256* p = best_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& StatusData::best_hash() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.best_hash)
  return _internal_best_hash();
}
inline void StatusData::unsafe_arena_set_allocated_best_hash(
    ::types::H256* best_hash) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(best_hash_);
  }
  best_hash_ = best_hash;
  if (best_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.StatusData.best_hash)
}
inline ::types::H256* StatusData::release_best_hash() {
  
  ::types::H256* temp = best_hash_;
  best_hash_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H256* StatusData::unsafe_arena_release_best_hash() {
  // @@protoc_insertion_point(field_release:sentry.StatusData.best_hash)
  
  ::types::H256* temp = best_hash_;
  best_hash_ = nullptr;
  return temp;
}
inline ::types::H256* StatusData::_internal_mutable_best_hash() {
  
  if (best_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArena());
    best_hash_ = p;
  }
  return best_hash_;
}
inline ::types::H256* StatusData::mutable_best_hash() {
  // @@protoc_insertion_point(field_mutable:sentry.StatusData.best_hash)
  return _internal_mutable_best_hash();
}
inline void StatusData::set_allocated_best_hash(::types::H256* best_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(best_hash_);
  }
  if (best_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(best_hash)->GetArena();
    if (message_arena != submessage_arena) {
      best_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, best_hash, submessage_arena);
    }
    
  } else {
    
  }
  best_hash_ = best_hash;
  // @@protoc_insertion_point(field_set_allocated:sentry.StatusData.best_hash)
}

// .sentry.Forks fork_data = 4;
inline bool StatusData::_internal_has_fork_data() const {
  return this != internal_default_instance() && fork_data_ != nullptr;
}
inline bool StatusData::has_fork_data() const {
  return _internal_has_fork_data();
}
inline void StatusData::clear_fork_data() {
  if (GetArena() == nullptr && fork_data_ != nullptr) {
    delete fork_data_;
  }
  fork_data_ = nullptr;
}
inline const ::sentry::Forks& StatusData::_internal_fork_data() const {
  const ::sentry::Forks* p = fork_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentry::Forks&>(
      ::sentry::_Forks_default_instance_);
}
inline const ::sentry::Forks& StatusData::fork_data() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.fork_data)
  return _internal_fork_data();
}
inline void StatusData::unsafe_arena_set_allocated_fork_data(
    ::sentry::Forks* fork_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fork_data_);
  }
  fork_data_ = fork_data;
  if (fork_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.StatusData.fork_data)
}
inline ::sentry::Forks* StatusData::release_fork_data() {
  
  ::sentry::Forks* temp = fork_data_;
  fork_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sentry::Forks* StatusData::unsafe_arena_release_fork_data() {
  // @@protoc_insertion_point(field_release:sentry.StatusData.fork_data)
  
  ::sentry::Forks* temp = fork_data_;
  fork_data_ = nullptr;
  return temp;
}
inline ::sentry::Forks* StatusData::_internal_mutable_fork_data() {
  
  if (fork_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentry::Forks>(GetArena());
    fork_data_ = p;
  }
  return fork_data_;
}
inline ::sentry::Forks* StatusData::mutable_fork_data() {
  // @@protoc_insertion_point(field_mutable:sentry.StatusData.fork_data)
  return _internal_mutable_fork_data();
}
inline void StatusData::set_allocated_fork_data(::sentry::Forks* fork_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fork_data_;
  }
  if (fork_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fork_data);
    if (message_arena != submessage_arena) {
      fork_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fork_data, submessage_arena);
    }
    
  } else {
    
  }
  fork_data_ = fork_data;
  // @@protoc_insertion_point(field_set_allocated:sentry.StatusData.fork_data)
}

// uint64 max_block = 5;
inline void StatusData::clear_max_block() {
  max_block_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StatusData::_internal_max_block() const {
  return max_block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StatusData::max_block() const {
  // @@protoc_insertion_point(field_get:sentry.StatusData.max_block)
  return _internal_max_block();
}
inline void StatusData::_internal_set_max_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  max_block_ = value;
}
inline void StatusData::set_max_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_block(value);
  // @@protoc_insertion_point(field_set:sentry.StatusData.max_block)
}

// -------------------------------------------------------------------

// SetStatusReply

// -------------------------------------------------------------------

// HandShakeReply

// .sentry.Protocol protocol = 1;
inline void HandShakeReply::clear_protocol() {
  protocol_ = 0;
}
inline ::sentry::Protocol HandShakeReply::_internal_protocol() const {
  return static_cast< ::sentry::Protocol >(protocol_);
}
inline ::sentry::Protocol HandShakeReply::protocol() const {
  // @@protoc_insertion_point(field_get:sentry.HandShakeReply.protocol)
  return _internal_protocol();
}
inline void HandShakeReply::_internal_set_protocol(::sentry::Protocol value) {
  
  protocol_ = value;
}
inline void HandShakeReply::set_protocol(::sentry::Protocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:sentry.HandShakeReply.protocol)
}

// -------------------------------------------------------------------

// MessagesRequest

// repeated .sentry.MessageId ids = 1;
inline int MessagesRequest::_internal_ids_size() const {
  return ids_.size();
}
inline int MessagesRequest::ids_size() const {
  return _internal_ids_size();
}
inline void MessagesRequest::clear_ids() {
  ids_.Clear();
}
inline ::sentry::MessageId MessagesRequest::_internal_ids(int index) const {
  return static_cast< ::sentry::MessageId >(ids_.Get(index));
}
inline ::sentry::MessageId MessagesRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:sentry.MessagesRequest.ids)
  return _internal_ids(index);
}
inline void MessagesRequest::set_ids(int index, ::sentry::MessageId value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:sentry.MessagesRequest.ids)
}
inline void MessagesRequest::_internal_add_ids(::sentry::MessageId value) {
  ids_.Add(value);
}
inline void MessagesRequest::add_ids(::sentry::MessageId value) {
  // @@protoc_insertion_point(field_add:sentry.MessagesRequest.ids)
  _internal_add_ids(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
MessagesRequest::ids() const {
  // @@protoc_insertion_point(field_list:sentry.MessagesRequest.ids)
  return ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MessagesRequest::_internal_mutable_ids() {
  return &ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MessagesRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:sentry.MessagesRequest.ids)
  return _internal_mutable_ids();
}

// -------------------------------------------------------------------

// PeerCountRequest

// -------------------------------------------------------------------

// PeerCountReply

// uint64 count = 1;
inline void PeerCountReply::clear_count() {
  count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PeerCountReply::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PeerCountReply::count() const {
  // @@protoc_insertion_point(field_get:sentry.PeerCountReply.count)
  return _internal_count();
}
inline void PeerCountReply::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  count_ = value;
}
inline void PeerCountReply::set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:sentry.PeerCountReply.count)
}

// -------------------------------------------------------------------

// PeersRequest

// -------------------------------------------------------------------

// PeersReply

// .types.H512 peer_id = 1;
inline bool PeersReply::_internal_has_peer_id() const {
  return this != internal_default_instance() && peer_id_ != nullptr;
}
inline bool PeersReply::has_peer_id() const {
  return _internal_has_peer_id();
}
inline const ::types::H512& PeersReply::_internal_peer_id() const {
  const ::types::H512* p = peer_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& PeersReply::peer_id() const {
  // @@protoc_insertion_point(field_get:sentry.PeersReply.peer_id)
  return _internal_peer_id();
}
inline void PeersReply::unsafe_arena_set_allocated_peer_id(
    ::types::H512* peer_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  peer_id_ = peer_id;
  if (peer_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentry.PeersReply.peer_id)
}
inline ::types::H512* PeersReply::release_peer_id() {
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H512* PeersReply::unsafe_arena_release_peer_id() {
  // @@protoc_insertion_point(field_release:sentry.PeersReply.peer_id)
  
  ::types::H512* temp = peer_id_;
  peer_id_ = nullptr;
  return temp;
}
inline ::types::H512* PeersReply::_internal_mutable_peer_id() {
  
  if (peer_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArena());
    peer_id_ = p;
  }
  return peer_id_;
}
inline ::types::H512* PeersReply::mutable_peer_id() {
  // @@protoc_insertion_point(field_mutable:sentry.PeersReply.peer_id)
  return _internal_mutable_peer_id();
}
inline void PeersReply::set_allocated_peer_id(::types::H512* peer_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id_);
  }
  if (peer_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_id)->GetArena();
    if (message_arena != submessage_arena) {
      peer_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_id, submessage_arena);
    }
    
  } else {
    
  }
  peer_id_ = peer_id;
  // @@protoc_insertion_point(field_set_allocated:sentry.PeersReply.peer_id)
}

// .sentry.PeersReply.PeerEvent event = 2;
inline void PeersReply::clear_event() {
  event_ = 0;
}
inline ::sentry::PeersReply_PeerEvent PeersReply::_internal_event() const {
  return static_cast< ::sentry::PeersReply_PeerEvent >(event_);
}
inline ::sentry::PeersReply_PeerEvent PeersReply::event() const {
  // @@protoc_insertion_point(field_get:sentry.PeersReply.event)
  return _internal_event();
}
inline void PeersReply::_internal_set_event(::sentry::PeersReply_PeerEvent value) {
  
  event_ = value;
}
inline void PeersReply::set_event(::sentry::PeersReply_PeerEvent value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:sentry.PeersReply.event)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sentry

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sentry::PeersReply_PeerEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentry::PeersReply_PeerEvent>() {
  return ::sentry::PeersReply_PeerEvent_descriptor();
}
template <> struct is_proto_enum< ::sentry::MessageId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentry::MessageId>() {
  return ::sentry::MessageId_descriptor();
}
template <> struct is_proto_enum< ::sentry::PenaltyKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentry::PenaltyKind>() {
  return ::sentry::PenaltyKind_descriptor();
}
template <> struct is_proto_enum< ::sentry::Protocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentry::Protocol>() {
  return ::sentry::Protocol_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_p2psentry_2fsentry_2eproto
